--- Test 'HashMap' properties
module tests.qc.HM where

import Test.QuickCheck
import Data.HashMap H hiding(!!)

instance Arbitrary (Eq k, Arbitrary k, Arbitrary v) => (HashMap k v) where
    arbitrary = sized (\n → vector (2*n) 
            >>= return . fold (\hm \(k, v) -> H.insert k v hm) HashMap.empty) 

--- invariants are met before and after insert
p_invInsert = property hminsert
    where
        hminsert :: HashMap String Int -> String -> Int -> Property
        hminsert hm s i = collect 
                ("map size <%3d00".format (1 + H.size hm `quot` 100) :: String) 
                (hm.invariants && (H.insert s i hm).invariants)

--- invariants are met before and after delete
p_invDelete = property hmdelete
    where
        hmdelete :: HashMap Byte Int -> Byte -> Property
        hmdelete hm k = collect 
                (maybe "non existing key" (const "existing key") (lookup k hm)) 
                (hm.invariants && (H.delete k hm).invariants)
{-- 
    check the property that first inserted values are not evaluated,
    unless the update function is strict in the second argument.
-}
p_undefUpdate = once prop
    where 
        prop :: HashMap String Int -> Bool
        prop = maybe false (==7) 
                    . lookup "foo" 
                    . insert "foo" 7 
                    . insert "foo" undefined
                    . delete "foo"

--- a previously inserted value will be found by lookup
p_lookupJust = property hmlookup
    where
        hmlookup :: HashMap String Int -> String -> Int -> Property
        hmlookup hm s i = collect 
                ("map size <%3d00".format (1 + H.size hm `quot` 100) :: String) 
                (lookup s (insert s i hm) == Just i)

--- a previously deleted value will not be found by lookup
p_lookupNothing = property prop
    where
        prop :: HashMap Byte Int -> Byte -> Property
        prop hm k = collect 
                (maybe "non existing key" (const "existing key") (lookup k hm)) 
                (lookup k (delete k hm) == Nothing)

--- deleting all possible keys will leave an empty map
p_deleteAll = property prop
    where
        prop :: HashMap Byte Int -> Property
        prop hm = collect 
                ("map size <%3d00".format (1 + H.size hm `quot` 100) :: String)
                (HashMap.null (foldr delete hm all))
        all = [minBound .. maxBound] 
 
--- A maps size is the same as the length of the keys list
p_sizekeys = property prop
    where
        prop ∷ HashMap String Float → Bool
        prop hm = size hm == length (keys hm)

--- keys and values can be created from each, and vice versa
p_kveach = property prop
    where
        prop ∷ HashMap String Double → Bool
        prop hm = each hm == zip (keys hm) (values hm)

--- keys from a HashMap are unique
p_uniqueKeys = property prop
    where
        prop ∷ HashMap String Double → Bool
        prop hm = uni (keys hm)
        uni (x:xs) = x `notElem` xs && uni xs
        uni []  = true
        uni [x] = true