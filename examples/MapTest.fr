--- Test various map implementations
module examples.MapTest where

-- import frege.Prelude hiding(uniq)
import Data.TreeMap T()
import Data.HashMap HM(HashMap)
import Data.JSON(toJSON)
import Java.Util(HashMap JHM)


main ["count", "tree"] = count  0 >>= println  
main ["uniq", "tree"] = do
    t <- uniqt T.Tree.empty
    println $ sumt t
    println $ size t

main ["uniq", "hash"] = do
    t <- uniqh HashMap.empty
    -- println $ sumt t
    println $ sum (HM.values t)
    println $ HM.size t

main ["uniq", "java"] = do
    t <- JHM.new ()
    t <- uniqj t
    t.values >>= _.iterator >>= Util.Iterator.fold (+) 0 >>= println
    t.size >>= println


main ["coll", "hash"] = do
    t <- uniqh HashMap.empty
    println $ sum (HM.values t)
    println $ HM.size t
    println $ toJSON (t.collisions)


main ["words"] = thewords

main ["hashtest"] = do
    let e = HashMap.empty :: HashMap Int String
    let hm1 = HM.insert 1 "foo" e
    let hm2 = HM.insert 0x40000001 "bar" hm1
    let hm3 = HM.insert 0x80000001 "foobar" hm2
    println (HashMap.invariants e)
    println (toJSON e)
    println (HashMap.invariants hm1)
    println (toJSON hm1)
    println (HashMap.invariants hm2)
    println (toJSON hm2)
    println (HashMap.invariants hm3)
    println (toJSON hm3)
    return ()




foldTree ∷ (c → a → b → c) → c → T.Tree a b → c
foldTree f !a t
    | t.null = a
    | otherwise = foldTree f (foldTree f (f a t.key t.value) t.right) t.left

size ∷ T.Tree 𝖆 𝖇 → Int
size t = foldTree (\n\_\_ -> n+1) 0 t

sumt ∷ T.Tree 𝖆 Int → Int
sumt t = foldTree (\n\_\v -> n+v) 0 t

thewords :: IO ()
thewords = do
        more ← stdin.readLine
        case more of
            Just line → do
                mapM_ println (
                    zipWith (++) 
                        (cycle (map ctos ['!'..'~'])) 
                        (line ~~* '\w+')) 
                thewords
            Nothing   → return ()

uniqt :: T.Tree String Int -> IO (T.Tree String Int)
uniqt !tree = do
        more ← stdin.readLine
        case more of
            Just line → uniqt (process tree line)
            Nothing   → return tree
    where
        process ∷ T.Tree String Int → String → T.Tree String Int
        process tree s = tree.insert  s n
            where !n = 1 + fromMaybe 0 (tree.lookup s)

uniqj :: MutableIO (JHM String Int) -> IOMutable (JHM String Int)
uniqj !jmh = do
        more ← stdin.readLine
        case more of
            Just line → do
                v <- jmh.get line
                jmh.put line (maybe 1 (1+) v)
                uniqj jmh
            Nothing   → return jmh

private pure native sumHashMap MapTest.sumHM :: JHM String Int -> Int
native module where {
    static int sumHM(java.util.HashMap<java.lang.String, java.lang.Integer> hm) {
        int sum = 0;
        for (Integer i : hm.values()) {
            sum += i;
        }
        return sum;
    }
}

uniqh :: HashMap String Int -> IO (HashMap String Int)
uniqh !hmap = do
        more ← stdin.readLine
        case more of
            Just line → uniqh (HM.insertWith (+) line 1 hmap)
            Nothing   → return hmap

count !e = 
        fmap addwords <$> stdin.readLine 
            >>= maybe (return e) count
    where
        addwords s = e + (loop 0 (s =~ '\w+')) 
        loop ∷ Int → Maybe Matcher → Int
        loop !n Nothing  = n
        loop !n (Just m) = loop (n+1) m.find

