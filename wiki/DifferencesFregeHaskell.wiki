#summary Brief Summary of Differences between Frege and Haskell
#labels Featured

This document is intended for people who have a working knowledge of Haskell and want to write Frege code. The objective is not to describe each difference in every detail. For this, please consult the Frege Language Reference Manual, that can be obtained from the [http://code.google.com/p/frege/downloads/list download page]. It is rather just an overview with brief explanations. 
However, if you feel some difference you stumble upon should be included here, please open an issue on the [http://code.google.com/p/frege/issues/list project page].

I refer to the Haskell language as described in the [http://haskell.org/definition/haskell2010.pdf “Haskell 2010 Language Report”]. This document follows in structure the Haskell 2010 Language Report. I give the section numbers for easy reference. Most of the time I will not repeat how things are in Haskell, for example I will not write "_In Haskell, this is such and such, whereas in
Frege, it is thus._" Rather, I just write "_thus_".
Words and phrases like "_not yet_", "_currently_", "_at this time_" etc. indicate the possibility, that the incompatibility they refer to will be eliminated later.

= Library/Prelude =

The Frege-Prelude defines many functions, type classes and types known from Haskell in a similar way. Apart from that, everything else will be quite different, because Frege uses the Java APIs whenever possible. At the time being, there is not much library support yet.

= 1.4 Namespaces / 5 Modules =

The compilation unit is a _package_ or _module_, whose name is a dot-separated sequence of identifiers, where the last one must start with an uppercase letter. 
Packages names are used only in import clauses. In all other cases, they are referenced by the simple name that was assigned in the import clause or, if there was none assigned, by the last component of the package name. This is known as _name space identifier_.

There are no export clauses. Constructors, functions and data types that must not be accessible from other modules can be marked *`private`*. A data type declaration can be marked *`abstract`*, this is equivalent to making all constructors private.

Every module, not just `Main`, can have a function
{{{
main :: [String] -> IO ()
}}}
Execution of the Java class file that results from compiling of such a package will apply this function to the list of command line arguments and then run the resulting IO action.

= 2.3 Comments =

Comments introduced with `{--` (block comment) or `---` (line comment) are treated as _documentation text_. Documentation text looks like a comment, but is syntactically a single token that may occur at certain points in the program only. The text of the comment makes it down to the compiled module (Java class file) from where it can be retrieved
later, for example by documentation tools.

= 2.4 Identifiers and Operators =

  * `default`, `deriving`, `foreign` and `newtype` are not keywords.
  * *`abstract`*, *`derive`*, *`false`*, *`native`*, *`package`*, *`private`*, *`protected`*, *`public`*, *`pure`* and *`true* are keywords.
  * Currently, no identifier may start with an underscore except the identifier `_`. The latter may only appear in patterns, where it signals an uninteresting value, as usual.
  * Identifiers and operators can be qualified with name space identifiers.
  * The only operator allowed as data constructor is *`:`* 
  * *`!`* and *`?`* are _unary_ operators. Unary operators bind yet stronger than function application, so that `f !a` is parsed as `f (!a)`
  * Frege has 18 precedence levels, 16 can be assigned to user defined operators. The *`infix`* directives work on the lexical level only.

Here is the table of standard operators from the Prelude:
{{{
--       18 `!` `?`                -- unary operators
--       17                        -- function application
infixr   16 `<~`  `•`              -- a <~ (b <~ c) == (c ~> b) ~> a
infixl   16 `!!` `~>`
infixr   15 `**` `??` 
infix    15 `=~` `!~` `?~` `/~`  `~` `~~` `~~~`
infixl   14 `*` `/` `%` `mod` `rem` `div` `quot`
infixl   13 `+`                    -- `-` is handled specially
infixr   13 `++`
infixl   12 `<<` `bshl` `bshr`
infixl   11 `band`
infixl   10 `bor` `bxor`
infix     9 `<=` `>=` `<` `>` `elem` `notElem`
infix     8 `<=>` `compare`
infix     7 `==` `!=` `/=` `===` `!==` 
infixr    6 `&&`  `and`
infixr    5 `||`  `or` `xor`
infix     4 `..`
infixr    4 `:`
infixr    3 `>>` `>>=`              -- monad bind
infixr    2 `:=` `=<<` `@` `seq`    -- so that in x@a:bs 
                                    -- x is bound to the list
infixr    1 `$` `$!`
}}}

= 2.5 Numeric Literals = 

Frege accepts Java style numeric literals, except hexadecimal floating point literals. In addition, integer literals can have trailing groups of 3 digits separated by underscores.

A decimal integer literal followed by the letter `n` or `N` has type `Integer`, for other numeric literals one gets the Frege type by capitalizing the first letter of the name of the type that the literal would have in Java (i.e. `int` -> `Int`, `float` -> `Float`).

Numeric literals are not overloaded. The `Num` class has a function
{{{
fromInt :: Num a => Int -> a
}}}
that can be used to overload integer literals manually.

= 2.6 Character and String Literals =

Character and string literals are the same as in Java. A string literal denotes a value of type `String`. A string value is not a list of characters but an instance of the Java class java.lang.String.

Prelude functions `packed` and `unpacked` convert from lists of characters to strings and back.

== Regular expression literals ==

A sequence of characters included in number signs `#` denotes a value of type `Regex`, which is the Frege incarnation of `java.util.regex.Pattern`.

== Boolean literals ==

Because `Bool` is not an algebraic data type in Frege but an abstract one that wraps the `boolean` type of Java there  are no constructors `True` and `False`. Rather, the keywords *`true`* and *`false`* act as literals for the two boolean values.

= 2.7 Layout = 

  * The token following a *`where`*, *`let`*, *`do`* or *`of`* keyword must be an opening brace or it must be more indented than the current level, otherwise the layout algorithm will insert a closing brace which will result in a syntax error. In other words, the token sequence { } will never be inserted.
  * The handling of layout is a pure lexical matter in Frege, hence, it is not possible to insert a closing brace “if an illegal lexeme is encountered at a point where a close brace would be legal”.
  * However, a closing brace is inserted before the keyword *`in`* regardless of the indentation unless it is already preceded by a closing brace. Therefore one can still write let expressions without braces on a single line like so: 
{{{
let a = 6; b=7 in a*b
}}}

= 3 Expressions, Patterns =

  * The expression hierarchy is different from Haskell’s. *`if`*, *`case`* and *`let`* expressions as well as lambda abstractions bind less tightly than infix expressions, while *`do`* expressions are terms (aka _aexp_). In practice, this should seldom make a difference as to how expressions are parsed.
  * A lambda abstraction has exactly one pattern. However, `\a -> \b -> x` can be abbreviated as `\a \b -> x`
  * There are no arithmetic sequences yet. The `..` operator from the `Enum` class may serve as a poor substitute in some cases. The following holds 
{{{
a..b = takeWhile (<=b) (iterate succ a)
}}}
Note that `a..b` is an ordinary infix expression and is not written in brackets - no syntactic sugar here.
  * There is a whole range of syntactic sugar for field access, test for field existence, nondestructive update of data values with fields and nondestructive change of values through application of functions to fields. This applies to algebraic data types that have constructors with field labels.
  * If _e_ has type _T u1 ... uk_, the expression _e.f_ is transformed to _(T.f e)_, i.e. the function _f_ from namespace _T_ applied to _e_. Otherwise, if _f_ is a type class operation of type class C it means _(C.f e)_. This is so because every type (constructor) name and class name is associated with a separate name space.
  * The function composition operator is `•` (an alias `<~` is provided). The character can be produced by holding the ALT key and typing 0149 on the numeric keypad (at least this is how it works on keyboards with german layouts). Every decent programmer's editor should be able to bind arbitrary characters like `•` to key combinations like Ctrl+.
  * There is no notation to make a pattern irrefutable. However, patterns of product types like tuples are irrefutable unless they contain refutable sub-patterns. In general, all products are matched as lazily as possible.
  * The precedence rules for patterns are subtly different from Haskell's, but one easy rule is enough to understand them: In Frege, patterns are syntactically just expressions (in fact, there is not even a separate grammar rule for patterns), though of course only a subset of all possible expressions make valid patterns. 
A consequence is that if the left hand side of a binding is syntactically an application of some function, it will be interpreted
as function binding for that function. Hence, `f y@(x:xs) = ...` is taken as an attempt to define the @ operator, even if `f y` is not a valid pattern (which causes this attempt to fail, but only after it is parsed). If one meant to define a function f that takes a list y with head x and tail xs, one writes `f (y@x:xs) = ...`.
   * Likewise, application of `!` is syntactically an unary expression, not an application, therefore a construct like `!p = ...` is interpreted as (strict) binding for pattern _p_ and 
{{{
f !x !y = ...
}}}
binds `f` to a function that takes 2 strict arguments.

= 4.2 User-Defined Datatypes =

  * No constraints can be specified in constructor declarations.
  * Infix notation can not be used in constructor declarations (but is possible in constructor application).
  * Every type declared with *`data`* owns a namespace. The data declaration can have a where clause, and value bindings in the scope of that where clause go in the type’s namespace. Qualified access of those bindings is possible, the qualifier is the type constructor name.
  * Field labels are not global, but live in the namespace associated with the type. Hence, if type _T_ has a (data constructor that has a) field _m_ and the type of _e_ is an application of _T_, then _e.m_ accesses the field and _T.m_ is a function that extracts the field from any value _v_ whose type is an application of _T_, provided _v_ was constructed with a data constructor in whose field list _m_ appears.
  * There is no *`deriving`* clause. See below for *`derive`* declarations that serve the same purpose.
  * No strictness flags on individual fields are possible, instead the whole variant can be made strict by placing a `!` before the constructor in data type declaration. This causes the constructor to be strict in all arguments and all fields are kept in weak head normal form or in unboxed native form for fields with native types.
  * Any Java class or interface can be declared as an abstract Frege types.

== 4.2.3 Datatype Renamimgs ==

There is no *`newtype`* keyword. An algebraic data type with exactly one constructor with exactly one field serves the same purpose.

== 4.3.1 and 4.3.2 Constraints in Class and Instance Declarations ==

The Frege syntax reflects the idea, that a context is part of a type. Therefore, instead of 
{{{
class Eq a => Ord a
instance (Ord a, Ord b) => Ord (a,b)
}}}
we write 
{{{
class Ord Eq a => a
instance Ord (Ord a, Ord b) => (a, b)
}}}
Hence, the class we are talking about comes next to the keyword, followed by the type we are talking about.

== 4.3.2 Intance Declarations ==

  * Type synonyms in instance declarations are allowed.
  * The arguments to a type constructor need not be distinct type variables, they can also be type applications or the same type variable can be used more than once. However, since at most one instance per class and type constructor may be in place, this is not generally recommended. In addition, I am not sure if this will work with multi-parameter classes and instances (not yet implmented), so the best bet is to stick with the Haskell 2010 rules.
  * Function types cannot be instances of type classes, use datatype renamings for that.

== 4.3.3 Derived Instances ==

A variant of the instance declaration uses the keyword *`derive`* in place of *`instance`* and lacks a where clause. It serves the same purpose as the deriving keyword in Haskell, but because it is independent of the data declaration it can occur everywhere
an instance declaration can, even in a different module. Hence, class, data and derive declarations could be in up to 3 different modules.

Currently, instances for `Eq`, `Ord`, `Show`, `Enum` and `Bounded` can be derived.
Derived Show instances currently do not show field labels.

= 8 Foreign Function Interface =

Frege has language constructs to
  * use any existing Java primitive, class or interface type as abstract data type. Actually, all basic types like Bool, Char, Int, Long, Integer, Float, Double, String, Regex are just abstract datatypes borrowed from Java.
  * make existing java methods and even java operators available as Frege functions. These are known as _native functions_.

Note that while the interoperability with other languages is not strictly restricted to Java it certainly can't cross the border of the JVM.