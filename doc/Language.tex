\documentclass[a4paper,landscape,twocolumn]{report}
\usepackage[a4paper]{geometry}
\geometry{landscape,a4paper,left=2cm,right=2cm,bottom=1.5cm}
\columnseprule1pt
\columnsep0.7cm
\usepackage{makeidx}
\usepackage[latin1]{inputenc}
%\usepackage{german}
\usepackage{alltt}
\usepackage{verbatim}
\usepackage[dvipdfm]{color}
\usepackage[
    bookmarks,
    colorlinks,
    linkcolor=blue
]{hyperref}
\usepackage{epsfig}
\usepackage{graphicx}

\definecolor{grau}{rgb}{0.95, 0.95, 0.95}
\definecolor{gelb}{rgb}{0.95, 0.95, 0.5}
\definecolor{rot}{rgb}{0.95, 0.8, 0.8}
\definecolor{gruen}{rgb}{0.8, 0.95, 0.8}
\definecolor{blau}{rgb}{0.8, 0.8, 0.95}
\definecolor{rgxblau}{rgb}{0.0, 0.0, 0.5}
\definecolor{trmred}{rgb}{0.2, 0.1, 0.1}

\newenvironment{code}[0]{\verbatim}{\endverbatim}
\newcommand{\exq}[1]{\begin{quote}\begin{alltt}#1\end{alltt}\end
{quote}}
\newcommand{\ex}[1]{\begin{alltt}#1\end{alltt}}
\newcommand{\boxquote}[3]{
\begin{center}
\colorbox{#1}%
{\parbox{0.45\textwidth}{
\sf
\underline{#2}:
#3
}}
\end{center}}
\newcommand{\hasdiff}[1]{\boxquote{rot}{Difference to \haskell{} 98}{#1}}
\newcommand{\note}[1]{\boxquote{grau}{Note}{#1}}
\newcommand{\trans}[1]{\boxquote{gelb}{Translation}{#1}}
\newcommand{\inmargin}[1]{\marginpar{\scriptsize\raggedright #1}}
\newcommand{\example}[1]{\boxquote{gruen}{Example}{#1}}

\newcommand{\haskell}[0]{\textsc{Haskell}}
\newcommand{\frege}[0]{\textsc{Frege}}
\newcommand{\java}[0]{\textsc{Java}}
\newcommand{\arrow}[0]{\begin{math}\rightarrow\end{math}}
\newcommand{\qq}[1]{"#1"}

\newcommand{\jex}[1]{\emph{\textcolor{rgxblau}{jex}}{\Large (}#1{\Large )}}
\newcommand{\ftn}[1]{\emph{\textcolor{rgxblau}{Ftn}}{\Large (}#1{\Large )}}
\newcommand{\jtn}[1]{\emph{\textcolor{rgxblau}{Jtn}}{\Large (}#1{\Large )}}
\newcommand{\unbox}[1]{#1\texttt{.unbox()}}
\newcommand{\tobox}[2]{\ftn{#1}\-\texttt{.box(}#2\texttt{)}}
\newcommand{\cons}[3] {\ftn{#1}\-\texttt{.new(#2 #3)}}

\newcommand{\term}[1]{\textbf{\texttt{\textcolor{trmred}{#1}}}}
\newcommand{\regex}[1]{\texttt{\textcolor{rgxblau}{#1}}}
\newcommand{\sym}[1]{\textbf{\texttt{\textcolor{trmred}{#1}}}}
\newcommand{\gcom}[1]{{\hspace{\fill}\scriptsize (#1)}}

\newcommand{\brackz}[0]{\textbf{\texttt{\textcolor{trmred}{]}}}}
\newcommand{\bracka}[0]{\textbf{\texttt{\textcolor{trmred}{[}}}}
\newcommand{\bracea}[0]{\textbf{\texttt{\textcolor{trmred}{\{}}}}
\newcommand{\bracez}[0]{\textbf{\texttt{\textcolor{trmred}{\}}}}}

\newcommand{\nont}[1]{\textit{#1}}
\newcommand{\some}[1]{{\Large \{}#1{\Large \}}}
\newcommand{\opt}[1]{{\Large [} #1 {\Large ]}}
\newcommand{\more}[1]{#1 {\Large \{} #1 {\Large \}}}
\newcommand{\liste}[2]{#1\some{#2 #1}}
\newcommand{\rul}[1]{\nont{#1}:\\\hspace{0.5in} }
\newcommand{\alt}[0]{\\\hspace{0.5in}{\Large $|$} }
\newcommand{\oder}[0]{{\Large $|$}}
\newcommand{\checked}[1]{#1!}

\makeindex

\parindent0cm
\oddsidemargin0.5cm
\evensidemargin0.5cm
%\textwidth12cm
\parskip2mm
\pagestyle{headings}

\date{last changed \today{} \\ $Revision$}
\author{\small{by Ingo Wechsung}}
\title{The \frege{} Programming Language}

\begin{document}
%\frontmatter
\maketitle


\begingroup 
\let\onecolumn\twocolumn 

\begin{abstract}

%\begin{center}\textbf{Abstract}\end{center}
This document describes the functional programming language \frege{}
and its implementation
for the \java{} virtual machine. Commonplace features of \frege{} are
type inference,
lazy evaluation,
modularization and separate compile-ability,
algebraic data types and type classes,
pattern matching and list comprehension.

Distinctive features are, first, that the type system supports
\emph{higher ranked polymorphic types},
and, second,
that \frege{} code is compiled to \java{}.
This allows for maximal interoperability with existing
\java{} software.
Any \java{} class may be used as an abstract data type, \java{}
functions and methods may be called from \frege{} functions and vice
versa.

Despite this interoperability feature  \frege{} is a pure functional language as long as impure \java{} functions are declared accordingly.

\begin{center}\textbf{What is or who was Frege?}\end{center}

%\inmargin{In honor of \\ J. G. Frege}
Johann Gottlob Frege
\index{Frege!Johann Gottlob}
was a
German mathematician, who, in the second half of the 19th
century tried to establish the foundation of mathematics in pure
logic. Although this attempt failed in the very moment when he
was about to publish his book \emph{Grundgesetze der Arithmetik},
he is nevertheless recognized as the father of modern logic among
philosophers and mathematicians.

In his essay \emph{Funktion und Begriff} \cite{f1891} Frege introduces a function that takes another function as argument and remarks:

\begin{quote}
\small{
Eine solche Funktion ist offenbar grundverschieden von den bisher betrachteten; denn als ihr Argument kann nur eine Funktion auftreten. Wie nun Funktionen von Gegenständen grundverschieden sind, so sind auch Funktionen, deren Argumente Funktionen sind und sein müssen, grundverschieden von Funktionen, deren Argumente Gegenstände sind und nichts anderes sein können. Diese nenne ich Funktionen erster, jene Funktionen zweiter Stufe.
}
\end{quote}

And, as if this was not confusing enough, he continues  later:

\begin{quote}
{\small
Man muß bei den Funktionen zweiter Stufe mit einem Argumente unterscheiden,
je nachden als dies Argument eine Funktion mit einem oder eine solche mit zwei Argumenten erscheinen kann; 
denn eine Funktion mit einem Argumente ist so wesentlich verschieden von einer solchen mit zwei Argumenten,
daß die eine nicht an eben der Stelle als Argument auftreten kann, wo die andere es kann.
}
\end{quote}

In my opinion, this makes \emph{Frege} a very good name for a functional programming language with a strong type system.

\begin{center}\textbf{Acknowledgments}\end{center}

Heartily thanks go to the whole functional language community and
especially to the authors and contributors of
\emph{The Haskell 98 Report} \cite{h98r} and \emph{Haskell 2010 Language Report} \cite{h2010}.
This documents structure closely reproduces that of the latter one as knowledgeable people will
easily spot.

I am especially grateful to Simon Peyton Jones, John Hughes and Philip
Wadler. By publishing their knowledge
and wisdom in numerous papers and books accessible through the internet
these men of genius enrich the world and make it a better place.

\end{abstract}

\tableofcontents

\listoffigures
\endgroup

%\mainmatter

\chapter{Introduction}

%\section{The \frege{} language}

\frege{} is a functional language influenced by \haskell{} with
the following features:

\begin{itemize}

\item haskell{} ({\tt www.haskell.org}) like syntax

\item type safety through a strong type system with type inference. The
type inference mechanism is based on and derived from the paper
\emph{Practical type inference for arbitrary-rank types} by Simon
Peyton Jones \cite{ptifart}, to whom I am greatly indebted.

Type inference by the compiler means that it is
almost never necessary to declare the type of variables, functions or
expressions.

\item lazy evaluation: expressions are only evaluated when they are
needed.

\item modularization through packages like in \java{}

\item rich type system with basic types, functions, regular expressions,
lists, tuples and user defined algebraic types.
In addition, types from the host language may be used as abstract
types.

\item user definable operators

\item type classes (interfaces) and instances (types that
implement interfaces) provide a form of controlled polymorphism. For
example, a sorting function may require that the values to be sorted
must support comparisons. This is also a clean and type safe way to
overload functions and operators.

\item pattern matching with guards.

\item interface to \java{}. In fact, \frege{} is
compiled to \java{} and
all primitive types and operations are borrowed from \java{}.


\end{itemize}

If you know \haskell{} or another functional language,
\frege{} will be easy to learn for you. This document contains boxes
that highlight differences to \haskell{} that look like this:

\hasdiff{Look for paragraphs like this to learn what is different in
\frege{}}

\frege{} is

\begin{description}

\item[not object oriented]

\item[no replacement]

for already established functional programming languages like Haskell,
Scala, F\# and others.
Nevertheless, \frege{} may be interesting
\begin{itemize}
\item for \java{} programmers that are interested in pure functional programming. 
\item as a substitute for \haskell{} when a functional programmer needs to do work in or for the \java{} platform. 
\end{itemize}

\end{description}

\section{Differences to \haskell{} 2010}

\note{Readers not familiar with \haskell{} may want to skip this
section.}

\begin{description}
\item[Module system]
\frege{}'s module system is based on that of \java{}. A \frege{}
program is is a collection of packages. Each \frege{}
source file defines exactly one package
and compiles to a \java{} source file with the definition of a
\texttt{public class}.


\item[Types]

Numeric literals are not overloaded in \frege{}. 

\item[Strings]
Strings are primitive types in \frege{} and are implemented
as the \java{} \texttt{java.lang.String} type.
Conversions to and
from lists of characters are provided.

\item[Regex]
\par Another primitive \frege{} type is \texttt{Regex}. It makes
powerful
and fast working functions on strings possible. A \texttt{Regex} can
also
be used as pattern for string arguments.

\end{description}

%\paragraph{What \frege{} has not}
%\begin{itemize}
%\item no syntactic support for monadic types (yet)
%\end{itemize}

\paragraph{What \frege{} has and \haskell{} 98 does not have}
\begin{itemize}
\item support for regular expressions in the language
\item records with field labels that do not pollute the name space
\item definitions that live in the scope of a data type
\item pattern guards as proposed by Simon Peyton Jones in \cite{pguards}
and meanwhile implemented in \haskell{} 2010.
\item seamless access to any \java{} class and its public members and methods
\end{itemize}

\section{Program structure}

In this section, we introduce the language structure and at the
same time give an outline of the organization of this
document.

\begin{enumerate}

\item At the topmost level, a \frege{} program is a set of
\emph{packages}, described in \autoref{packages}.

\item The top level of a package consists of a collection of
\emph{declarations},
of which there are several kinds, all described in
\autoref{declarations}.
Declarations define things such as ordinary values and functions,
data types,
type classes, fixity information.

\item At the next lower level are \emph{expressions}, described in
\autoref{expressions}.

\item At the bottom level is the lexical structure, described in
\autoref{lexical structure}.

\end{enumerate}

The last section describes  the native interface
(\autoref{native interface}).
%Also there are several appendices.

Examples of \frege{} program fragments in running text are given in
typewriter font. Sometimes examples are given in a form of
colored pseudo code,
with indexed identifiers in \emph{italics} as in \term{if} $e_1$
\term{then} $e_2$ \term{else} $e_3$, where the  italicized names are
supposed to be mnemonic, such as $e$ for expressions, $p$ for patterns,
etc.


\input{chapterlex}
\input{chapterexpr}
\input{chapterdeclarations}
\input{chaptermodules}
%\input{chaptertypes}
\input{chapternative}

\appendix


\chapter{Examples}
\section{Using \qq{infinite} lists to compute the list of prime numbers}
\label{example1}
This example will show how lazy evaluation makes it possible to work
with infinite lists and unlimited recursion.

\begin{figure}[hbt]
%fbox{
\begin{code}
// the (infinite) list of prime numbers
primes = let
          iterate f s = s:iterate f (f s)
          odds = iterate (+2) 3   // [3,5,7,...]
          takeWhile p [] = []
          takeWhile p x:xs
            | p x       = x:takeWhile p xs
            | otherwise = []
          grep p []     = []
          grep p x:xs
            | p x       = x:rest
            | otherwise = rest
            where
                rest = grep p xs
          any p []      = false
          any p x:xs
            | p x       = true
            | otherwise = any p xs
          // check if n is prime
          isprime n = let
            // list of numbers that may divide n
            ts = takeWhile (\o -> o*o <= n) primes
          in if any (\t -> n%t==0) ts
            then false   // there is some t that divides n
            else true    // nothing divides n, so n is prime
    in 2:grep isprime odds
\end{code}
%}
\caption{\frege{} code for the list of prime numbers}
\label{primes}
\end{figure}

The last line of the code in \ref{primes} expresses the fact, that 2 is
the first prime number, so 2 is the head of {\tt primes}. The tail of
{\tt primes} is constructed by filtering the prime numbers from the list
of odd numbers.
This is
exactly what the expression
\ex{grep isprime odds}
does\footnote{Note that {\tt grep} as well as {\tt takeWhile},
\texttt{any}
and {\tt iterate} are
standard functions from
package {\tt frege.List}, they're only shown here for completeness}.

The list of odd numbers {\tt odds} is created easy enough by helper
function {\tt iterate}, which takes a function {\tt f} and a start value
{\tt s} and constructs a list with first element {\tt s} and a remaining
list, where the start value of the remaining list is {\tt f} applied to
{\tt s}.
This may sound rather complicated in the first moment, but it will be
instructive to trace in one's own mind, how {\tt odds} is constructed.
For this, it is only necessary to note that the construct {\tt (+2)}
actually is a function, that adds 2 to its argument. Keeping this in
mind, {\tt odds} unfolds like this:

\begin{code}
iterate f s = s:iterate f (f s)
odds = iterate (+2) 3
     = 3:iterate (+2) ((+2) 3)    // by definition of iterate
     = 3:iterate (+2) 5           // simplified (+2) 3
     = 3:5:iterate (+2) ((+2) 5)  // expanding iterate again
     = ...
     = 3:5:7:9:11:iterate (+2) ((+2) 11)
\end{code}

The crucial point here is that this list will not be computed at
once. This would be impossible, because {\tt odds} is
conceptually an infinite list\footnote{The fact that the
implementation of the {\tt Int}
type implies that the list of odd {\tt Int} numbers is actually finite
does not help very much here. Computation of a list of length $2^{31}-1$
would still
take very long and the memory of most contemporary computers could not
hold it.}
and therefore the full computation
would never end and would also require unlimited memory.

Instead, in the definition of {\tt iterate}, the compiler
recognizes that the subexpression {\tt iterate f (f s)}
needs not be computed immediately
because it is an argument to a lazy function,
in this case the list constructor {\tt (:)}.
Therefore it arranges for deferred computation of the recursive
part. This means, only when there is an attempt to
deconstruct\footnote{
Deconstruction essentially means the value
is matched against a pattern. For example, when {\tt grep
isprime odds} is computed, it will first check if {\tt odds} is
an empty list {\tt []}.}
the list {\tt odds} will the expression
{\tt iterate (+2) 3} be evaluated and this will yield
{\tt 3:{\it iterate (+2)5}}, where the italic part resembles a
description of how to
compute the tail of the list. Whenever this list is to be
deconstructed, the run time system carries out the outstanding
computation, yielding {\tt 5:{\it iterate (+2) 7}}.

At the end of the day, only so many elements of the list will have been
computed as absolutely required. The same holds for the list {\tt
primes}.
The definition, however, is universal. Of course, there are things one
should not try to do with infinite lists. For example, reversing them or
computing their length.

It should also be instructing to see how the the predicate {\tt
isprime} works. This is the function that helps {\tt grep} to sort out
the prime numbers from {\tt odds}\footnote{
Careful readers will have
noticed, that the algorithm also works with the list of all numbers
greater than 2, namely {\tt iterate (+1) 3} instead {\tt odds}. Clearly,
since we know the outcome of {\tt isprime n} for even numbers
beforehand, there is no point in actually carrying out those
computations.}.

First, one must understand that only other {\em prime numbers} matter as
potential divisors. For example, one might ask if, in determining
whether
315 is prime, the number 105 needs to be considered as divisor? The
answer is no, because if something is divisible by 105, then it must
also be divisible by the divisors of 105, namely 35 and 3. And if
something is divisible by 35, then it must also be divisible by 5 and 7.
Every number that is not itself a prime number
can ultimately be written as a
product of prime numbers. In the case 315 this would be
$3\times 3\times 5\times 7$.
Therefore, for
our purpose it suffices to know if the number is divisible by any other
\emph{prime} number.

Another question is, do we have to check all prime numbers? Of course this is impossible, since there are infinitely many of them. However, it is clear that potential divisors must be lower than the divident itself, thus we can say with confidence that the process of deciding prime-ness for a given number requires only finite many steps.

But it turns out that we do not even have to check all prime numbers that are lower than the divident.
Take for example the number 35. It can be divided by 5
and 7. But even if we do not see this immediately, nobody would earnestly
waste time by checking if 35 is possibly divisible by 29.
This is because for any divisor greater than the square root
there will be
another divisor (namely the result of dividing our number to check with
that divisor) that is lower than the square root, so we should have
found the latter one already. This means, if we don't find a divisor
that
is lower or equal than the square root, we also will not find one that
is greater than the square root.

The square root of 35 is lower than 6 (since 6*6 is 36) but greater than
5
(since 5*5 is 25). This means, we have to check if 35 is divisible by
any
prime less than 7, since 7*7 is 49.

Note how the definition of {\tt isprime} takes advantage of all those
well established facts about divisibility of integer numbers. Let's
imagine the situation when {\tt isprime 3} is evaluated. This is
the case when the
second element of {\tt primes} must be computed and this, in turn,
is the case when {\tt grep isprime odds} has to check if the first
element of {\tt odds} is
prime.

At this point, {\tt isprime} must return
{\tt true} if the list of prime numbers,
that are lower or equal than the square root of 3 and that do in
fact divide 3
is empty and {\tt false} otherwise.
For better readability, the source code splits this in
three fairly easy
steps. The first and probably most interesting one is to compute the
list of potential divisors, i.e. the list of all primes {\tt o},
where the condition {\tt o*o<=3} holds.
In assuming that the list {\tt primes} is already computed far enough,
we can simply take elements from {\tt primes} while this
condition holds. This is the job of {\tt takeWhile}, to take the head
elements of a list that satisfy a given condition. We are using the list
we are just about to compute, that's quite a bit astonishing!

Consider! The list {\tt primes} at this point, according to our
discussion above, looks like  {\tt 2:{\it grep isprime odds}}
(italics indicate yet to evaluate values as before)
and we are now
computing:

\begin{code}
ts = takeWhile \o{o*o <= n} primes;
\end{code}

where {\tt primes} is actually {\tt 2:{\it grep isprime odds}}.
The pattern match of {\tt primes} against {\tt []} in the first
line of the definition of {\tt takeWhile} fails
because {\tt primes} is obviously not the empty list,
but the second
line matches, since {\tt primes} clearly has the form {\tt x:xs}
as indicated above. Thus, {\tt x} will be bound to 2 and {\tt
xs} to {\tt {\it grep isprime odds}}, i.e. the not yet computed
part of primes. Since {\tt 2*2<=3} is false, {\tt takeWhile}
returns the empty list and does not try to evaluate its list
argument further\footnote{
The algorithm rests on the assumption, that the next prime number
{\tt p'} after
the greatest prime {\tt p} that we already know
is not greater than the square of {\tt p}, i.e.
{\tt p} is already element of {\tt primes} and
{\tt p*p>=p'}
holds so that {\tt takeWhile} does not have to ask for the value of {\tt
p'}. This would be fatal, since we are just about to check if {\tt p'}
is prime which would lead to infinite regress.
Luckily, this is provable true. Moreover, it is known that for any prime
number {\tt p} there exists at least another
prime number {\tt p'} so that
$p<p'<2p$ holds.
}.

In fact, there is no prime number that is not greater than the
square root of 3.
If this is so, then it is false, that any prime number that is not
greater than the square root of 3 divides 3 ({\tt any
$\backslash$t\{n\%t==0\} ts}).
Therefore, evaluation of {\tt isprime 3} yields {\tt true}.
This, in turn, causes {\tt grep isprime (3:{\it xxx})} to evaluate
to
{\tt 3:{\it grep isprime xxx}}.
From this point on, then, {\tt prime} is
{\tt 2:3:{\it grep isprime xxx}}, where {\tt\it xxx} is an abbreviation
for {\tt\it iterate (+2) 5}.

%\chapter{References}

% Most of the literature can be obtained through the internet.

\begin{thebibliography}{99}

\bibitem{f1891} Gottlob Frege \emph{Funktion und Begriff} 
\small{Vortrag, gehalten in der Sitzung vom 9.1.1891 der Jenaischen Gesellschaft für Medizin und Naturwissenschaft}

\bibitem{h98r} Simon Peyton Jones,
John Hughes et al. \emph{Report on the Programming Language
Haskell 98}

\bibitem{h2010} Simon Marlow (editor) \emph{Haskell 2010 Language Report}

\bibitem{ptifart} Simon Peyton Jones \emph{Practical type
inference for arbitrary-rank types}

\bibitem{langspec3} James Gosling, Bill Joy, Guy Steele and
Gilad Bracha. \emph{The Java Language Specification Third
Edition}

\bibitem{implfun} Simon Peyton Jones. \emph{The Implementation of
Functional Programming Languages}

\bibitem{pguards} Martin Erwig, Simon Peyton Jones. \emph{Pattern
Guards and Transformational Patterns}

\bibitem{apidoc} \emph{Java 2 Platform API Specification}

\end{thebibliography}

%\begin{theindex}

\printindex

%\end{theindex}

\end{document}