% $Revision$
% $Header: E:/iwcvs/fc/doc/chapternative.tex,v 1.8 2010/11/06 22:32:25 ingo Exp $
% $Log: chapternative.tex,v $
% Revision 1.8  2010/11/06 22:32:25  ingo
% - described file dlabel things
%
% Revision 1.7  2010/11/02 14:30:07  ingo
% - twocolumn format
%
% Revision 1.6  2009/04/30 13:31:24  iw
% - continued documentation
%
% Revision 1.5  2009/04/22 21:27:24  iw
% - more text
%
% Revision 1.4  2009/03/19 22:02:23  iw
% - continue text
%
% Revision 1.3  2008/05/16 16:03:20  iw
% - continued the native chapter
%
% Revision 1.2  2008/05/14 22:03:11  iw
% - almost finished declaration chapter
%
% Revision 1.1  2007/10/01 16:16:58  iw
% - new chapters
%
%
%
%

\chapter{Native Interface} \label{native interface}

In this chapter, we describe how applications of \hyperref[nativefun]{native functions} are mapped to \java{} code and give a receipt for creating correct native function declarations.

As running example, we develop a package that implements (part of) the functionality of the \java{} classes \texttt{java.lang.Math} and \texttt{java.math.BigInteger}.

\subsection*{Terminology and Definitions}

Let's recall the general forms of \hyperref[nativedat]{native data declarations} and native function declarations:
\begin{quote}
\begin{flushleft}
\textbf{data} $T$ = \textbf{native} $J$\\
\textbf{native} $v$ $j$ :: $t$
\end{flushleft}
\end{quote}

We call $T$ a \emph{native type} and $J$ the \emph{java type} associated with it. If $T$ is associated with one of \texttt{byte}, \texttt{boolean}, \texttt{char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{float} or \texttt{double}, then $T$ is a \emph{primitive type}, otherwise it is a  \emph{reference type}.

We call $v$ a \emph{native value} and $j$ the \emph{java item} associated with it. If $t$ is of the form $t_1 \rightarrow{} \cdots{} \rightarrow{} t_k \rightarrow{}t_R$, where $t_R$ is not itself a function type, we call $v$ a \emph{native function} with \emph{arity} $k$ $(k\ge 1)$ and \emph{return type} $t_R$. The $t_i$ are called \emph{argument types}. For $v$'s that are not native functions, the arity is 0 and the return type is $t$.

$J$ and $j$ are snippets of \java{} code and can be specified as identifiers, qualified identifiers or operator symbols as long as this does not violate the \frege{} lexical syntax. In all other cases the code snippets can be given in the form of string literals. In the following sections, we will frequently use the value of $j$ or just $j$. This is to be understood as the string that is described by the string literal, not the string literal itself.

\paragraph*{Notation of Java Types} Let $t$ be a frege type. Then \ftn{$t$} denotes the type name of the java class that implements $t$ in the code generated by the frege compiler. The actual name is implementation dependent. For any $t$ it is the case that \ftn{$t$} will be a subclass of \texttt{frege.Run.V}, the root of the class hierarchy used to model boxed frege values in \java{}. Such a common supertype is needed for polymorphic functions and data types.

If $t$ is a native frege type associated with $J$, then \jtn{$t$} is $J$, otherwise it is the same as \ftn{$t$}.

\paragraph*{Example}

\autoref{maptypes} lists the \ftn{} and \jtn{} for different types. For each type category there is an example.
\begin{figure}[bht]
\begin{tabular}{llll}
Category & Frege type $t$ & \ftn{$t$} & \jtn{$t$} \\
\hline
primitive & Int  &  \texttt{frege.Prelude.Int} & int \\
reference & String  & \texttt{frege.Prelude.String} & \texttt{java.lang.String} \\
algebraic & data T = ... & $package.$\texttt{T} & $package.$\texttt{T} \\
polymorphic & a & \texttt{frege.Run.V} & \texttt{frege.Run.V} \\
frege array & Array a & \texttt{frege.Prelude.Array} & \texttt{frege.Run.V[]} \\
\end{tabular}
\caption{Mapping of types between \frege{} and \java{}} \label{maptypes}
\end{figure}

\paragraph*{Notation of Java Expressions} Let $e$ be a frege expression. Then we denote with \jex{$e$} the java expression that is generated for $e$ to produce a value with java compile time type \ftn{$t_e$}, where $t_e$ is the type of $e$.

\paragraph*{Boxing and Unboxing}
If $x_f$ is a java expression with compile time type \ftn{$t$} for some frege type $t$, then \unbox{$x_f$} extracts the java value with a compile time type of \jtn{$t$}. The conversion in the other direction is denoted \tobox{$t$}{$x_j$}, where $x_j$ is a java expression with compile time type \jtn{$t$} and the result is a boxed value with compile time type \ftn{$t$}.

If \ftn{$t$} is the same as \jtn{$t$}, both boxing and unboxing have no effect and leave the value unchanged.

It is alwas true that \unbox{\tobox{$t$}{$x_j$}} is equal to $x_j$ and \tobox{$t$}{\unbox{$x_f$}} is equal to $x_f$.

\paragraph*{Costruction of algebraic data types}

Let $jx_i$ be java expressions with compile time types \ftn{$t_i$} for frege type $t_i$. Let $C$ be a constructor of algebraic datatype $T$. Then \cons{$T$}{$C$}{$jx_0 jx_1 \cdots jx_n$} is the java expression with compile time type \ftn{$T$} that constructs a frege value of type $T$ with constructor $C$ from the java expressions.

\example{
\cons{Maybe Int}{Just}{\tobox{Int}{42}} is the code that would be compiled for the frege expression \texttt{Just 42}.
}

\subsection*{Types with Special Meaning}

The following types play a special role in the native interface.

\begin{description}
\item[\texttt{()}] The unit type as argument type indicates an empty argument list for the java method that implements the native function. The unit type is only allowed if there is exactly one argument.

The unit type as return type indicates that the native function is implemented by a java method that is declared \texttt{void}.

\item[\texttt{Maybe} $a$] A \texttt{Maybe} type in argument position indicates that the java method that implements a native function takes \texttt{null} values for the corresponding argument. The generated code will pass \texttt{null} for arguments with value \texttt{Nothing} and \jex{$x$} for arguments (\texttt{Just} $x$).

A \texttt{Maybe} type as return type indicates that the implementing method may return \texttt{null} values. The return value \texttt{null} will be mapped to \cons{\texttt{Maybe} $a$}{Nothing}{} and any other return value $j$ to \cons{\texttt{Maybe} $a$}{Just}{\tobox{$a$}{$j$}}.

The type $a$ must not be any of the special types described here.

\item[\texttt{Exception} $t$] This type is to be used as return type instead of $t$ when the implementing method is declared to throw checked exceptions or if it is known that it throws other exceptions that one needs to catch.

The generated code calls the native method through a wrapper method containing a \texttt{try} statement with a \texttt{catch} clause that catches objects of all classes that are subclasses of \texttt{java.lang.Exception}.
If the method indeed throws an exception $x$, the wrapper returns \cons{\texttt{Exception} $t$} {Left} {\tobox{\texttt{JException}}{$x$}}.
Otherwise, if a value $v$ is returned, the wrapper maps this to
\cons{\texttt{Exception} $t$} {Right} {\tobox{$t$}{$x$}}.

\texttt{Exception} $t$ is not valid for argument types. $t$ may not be another \texttt{Exception} type or an \texttt{IO} type.

\item[\texttt{IO} $t$] This type must be used when the implementing method has any \hyperref[pure]{side effects}. \texttt{IO} must be the outermost type constructor in the result type. The compiler creates an appropriate wrapper function that constructs an IO action, which, when executed, runs the native method and returns its value in the \texttt{IO} monad.

\end{description}

For an overview of possible return values of native functions see \autoref{nativertys}.

%\begin{onecolumn}
\begin{figure*}[bth]
\begin{center}
\begin{tabular}{llp{0.3\textwidth}}
\textbf{\small declared return type} & \textbf{\small expected java signature} & \textbf{\small example java code or comment} \\
& & \\
\texttt{\small ()} & \texttt{\small void meth(...)} & \texttt{\small System.exit()}\footnotemark[1] \\
\texttt{\small Exception ()} & \texttt{\small void meth(...) throws\footnotemark[2] ...} & \texttt{\small System.arraycopy(...)}\footnotemark[1] \\
\texttt{\small IO ()} & \texttt{\small void meth(...)} & \texttt{\small System.gc()} \\
\texttt{\small IO (Exception ())} & \texttt{\small void meth(...) throws\footnotemark[2] ...} & \texttt{\small (Thread)t.start()}\\
\texttt{\small Int} & \texttt{\small int meth(...)} & \texttt{\small (String)s.length()} \\
\texttt{\small String} & \texttt{\small java.lang.String meth(...)} & \texttt{\small (String)s.concat(...)} \\
{\small $a$}\footnotemark[3] & {\small \jtn{$a$}} \texttt{\small meth(...)} & {\small general rule, note that previous 2 lines are no exceptions} \\
\texttt{\small Maybe Int}\footnotemark[4]& \texttt{\small java.lang.Integer meth(...)} & \texttt{\small Integer.getInteger(...)} \\
{\small \texttt{Maybe} $a$}\footnotemark[3] & {\small \jtn{$a$}} \texttt{\small meth(...)} & {\small general rule for any $a$ that is not a primitive type} \\
{\small \texttt{Exception} $a$}\footnotemark[5] & {\small same as for $a$ + \texttt{throws\footnotemark[2] ...}} & \texttt{\small Float.parseFloat(...)} \\
{\small \texttt{IO} $a$}\footnotemark[6] & {\small same as for $a$} & \texttt{\small System.nanoTime()}\\
\end{tabular}
\end{center}
\caption{Well formed native return types} \label{nativertys}

\begin{footnotesize}
\vspace{3mm}
\footnoterule
\footnotemark[1]{However, the compiler can not be fooled into thinking that such a method is actually pure. Therefore, despite the return type is well-formed, it's still invalid. If you need a function that maps any argument to \texttt{()}, consider \texttt{const ()}}

\footnotemark[2]{The \texttt{throws} clause is not required by the \frege{} compiler. But if the java method actually declares checked exceptions, you have to declare an \texttt{Exception} return type.}

\footnotemark[3]{where $a$ is no type with special meaning}

\footnotemark[4]{This works in a similar way for all other primitive types. The code generated by the compiler expects a value of the corresponding boxed type or \texttt{null}. Note that, because \java{} does autoboxing of primitive values, methods that return the corresponding primitve value are also allowed.}

\footnotemark[5]{where $a$ is not another \texttt{Exception} type and not an \texttt{IO} type}

\footnotemark[6]{where $a$ is not another \texttt{IO} type}
\end{footnotesize}
\end{figure*}



%\end{onecolumn}

\subsection{Purity of \java{} methods} \label{pure}

\boxquote{white}{John Hughes}{\emph{The functional programmer sounds rather like a medieval
monk, denying himself the pleasures of life in the hope that it will make him virtuous.}}

A \emph{pure} function has the following properties:
\begin{itemize}
\item Its return value depends only on its arguments and on nothing else.
\item It has no side effects.
\end{itemize}

%We are abstracting here from different settings of the JVM and assume a JVM with unlimited stack space and heap memory so that the exceptions \texttt{java.lang.OutOfMemoryError} and \texttt{java.lang.StackOverflowError} will never be thrown by the JVM.

%Thus, if in the real world, a method invocation throws one of the errors above but there exists a configuration of the JVM where it would not, then we do not regard this as a property of the method.

Dually, a function is not pure if at least one of the following holds:
\begin{enumerate}
\item The method performs any input or output operations.
\item The method changes data that is either visible outside of the method or influences the outcome of subsequent invocations. 
\item It matters, when or how often a method is invoked.
\item It can return different values on different invocations with identical arguments
\end{enumerate}

In \java{}, like in most imperative languages, the use of impure functions is widespread.
Examples for methods that are impure
\begin{enumerate}
\item creation or removal of files, open a file, read from or write to a file
\item any so called \emph{setter}-method, that changes state of an object. Also, random number generators that employ a hidden \emph {seed}.
\item methods that depend on the time of day or the runtime
\item methods that depend on default locale settings like number or date formatting, methods that read the environment, registry settings or configuration files.
\end{enumerate}

Nevertheless, \java{} provides many methods and operations that are pure. Most methods of {\tt java.lang.String} are, as well as the methods of {\tt java.util.BigInteger} and the operations on primitive data types. Most object constructors and getter-methods are also pure.

A pure \java{} method can be declared as such by starting the native declaration with the \term{pure} keyword.


\subsubsection{Deriving a \frege{} \texttt{native} declaration from a \java{} method signature}

For every \java{} method signature

\begin{quote}
\begin{flushleft}
$t$ $name$($t_1$ $a1$, $t_2$ $a2$, $\cdots$, $t_n$ $ai$)
\end{flushleft}
\end{quote}

where $t$ is the return type, $n$ is the fixed number of arguments
\footnote{Argument lists with a variable number of arguments are not supported.}
 and $t_1$, $t_1$, $\cdots$, $t_n$  are the types of the arguments, the \frege{} type must be

\begin{quote}
\begin{flushleft}
() $ \rightarrow{}$ $f_r$  when $n$ is 0\\
$f_1  \rightarrow{} f_2  \rightarrow{}\cdots \rightarrow{}  f_n  \rightarrow{} f_r$  when $n>0$ and for all $i$ \jtn{$f_i$} is $t_i$\\
\end{flushleft}
\end{quote}

\paragraph{Finding the return type}

If $t$ is \term{void}, the return type is \texttt{IO ()} or \texttt{IO (Exception ())} when the method may throw an exception. 

\begin{itemize}
\item write me
\end{itemize}

\subsection*{Field Access Expressions}

Native values with arity 0 can be used to access static fields of a java class. The corresponding frege value is computed once upon beginning of the program.

\trans{
Let $v$ be declared as
\begin{flushleft}
\textbf{native} $v$ $j$ :: $t$\\
\end{flushleft}
\par where $t$ is not a function type. Then the expression $v$ will be compiled to the following java code: \tobox{$t$}{$j$}
}

\example{
Consider the following definition
\begin{flushleft}
\textbf{native} pi java.lang.Math.PI :: Double\\
\end{flushleft}
Then \jex{pi} will be
\begin{flushleft}
frege.Prelude.Double.box(java.lang.Math.PI)\\
\end{flushleft}
}