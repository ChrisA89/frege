% $Revision$
% $Header: E:/iwcvs/fc/doc/chapternative.tex,v 1.8 2010/11/06 22:32:25 ingo Exp $
% $Log: chapternative.tex,v $
% Revision 1.8  2010/11/06 22:32:25  ingo
% - described file dlabel things
%
% Revision 1.7  2010/11/02 14:30:07  ingo
% - twocolumn format
%
% Revision 1.6  2009/04/30 13:31:24  iw
% - continued documentation
%
% Revision 1.5  2009/04/22 21:27:24  iw
% - more text
%
% Revision 1.4  2009/03/19 22:02:23  iw
% - continue text
%
% Revision 1.3  2008/05/16 16:03:20  iw
% - continued the native chapter
%
% Revision 1.2  2008/05/14 22:03:11  iw
% - almost finished declaration chapter
%
% Revision 1.1  2007/10/01 16:16:58  iw
% - new chapters
%
%
%
%

\chapter{Native Interface} \label{native interface}

\todo{This chapter is not yet complete.}

In this chapter, we describe how \hyperref[nativedat]{native data types} and \hyperref[nativefun]{native functions} work, establish some conventions for the work with mutable data types
and give a receipt for creating correct native function declarations.

\section{Purpose of the Native Interface}

The language constructs introduced so far make it possible to write \emph{pure} functional programs. Pure functional programs consist of pure functions that work on immutable data. For the purpose of this discussion, we define these terms as follows: 

\begin{description}
\item[pure function] A function $f$ is pure, if the following holds:
\begin{itemize}
\item $f$ computes the same result when given the same argument values during execution of the program that contains $f$.
\item The result must only depend on the values of the arguments, immutable data and other pure functions. Specifically, it may not depend on mutable state, on time or the current state of the input/output system.
\item Evaluation of $f$ must not cause any side effect that could be observed in the program that evaluates $f$. It must not  change the state of the real world (such as magnetic properties of particles on the surface of a rotating disc).
\end{itemize}
This definition is not as rigid as others that can be found in the literature or in the Internet. For example, we may regard a function \exq{\term{getenv} \sym{::} \term{String} $\rightarrow$ \term{String}} as pure, even if it depends on some hidden data structure that maps string values to other string values (the environment), provided that it is guaranteed that this mapping remains constant during program execution. 

Regarding side effects, we exclude only effects in the real world (input/output, but not physical effects in the CPU or memory chips) and effects that are observable \emph{by the program that caused it}. For example, evaluation of the expression
\exq{ s1 ++ s2 }
where \term{s1} and \term{s2} are string values, will cause creation of a new \java{} \term{String} object and mutation of some memory where the new string's data is stored, this could even trigger a garbage collector run with mutation of huge portions of the program's memory. Yet, all this happens behind the scene and is observable only by \emph{another} program such as a debugger or run time monitor, if at all.

We also do not insist that application of a pure function with the same argument values must return the same value in different executions of the program\footnote{If we did insist on equal return values for application of a pure function with equal arguments \emph{in different executions of a program}, we could not use any functionality provided by the underlying platform, which is in our case \java{} and the \java{} Virtual Machine. For we could not guarantee that certain constants or pure methods we use will be unchanged in the next update or version of that component. 

Alternatively, one could of course define the term \emph{program} in such a way that it encloses a specific version of the \java{} runtime system (and in turn specific versions of the libraries used by \java{}, and the libraries used by those libraries down to the operating system and even the hardware). But then, the term \emph{program} would become almost meaningless.
Suppose, for example, that some chip producer finds a bug in one of the floating point units that he produces, which causes incorrect results to be returned by certain floating point divisions. Suppose further, that the faulty CPU chip is replaced by a fixed one in the computer used by an extremely rigid functional purist, who insists that functions must produce the same value across different program executions. Then, this person must either admit that some function he wrote was not pure (because it suddenly produces different results for the same argument values) or he must regard his program as having changed. He could, for instance, talk about how much more exact results "\emph{this new version of my program}"  produces, despite nobody hasn't changed a single bit on the hard disk!

This argumentation is not invalidated by pointing out that the faulty CPU did not behave according to their specification. It remains the fact that results of computer functions depend on the computing environment they are executed in, no matter if one likes it or not.

It is probably more rational to acknowledge that the idea of a function that \emph{depends on nothing but its arguments} is a nice, but utterly idealistic one that must necessarily abstract away many aspects of reality. In practice, the result of a function $\backslash x \rightarrow x/3145727.0$, when defined in some computer language and executed in some computing environment depends not only on $x$, but also on how the floating point unit works, how exact the divisor can be represented in floating point, in short, it depends on the computing environment where it is run. 

We do not understand the concept of functional purity so narrowly that we require the same result of a pure function in all thinkable computing environments. Rather, we admit realistically that results may be different in different computing environments. The session environment (the mapping of values printed by the command \term{env} in a \textsc{Unix} session; similar features exist in other operating systems) is a part of the computing environment that is constant during program execution (in \java{} programs, that is). Hence, the result of a pure function in a program may depend on environment variables, according to our definition. It may depend on the arguments passed on the command line. Yet, it may not depend on the current directory, for obtaining the name of it or using it presupposes input/output to be performed. It may also not depend on \java{}s system properties, for those can be changed during program execution.}.

\item[immutable values] A value is immutable if there are no means to \emph{observably} change it or any values it contains or references.

This is deliberately vague in view of the difficulties in \java{} when it comes to enforcing immutability. \footnote{It is, for example.possible to break intended immutability with the help of  the reflection API.}
\end{description}

The native interface allows to call \java{} methods and use \java{} data in \frege{} programs.
Because \java{} reference values  may be mutable and \java{} methods may not be pure functions, it provides means to differentiate between pure vs. impure methods and mutable vs. immutable values. Unfortunately, there exists no reliable general way to establish purity of \java{} methods or immutability of \java{} values. Therefore, the \frege{} compiler must rely on the truthfulness of the annotations the programmer supplies.

\hasdiff{The native interface in \frege{} 
corresponds to the \emph{Foreign Function Interface} in Haskell 2010 (\cite[Chapter 8]{h2010}), but differs in the following points:
\begin{itemize}
\item There are no foreign exports, because all items defined in a \frege{} module that are visible
in other \frege{} modules are also visible to any \java{} program.
\item Foreign imports (i.e. native declarations) always refer to items known in the \java{} virtual machine. 
The source language that was used to create those classes, interfaces or methods is immaterial.
\item For the same reason, there are no different calling conventions.
\item Some simple marshalling between \frege{} data and JVM data is supported.
\end{itemize}}


\section{Terminology and Definitions}

Let's recall the general forms of native data and function declarations:
\begin{quote}
\begin{flushleft}
\textbf{data} $T$ $t_1$ $\cdots$ $t_i$ = \textbf{native} $J$\\
\textbf{native} $v$ $j$ :: $t$
\end{flushleft}
\end{quote}

We call $T$ a \emph{native type} and $J$ the \emph{java type} associated with it. 
We also say that the \frege{} type ($T$ $t_1$ $\cdots$ $t_i$) denotes the \java{} type $J$.
In this chapter, we'll use the abbreviations \jt{$T$} for \emph{the \java{} type associated with or denoted by T}
and \ft{$J$}for \emph{the \frege{} type that denotes J}.

If $T$ is associated with one of 
\texttt{byte}, \texttt{boolean}, \texttt{char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{float} or \texttt{double}, 
then $T$ denotes a \emph{primitive type}, otherwise it denotes a \emph{reference type}.

We call $v$ a \emph{native value} and $j$ the \emph{java item} associated with it. If $t$ is of the form $t_1 \rightarrow{} \cdots{} \rightarrow{} t_k \rightarrow{}t_R$, where $t_R$ is not itself a function type, we call $v$ a \emph{native function} with \emph{arity} $k$ $(k\ge 1)$ and \emph{return type} $t_R$. The $t_i$ are called \emph{argument types}. For $v$'s that are not native functions, the arity is 0 and the return type is $t$.

$J$ and $j$ are snippets of \java{} code and can be specified as identifiers, qualified identifiers or operator symbols as long as this does not violate the \frege{} lexical syntax. In all other cases the code snippets can be given in the form of string literals. In the following sections, we will frequently use the value of $j$ or just $j$. This is to be understood as the string that is described by the string literal, not the string literal itself.

\section{Mapping between \frege{} and \java{} Types}

Since all \frege{} types must be mapped to \java{} types eventually, 
it is the case that every \frege{} type of kind \sym{*} denotes exactly one \java{} type. 
The converse, however, is not true, since multiple \frege{} 
types may map to one and the same \java{} type\footnote{Implementations are free to erase type arguments, 
so that, for example \term{Maybe String} and \term{Maybe Int} may denote the same \java{} type. 
In fact, since \java{}'s type system is not powerful enough to deal with higher kinded types, 
it is very likely that type arguments will be erased.}
and in addition, \ft{$J$} is only defined for
those \java{} types that are made available to \frege{} with a native data definition.

The \autoref{typemapping} shows a recommended mapping.

\begin{figure}[hbt]
\begin{tabular}{|c|c|p{5cm}|}
\hline \rule[-1ex]{0pt}{1.5ex} Type $T$ & \jt{$T$} & Comment \\ 
\hline \rule[-1ex]{0pt}{1.5ex} $a$ & \texttt{java.lang.Object} & \small nothing is known about values of type $a$\\
\hline \rule[-1ex]{0pt}{1.5ex} $a$ $\rightarrow$ $b$ & \texttt{frege.runtime.Lambda} & \\
\hline \rule[-1ex]{0pt}{1.5ex} \texttt{Bool} & \texttt{boolean} & \\
\hline \rule[-1ex]{0pt}{1.5ex} \texttt{Int} & \texttt{int} & \small and similarly for all other primitive types\\
\hline \rule[-1ex]{0pt}{1.5ex} \texttt{String} & \texttt{java.lang.String} & \\
\hline \rule[-1ex]{0pt}{1.5ex} \texttt{Integer} & \texttt{java.math.BigInteger} & \\
\hline \rule[-1ex]{0pt}{1.5ex} \bracka{}$a$\brackz{} & \texttt{frege.prelude.PreludeBase.TList} & \\
\hline \rule[-1ex]{0pt}{1.5ex} ($a$, $b$) & \texttt{frege.prelude.PreludeBase.TTuple2} & and similarly for tuples with more components\\
\hline \rule[-1ex]{0pt}{1.5ex} enumerations & \texttt{short} & \\
\hline \rule[-1ex]{0pt}{1.5ex} algebraic & $M$.T$T$ & where $T$ is defined in module $M$\\
\hline 
\end{tabular} 
\caption{Recommended type mapping} \label{typemapping}
\end{figure}


\section{Types with Special Meaning}

The following types have a special meaning in the type signatures of native values and functions. 
They are used to require special handling of argument or return values (marshalling).

As far as \frege{} is concerned, the corresponding values have exactly the declared types.
The \java{} type, however, can be different.

\begin{description}
\item[\texttt{()}] The unit type as argument type indicates an empty argument list for the \java{} method that implements the native function. The unit type is only allowed in argument position if the type is of the form $() \rightarrow t_R$. i.e. when the unit value is the only argument.

The unit type as return type indicates that the native function is implemented by a \java{} method that is declared \texttt{void}. The compiler supplies a wrapper that invokes the method and returns the value ().

\item[\texttt{Maybe} $a$] A \texttt{Maybe} type in argument position indicates that the \java{} method that implements a native function takes \texttt{null} values for the corresponding argument. The generated code will pass \texttt{null} for arguments with value \texttt{Nothing} and the unboxed $x$ for arguments of the form (\texttt{Just} $x$).

A \texttt{Maybe} type as return type indicates that the implementing method may return \texttt{null} values. The return value \texttt{null} will be mapped to \texttt{Nothing} and any other return value $j$ to (\texttt{Just} $j$).

It therefore holds that \jt{\texttt{Maybe} $a$} in native method's arguments or return values is \jt{$a$}.

\java{} provides classes for boxed primitive values, like for instance \texttt{java.lang.Float}. 
If one needs to use a method that has an argument of a boxed type, 
one can use any \frege{} type that is associated with the corresponding  primitive type (i.e. \texttt{Float}). 
This works because \java{} performs \emph{autoboxing}. 
However, if one ever needs to pass \texttt{null}, the corresponding argument type must be wrapped in \texttt{Maybe} (i.e. \texttt{Maybe Int}). 
For return types, the autoboxing works in a similar way. 
Yet, whenever it is not provably impossible that the method ever returns \texttt{null}, 
one must declare the return type as a \texttt{Maybe} type. 
Failure to do so may cause null pointer exceptions to occur at runtime.

The type wrapped by \texttt{Maybe} must not be any of the special types described here.

\item[\texttt{\bracka{}$t$\brackz{}}]
\inmargin{not yet impl. for primitive arrays}
A list type as return type signals that the \java{} method will return an array with elements of type $t$, or a value of type \texttt{java.lang.Iterable} that yields elements of type $t$. The return value will then be converted to a \frege{} list with $t$ elements. If the method returns \texttt{null}, an empty list will be returned. Any \texttt{null} values found in the array or returned by the iterator are skipped. Note that, when the result is an empty list, the \java{} method could have returned \texttt{null} or an array that contained only \texttt{null}s or an iterator that returned only \textit{null}s.

It is important to note that this feature introduces the possibility of run time type errors
\inmargin{checking against array types may be possible in the future} 
and must therefore be used with uttermost care.
This is because the list element type does not appear anywhere in the generated java type.
To be safe, the element type $e$ of the array or iterator the method actually returns must be such that \jt{$t$} = $e$ holds.


The list element type $t$ must not be any of the special types described here.

\item[\texttt{Either} $x$ $t$] This type is to be used as return type instead of $t$ when the implementing method is declared to throw checked exceptions or if it is known that it throws other exceptions that one needs to catch.

The $x$ must be an \emph{exception descriptor} whose definition follows along with two other concepts we will be using:
\begin{itemize}
\item If \jt{$x$} is some \java{} type that implements \texttt{java.lang.Throwable}, then and only then is $x$ a \emph{throwable type}. \label{throwable}
\item If $x$ is a throwable type, it is a valid \emph{exception descriptor}. \label{descriptor}
\item Let $y$ be an exception descriptor and $t$ a throwable type. 
Then \texttt{Either} $y$ $t$  is a valid exception descriptor.
\item All other types are not exception descriptors.
\item A type of the form \texttt{Either $x$ $t$} 
where $x$ is an exception descriptor and $t$ is not an exception descriptor is called a \emph{catching type}.
\label{catching}
\end{itemize}

The \hyperref[nested-either]{nested \texttt{Either}} syntax comes in quite handy here:

\example{\tt \small
\begin{flushleft}
data BadCharset = pure native \\
\hspace{2cm}java.nio.charset.IllegalCharsetNameException\\

data UnsopportedCharset = pure native \\
\hspace{2cm}java.nio.charset.UnsupportedCharsetException\\

data CharSet = pure native java.nio.charset.Charset where\\
\hspace{1cm}pure native csForName java.nio.charset.Charset.forName \\
\hspace{2cm}:: String -> (BadCharset|UnsupportedCharset|CharSet)
\end{flushleft}
}

Code generation  will create a wrapper method containing a \texttt{try} statement with \texttt{catch} clauses
that catch the exceptions declared in $x$ in left to right order\footnote{
The order is the same, regardless of notation of the type as \texttt{(Either (Either E1 E2) R)} or \texttt{(E1|E2|R)}.
It could appear to be different only if one used type aliases like \texttt{type Rehtie a b = Either b a}, 
however, it is the order in the expanded form that counts.}
If the wrapper indeed catches one of the interesting exceptions, it constructs an appropriate \texttt{Left} value.
Otherwise, if a value $v$ is returned from the native method, the wrapper returns (\texttt{Right} $v_m$), 
where $v_m$ is the value after marshalling of $v$, 
which takes place in cases where $t$ is one of the types with special meaning as explained before.

A \hyperref[catching]{catching type} is not valid as argument type for a native function. 

$t$ may not be another catching type nor a \texttt{ST} or \texttt{IO} type.

\item[\texttt{ST} $s$ $t$] This type must be used when the implementing method uses mutable data. \texttt{ST} must be the outermost type constructor in the result type. The compiler creates an appropriate wrapper function that constructs a \texttt{ST}  action, which, when executed, runs the native method and returns its value in the \texttt{ST} monad. Native functions declared this way can also be used in the \texttt{IO} monad.

\item[\texttt{IO} $t$] This type must be used when the implementing method has any \hyperref[pure]{side effects}. \texttt{IO} must be the outermost type constructor in the result type. The compiler creates an appropriate wrapper function that constructs an \texttt{IO}  action, which, when executed, runs the native method and returns its value in the \texttt{IO} monad.

\end{description}

For an overview of possible return values of native functions see \autoref{nativertys}.

%\begin{onecolumn}
\begin{figure*}[bth]
\begin{center}
\begin{tabular}{llp{0.3\textwidth}}
\textbf{\small declared return type} & \textbf{\small expected java signature} & \textbf{\small example java code or comment} \\
& & \\
\texttt{\small ()} & \texttt{\small void meth(...)} & \texttt{\small System.exit()}\footnotemark[1] \\
\texttt{\small (Ex|())} & \texttt{\small void meth(...) throws \jt{Ex}\footnotemark[2]} & \texttt{\small System.arraycopy(...)}\footnotemark[1] \\
\texttt{\small IO ()} & \texttt{\small void meth(...)} & \texttt{\small System.gc()} \\
\texttt{\small IO (Ex|())} & \texttt{\small void meth(...) throws\footnotemark[2] ...} & \texttt{\small (Thread)t.start()}\\
\texttt{\small Int} & \texttt{\small int meth(...)} & \texttt{\small (String)s.length()} \\
\texttt{\small String} & \texttt{\small java.lang.String meth(...)} & \texttt{\small (String)s.concat(...)} \\
{\small $a$}\footnotemark[3] & {\small \jt{$a$}} \texttt{\small meth(...)} & {\small general rule, note that previous 2 lines are no exceptions} \\
\texttt{\small Maybe Int}\footnotemark[4]& \texttt{\small java.lang.Integer meth(...)} & \texttt{\small Integer.getInteger(...)} \\
{\small \texttt{Maybe} $a$}\footnotemark[3] & {\small \jt{$a$}} \texttt{\small meth(...)} & {\small general rule for any $a$ that is not a primitive type} \\
{\small (\texttt{Ex|}$a$)}\footnotemark[5] & {\small same as for $a$ + \texttt{throws\footnotemark[2] ...}} & \texttt{\small Float.parseFloat(...)}\footnotemark[7] \\
{\small \texttt{IO} $a$}\footnotemark[6] & {\small same as for $a$} & \texttt{\small System.nanoTime()}\footnotemark[8]\\
\end{tabular}
\end{center}
\caption{Well formed native return types} \label{nativertys}

\begin{footnotesize}
\vspace{3mm}
\footnoterule
\footnotemark[1]{However, the compiler can not be fooled into thinking that such a method is actually pure. Therefore, despite the return type is well-formed, it's still invalid. If you need a function that maps any argument to \texttt{()}, consider \texttt{const ()}}

\footnotemark[2]{If the \java{} method actually declares checked exceptions, the return type must be a catching type or the \texttt{throws} clause on the native declaration must be used.}

\footnotemark[3]{where $a$ is no type with special meaning}

\footnotemark[4]{This works in a similar way for all other primitive types. The code generated by the compiler expects a value of the corresponding boxed type or \texttt{null}. Note that, because \java{} does autoboxing of primitive values, methods that return the corresponding primitive value are also allowed.}

\footnotemark[5]{where $a$ is not another catching type and not an \texttt{IO} type}

\footnotemark[6]{where $a$ is not another \texttt{IO} type}

\footnotemark[7]{in this case, $a$ would be \texttt{Float}}

\footnotemark[8]{in this case, $a$ would be \texttt{Long}}
\end{footnotesize}
\end{figure*}


\section{Catching or Re-Throwing Exceptions}

There are two mechanisms that deal with exceptions thrown from native functions. 
The first mechanism uses \hyperref[catching]{catching types} 
as described in the previous section. 

The idea behind the catching types is to encode the actual return value and the catched exceptions in a value of type \texttt{Either}.
This makes it in effect impossible to overlook that the function may throw exceptions. 
The user has many choices to get at the actual return value: case expressions, the \texttt{either} function, or higher order functions like \texttt{fmap}. But he cannot pretend that the function just returns a value without taking the possibly of thrown exceptions into account.

This approach is fine in many cases, but may be a bit laborious in others. 
For example, when doing input/output using \java{} APIs, almost every function will potentially throw some incarnation of \texttt{java.io.IOException}. 
It is neither desirable nor even possible to ignore such exceptions, and this could lead to a programming style where every function call is followed by long winded error handling. In the end, even small sequences of I/O actions could result in deeply nested case expressions. Or the code could get extremely fragmented along the lines of:

\example{\tt
\begin{flushleft}
processFile path = do\\
\hspace{0.5cm}openFile path >>= either handleOpenException continueRead\\

continueRead f = do\\
\hspace{0.5cm}readLine f >>= either handleNoLine (processLine f)\\

processLine f ln = do\\
\hspace{0.5cm}result1 <- do something with the line\\
\hspace{0.5cm}readLine f >>= either handleNoOtherLine (processRest f result1)\\

processRest f res1 ln2 = do ....\\

handleOpenException ex = do ...\\

handleNoLine ex = do ....\\

handleNoOtherLine ex = do ....\\
\end{flushleft}
}

Should a function throw different exceptions that require separate handling, it will get even more complex.

Therefore, there is another approach, that allows to catch and handle exceptions explicitly 
in the \texttt{ST} or \texttt{IO} monads\footnote{The details of how to use the key functions \texttt{catch} and \texttt{finally} and how to write exception handlers can be found in the API documentation.}.

The explicit approach rests on the idea that the return types of native functions are left as they are, 
except for the \texttt{ST} or \texttt{IO} wrapper.
This requires, however, that checked exceptions, 
which are part of \java{} method signatures must be eliminated,
since \frege{} function types carry no information about them.

Put differently, a \java{} method that invokes a method whose signature states that checked exceptions may be thrown must do so either inside of a throw/catch statement where the checked exception is catched, or the calling method must itself state that it throws the exception.

Neither are there statements in \frege{}, let alone try/catch statements, 
nor are exceptions part of the contract of \frege{} functions. 
Hence, the only possibility is to catch the exceptions where they arise, 
wrap them in unchecked exceptions and re-throw the latter ones, 
which can be done without changing the method's signature.

To achieve this, the following form of a native function declaration must be used:

\begin{flushleft}
\textbf{native} $v$ $j$:: $t$ \textbf{throws} $x_1$, $\cdots$, $x_k$
\end{flushleft}

Here, $t$ is the function type whose return type must be a \texttt{ST} or \texttt{IO} type, and the $x_i$ ($i \ge 1$) are \hyperref[throwable]{throwable types} that denote \java{} exceptions to re-throw. The generated wrapper will create a try/catch statement that catches, wraps and re-throws all exceptions denoted by the $x_i$.

\subsection*{Rules for native functions that throw exceptions}

\begin{itemize}
\item The set of checked exceptions declared in the signature of the \java{} method must be a subset of the throwable types in the native declaration, otherwise the generated \java{} code will not compile. Put differently, 
all possible checked exceptions must be considered in one way or the other by the \frege{} declaration.
\item Catching types and the \texttt{throws} clause can be combined. The exceptions occuring in the catching type will never be thrown, but wrapped in the \texttt{Either} value.
\item Catching types as well as throws clauses can contain additional exceptions, also unchecked ones.
\item Native functions with \texttt{throws} clauses allow one to deliberatly ignore exceptions, even checked ones.
Needless to say, except for toy programs, this is not acceptable, as 
any unhandled re-thrown exception will terminate the thread where it was raised.
\end{itemize}

\section{Mutable and immutable \java{} data}

Most \java{} objects are potentially mutable. 
However, from the \frege{} point of view the question is whether objects of a certain class can be mutated with the operations that are available. If one restricts oneself to non-mutating native functions, 
a \java{} class can be considered immutable for the purpose at hand. 

An example for such a border case is \texttt{java.math.BigInteger}, which is technically not immutable at all, yet offers a quite functional interface. With the understanding that malicious \java{} code could manipulate big integer values, 
this class is regarded immutable in \frege{}, and serves as implementation for type \texttt{Integer}. Of course, all the
operations of \texttt{Integer} do not manipulate the underlying \java{} object in any observable way.

\section{Pure \java{} methods} \label{pure}

A \emph{pure} \java{} method is a pure function, i.e. it has the following properties:
\begin{itemize}
\item Its return value depends only on its arguments, on constant data and on nothing else.
\item It has no side effects.
\end{itemize}

Dually, a function is not pure if at least one of the following holds:
\begin{enumerate}
\item The method performs any input or output operations.
\item The method changes data that is either visible outside of the method or influences the outcome of subsequent invocations of any other method.
\item It matters, when or how often a method is invoked.
\item It can return different values on different invocations with identical arguments. 
This can be the case when the result of the function depends on mutable state.
\end{enumerate}

In \java{}, like in most imperative languages, the use of impure functions is widespread.
Examples for methods that are impure
\begin{enumerate}
\item creation or removal of files, open a file, read from or write to a file
\item any so called \emph{setter}-method, that changes state of an object. Also, random number generators that employ a hidden \emph {seed}.
\item methods that depend on the time of day
\item methods that depend on default locale settings like number or date formatting that could be changed during the runtime of a prgram, methods that read so called system properties, registry settings or configuration files.
\end{enumerate}

Nevertheless, \java{} provides many methods and operations that are pure. Most methods of {\tt java.lang.String} are, as well as the methods of \texttt{java.util.BigInteger} and the operations on primitive data types. Many object constructors and getter methods are also pure when they create or 
operate on immutable values.

A pure \java{} method can be declared as such by starting the native declaration with the \term{pure} keyword.


\section{Deriving a \frege{} \texttt{native} declaration from a \java{} method signature}

For every \java{} method signature

\begin{quote}
\begin{flushleft}
$t$ $name$($t_1$ $a1$, $t_2$ $a2$, $\cdots$, $t_n$ $ai$)
\end{flushleft}
\end{quote}

where $t$ is the return type, $n$ is the fixed number of arguments
\footnote{Argument lists with a variable number of arguments are not supported.}
 and $t_1$, $t_1$, $\cdots$, $t_n$  are the types of the arguments, the \frege{} type must be

\begin{quote}
\begin{flushleft}
() $ \rightarrow{}$ $f_r$  when $n$ is 0\\
$f_1  \rightarrow{} f_2  \rightarrow{}\cdots \rightarrow{}  f_n  \rightarrow{} f_r$  when $n>0$ and for all $i$ \jt{$f_i$} is $t_i$\\
\end{flushleft}
\end{quote}

\paragraph{Finding the return type}

If $t$ is \term{void}, the return type is \texttt{IO ()} or \texttt{IO (Exception ())} when the method may throw an exception. 

\begin{itemize}
\item write me
\end{itemize}

\subsection*{Field Access Expressions}

Native values with arity 0 can be used to access static fields of a \java{} class. 
The corresponding \frege{} value is computed once upon beginning of the program.

\trans{
Let $v$ be declared as
\begin{flushleft}
\textbf{native} $v$ $j$ :: $t$\\
\end{flushleft}
\par where $t$ is not a function type. Then the expression $v$ will be compiled to the following java code: $j$
}

\example{
Consider the following definition
\begin{flushleft}
\textbf{native} pi java.lang.Math.PI :: Double\\
\end{flushleft}
Then \jex{pi} will be
\begin{flushleft}
java.lang.Math.PI\\
\end{flushleft}
}