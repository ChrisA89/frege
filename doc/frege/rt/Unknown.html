<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (version 1.7.0) on Wed Oct 19 19:24:25 CEST 2011 -->
<title>Unknown</title>
<meta name="date" content="2011-10-19">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Unknown";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../frege/rt/SwingSupport.html" title="class in frege.rt"><span class="strong">Prev Class</span></a></li>
<li><a href="../../frege/rt/Value.html" title="interface in frege.rt"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?frege/rt/Unknown.html" target="_top">Frames</a></li>
<li><a href="Unknown.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">frege.rt</div>
<h2 title="Class Unknown" class="title">Class Unknown&lt;V&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>frege.rt.Unknown&lt;V&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;V&gt;, java.util.concurrent.Callable&lt;V&gt;</dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="strong">Unknown&lt;V&gt;</span>
extends java.lang.Object
implements <a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;V&gt;, java.util.concurrent.Callable&lt;V&gt;</pre>
<div class="block"><p> Base class for lazy values.</p>

 <p> Lazy values differ from proper values insofar as they need to know
 how to exactly evaluate themselves.
 This is the job of the _e() and _v() functions. </p>

 <p> The functionality of <a href="../../frege/rt/Unknown.html#_e()"><code>_e()</code></a> is fixed through <tt>final</tt>
 and cannot be changed.
 It calls <a href="../../frege/rt/Unknown.html#_v()"><code>_v()</code></a> in a loop until the value is fully evaluated and then
 caches it in a private instance variable. Hence, instances of
 Unknown are not immutable and this in turn requires synchronization.</p>

 <p> The caching of the evaluated value would not be strictly necessary, as
 repeated evaluation must always yield the same result. Experience shows,
 however, that re-evaluations are quite common, hence not caching the result
 would most likely cause even the simplest program to perform unacceptably bad.
 </p>

 <p> The real work, then, is done by _v(). _v() may return a proper value or
 another lazy value, though it is required that the latter is somehow closer
 to the final result, so that evaluation of that value gets even closer
 and repeated evaluation of the indermediate lazy values
 eventually reaches the result. </p>

 <h3> Introduction of lazyness in frege compiled code </h3>

 <p> Lazy values are introduced at 3 occasions: </p>

 <ol>
 <li>
 <p>  Code for self referential values. Take the following example: </p>
 <pre>
 // the list of fibonacci numbers
 fibs = 0:1:zipWith (+) fibs (tail fibs)
 </pre>

 <p> One cannot just compile this thus: </p>

 <pre>
  static final TList<Bint> fibs = DCons.<Bint>inst.run(box(0),
      DCons.<Bint>inst().run(box(1),
          Prelude.<Bint, Bint>zipWith().run(Prelude.INum_Int._plus(),
                                        fibs, Prelude.<Bint>tail().run(fibs))));
 </pre>
 <p>
 The problem is that the java variable <tt>fibs</tt> is not yet assigned
 at the time it is passed to <tt>zipWith</tt>.
 <br>The solution is: </p>
 <pre>
 static final Lazy<TList<Bint>> fibs = new Unknown<TList<Bint>>() {
      final Lazy<TList<PI>> _v() {
          return DCons.<Bint>inst().run(box(0),
                  DCons.<Bint>inst().run(box(1),
                      Prelude.<Bint, Bint>zipWith().run(Prelude.INum_Int._plus(),
                                        fibs, Prelude.<Bint>tail().run(fibs))));
      }
 }
 </pre>
 <p>In this way, evaluation of <tt>fibs</tt> is avoided unless it is really needed and
 the reference is assigned a non-null value.
 </li>
 <li> Code for non-strict arguments

 <p> Here is a short explanation to clarify what a non-strict argument is.
 </p>

 <p> Many functions have the property that they do not always need all their
 arguments to compute their return value. A classic example that should be
 familiar to Java programmers is the function performed by the &amp;&amp;
 operator: if the left operand is <tt>false</tt>, there is no need to evaluate
 the right operand because the result is <tt>false</tt>
 no matter what the boolean value
 of the right operand is. </p>

 <p> It is important to note that the guarantee to evaluate certain
 operators such as <tt>&amp;&amp;</tt>, <tt>||</tt> or the ternary <tt>?:</tt>
 operator lazily
 takes them semantically apart from all other operators and
 methods in the otherwise strict evaluation model of java.<br>
 It is, for instance, not possible to wrap these short-circuit operators
 in a java method. Consider the expression: </p>
 <pre>
      a == null ? "null" : a.foo()
 </pre>
 <p> Here, the method foo() can only be called when a is not null, but whether
 it is called or not is decided in the <tt>?:</tt> function itself, not, as usual,
 before the evaluation of the function starts. Therefore, the following
 method has a completely different semantic than the operator: </p>
 <pre>
 static&lt;T&gt; T eitherOr(boolean cond, T t, T f) {
      if (cond) return t;
      return f;
 }
 </pre>
 <p> If one would replace all occurences of the <tt>?:</tt> operator in a java program
 with calls to the eitherOr method, the resulting program would behave
 differently in those cases where the evaluation of the second
 or the third argument to eitherOr would not deliver a result. <br>
 For example, in </p>
 <pre>
      eitherOr(a == null, "null", a.foo())
 </pre>
 <p> a NullPointerException would be thrown in the case where a was indeed null,
 where in the original program the result was the string "null". </p>

 <p>
 In the context of the frege language, we say that evaluation of an expression
 <em>diverges</em> if
 it fails to deliver a value of the expected type. This subsumes, for example,
 endless recursion or looping, run time exceptions like division by zero and so on.
 Divergence of an evaluation is semantically equivalent to non-termination:
 the instance that caused the diverged evaluation will never receive an answer.
 </p>

 <p> Because we cannot foresee if a particular expression actually will diverge
 or not when evaluated, we assume that (evaluation of) any expression
 can diverge. To formalize this, we imagine every type is <em>lifted</em>
 so that it contains an extra undefined value (sometimes called <em>bottom</em>).
 Thus, an expression of type <tt>Int</tt> can, at runtime, evaluate to an integer
 number or to the undefined value, one of type <tt>Bool</tt> to <tt>true</tt>,
 <tt>false</tt> or undefined,
 and so on. (In the frege runtime, when evaluation detects the undefined
 value, some excpetion will be thrown.)
 </p>

 <p> Lazy evaluation means that expressions are evaluated at the latest possible
 moment. This is what java does with its short-circuit operators.
 For instance, whether the  second or third operand of the <tt>?:</tt> will be evaluated
 depends on the boolean value of the first operand.<br>
 A lazy language is simply one where all functions and operators
 are "short-circuit" and any
 expression will be evaluated only when absolutely necessary, for instance
 when it must be printed on the users screen. </p>

 <p> Of course, lazy evaluation does not come for free. Instead of values one
 must pass around representations of expressions
 that evaluate to values unless they diverge. Let us call such
 descriptions of how to compute a value <em>lazy values</em>.
 </p>
 <p> Construction of lazy values costs processing time and memory.
 The time needed in construction
 of the lazy value is not lost, however. If the value is actually not
 evaluated, the time that would have been spent evaluating it needlessly is,
 so to speak, payed back.
 </p>

 <p> There are expression, though, where we know that they will be
 evaluated. For example, in the frege version of the eitherOr from above: </p>
  <pre>
  eitherOr true  x y = x
  eitherOr false x y = y
  </pre>
 <p> we know for instance that if <tt>eitherOr a b c</tt> is evaluated,
 then <tt>a</tt> absolutely must be evaluated
 also. This opens opportunities for optimizations that remove unneeded
 lazyness <em>without</em> changing the behaviour of the program.</p>

 <p> We say that a function is <em>strict</em> in (one of) its arguments
 if it is unavoidable that the function evaluates it. This assumes that
 the function itself is called only when their value is needed.
 </p> <p>
 Now, if evaluation of an expression diverges (never returns) and if that
 expression is passed as argument to a function that is strict in that
 argument, evaluation of that function will also diverge. </p>
 <p>
 Hence, it does not make a difference from a semantic point of view, whether we
 pass a strict argument in evaluated or lazy form: If the evaluation of the argument
 diverges, the evaluation of the function call will also diverge. If the argument
 evaluates to a proper value, the function call may or may not diverge,
 but if it does,
 it will not be the fault of the argument. </p>

 <p> Conversely, it will make a big difference whether we evaluate
 a non strict argument before we actually call the function. This is
 precisely the semantic difference between the java method eitherOr and
 the java ternary operator <tt>?:</tt>  </p>

 <p> It should be clear by now, that the first argument of the <tt>?:</tt> java operator
 is strict, while the others are non-strict.
 </p>

 <p> The frege compiler does a so called <em>strictness analysis</em>
 that helps it find most function arguments (and, in general)
 pattern bound variables that are strict. </p>
 <p>
 In our running example the compiler would correctly infer that the
 first argument to
 <tt>eitherOr</tt> is strict, and the other two are non strict. When
 code for a call to <tt>eitherOr</tt> must be generated, it will make sure
 that expressions in the place of the second or third argument are
 passed lazily, while the expression given for the first argument will
 have been evaluated already to avoid the costs of creating a lazy value.
 </p>
 </li>
 <li>
 <p> Non-recursive tail calls. </p>
 <p> If the return value of a function is expressed as a function call,
 we call this a <em>tail call</em>. If a function tail-calls itself, this is
 <em>tail recursion</em>. Here are examples: </p>
 <pre>
 even 0 = true
 even n = odd  (n-1)
 odd  0 = false
 odd  n = even (n-1)
 factorial n | n &gt;= 0 = helper 1 n where
    helper r 0 = r
    helper r n = helper (r*n) (n-1)
 </pre>
 <p> Function "helper" is tail recursive and will be compiled to a while loop.
 Functions "factorial", "even" and "odd", however, employ tail calls.
 In "factorial", this is not a problem, it just sets up parameters for the
 very efficient "helper" function, thus we can expect a maximum stack depth of 2
 no matter what the value of "n" is.</p>
 <p> Things are different with "even" and "odd" that would need stack space
 proportional to the value of their argument if implemented naively.
 But frege functions may simply return their tail call in the form of
 an Unknown object instead of actually evaluating it themselves. This way, a long
 series of tail calls can be converted to a while loop, see <a href="../../frege/rt/Unknown.html#_e()"><code>_e()</code></a>. </p>
 <p>Unfortunately, this does not work in every case. Take the even/odd exmple in a slightly
 changed form:</p>
 <pre>
 even 0 = true
 even 1 = false
 even n = odd  (n-1)
 odd  n = !(even n)
 </pre>
 This will very soon run out of stack space with greater n. To see why, imagine <tt>even 5</tt>
 had to be evaluated.
 <pre>
 even 5 = odd 4               by 3rd rule of even
 odd 4 = !(even 4)            by definition of odd
 !(even 4) = !(odd 3)         by 3rd rule of even
 !(odd 3)  = !(!(even 3))
 !(!(even 3)) = !(!(odd 2))
 !(!(odd 2))  = !(!(!(even 2)))
 !(!(!(even 2))) = !(!(!(odd 1)))
 !(!(!(odd 1))) = !(!(!(!(even 0))))
 !(!(!(!(even 0)))) = !(!(!(!true)))
 </pre>
 <p>
 Because ! must first know the value to negate it must evaluate its argument
 before it returns. Hence, evaluation of (odd n) results in n nested negations, i.e. in
 a stack depth of n.
 </p>
 <p>This effect happens always when the recursion is done indirectly in an
 argument of a strict function. Another well-known case is the naive implementation
 of a function that tells a lists's length:</p>
 <pre>
 naiveLength [] = 0
 naiveLength (_:as) = 1 + naiveLength as
 </pre>
 <p>Here, the recursion takes place in the 2nd argument of the addition.
 To add 1 to something, one must first know to what, hence the
 whole list must be consulted before even the first addition 
 can take place.</p>
 <p>Compare the better implementation:</p>
 <pre>
 length xs = helper xs 0
    where
       helper []     !count = count
       helper (_:as) !count = helper as (count+1)
 </pre>
 Here, only tail call recursion takes place and because counter is strict, the increment
 will be evaluated in each loop.
 </li>
 </ol></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private <a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a></code></td>
<td class="colLast"><code><strong><a href="../../frege/rt/Unknown.html#result">result</a></strong></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../frege/rt/Unknown.html#Unknown()">Unknown</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a></code></td>
<td class="colLast"><code><strong><a href="../../frege/rt/Unknown.html#_e()">_e</a></strong>()</code>
<div class="block">Evaluates a lazy value.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../frege/rt/Unknown.html#_u()">_u</a></strong>()</code>
<div class="block"> Checks if this value is unevaluated.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract <a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../frege/rt/Unknown.html#_v()">_v</a></strong>()</code>
<div class="block">Do the real work in evaluating the result.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a></code></td>
<td class="colLast"><code><strong><a href="../../frege/rt/Unknown.html#call()">call</a></strong>()</code>
<div class="block"> Implemenation of the <code>Callable</code> interface </div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="result">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>result</h4>
<pre>private volatile&nbsp;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a> result</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Unknown()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Unknown</h4>
<pre>public&nbsp;Unknown()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="_e()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_e</h4>
<pre>public final&nbsp;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&nbsp;_e()</pre>
<div class="block"><p>Evaluates a lazy value.</p>

 <p> This is done by calling this._v() and,
          while the return value is still unevaluated,
          the _v() of the returned value and so on
          until the result is evaluated.
      </p>

 <p>The evaluated value will be a subclass of <a href="../../frege/rt/Value.html" title="interface in frege.rt"><code>Value</code></a>, such as
 a primitive value, a <a href="../../frege/rt/Boxed.html" title="class in frege.rt"><code>Boxed</code></a> java reference value or
 even a function type. </p>

 <p>
 e_() must be synchronized because
 parallel threads could try to _e() us at the same time.
 </p>

 <p> Deadlocks could occur only when one manages to
 construct two <em>different</em> Unknown objects a and b, where
 during evaluation of a the evaluated b is needed <b>and</b>
 during evaluation of b the the evaluated a is needed <b>and</b>
 one thread tries to evaluate a, thereby locking a first and
 another thread tries to evaluate b, thereby locking b first and
 then the first thread waits for b while the second one waits for a.</p>

 <p> This could happen, for instance,
  when the value of "blackhole" is computed: </p>

 <pre>
 a = b+1
 b = a-1
 blackhole = case a `par` b of (a,b) -> a+b
 </pre>

 <p> which should compile to something like this:

 <pre>
   static Lazy<Bint> a = new Unknown<Bint> () {
       Bint _v() { return b._e().j + 1; }
   }
   static Lazy<Bint> b = new Unknown<Bint> () {
       Bint _v() { return a._e().j - 1; }
   }
   ...
 </pre>

 <p> This, of course, is a programming error and, ironically, no answer
 is in some sense the correct answer to the question what number a or b is
 exactly. </p>

 <p> In a non parallel setting (i.e., when the `par` operator degenerates
 to the ordinary tuple constructor) the above equations  would simply
 result in a stack overflow. From the stack trace one could easily
 deduce that there was a blackhole, for it would look like</p>
 <pre>
      called from Unknown$1._e
      called from Unknown$2._v
      called from Unknown$2._e
      called from Unknown$1._v
      called from Unknown$1._e
      ...
 </pre></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../frege/rt/Lazy.html#_e()">_e</a></code>&nbsp;in interface&nbsp;<code><a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&gt;</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the evaluated value or <tt>this</tt> if it is already
         evaluated.</dd></dl>
</li>
</ul>
<a name="_v()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_v</h4>
<pre>public abstract&nbsp;<a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&gt;&nbsp;_v()</pre>
<div class="block"><p>Do the real work in evaluating the result.</p>

 <p>From the type one can see that _v() is not required to return
 an actual evaluated value. It can also return another unevaluated
 value, though the understanding is that the returned value must be
 somehow closer to the final result, so that, by calling that values _v()
 one gets even closer to the result and so forth until it is finally reached. </p>

 <p> This is the method subclasses of Unknown must implement. </p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../frege/rt/Lazy.html#_v()">_v</a></code>&nbsp;in interface&nbsp;<code><a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&gt;</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>another lazy value that may be a bit closer to the final result.</dd></dl>
</li>
</ul>
<a name="_u()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>_u</h4>
<pre>public final&nbsp;boolean&nbsp;_u()</pre>
<div class="block"><p> Checks if this value is unevaluated. </p>

 <p> If this is not the case, the value is cached and can be
 delivered via <a href="../../frege/rt/Unknown.html#_e()"><code>_e()</code></a> immediately.</p>

 <p> If evaluation is in progress in another thread, this method
 will block and return <tt>false</tt> when evaluation completes.</p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../frege/rt/Lazy.html#_u()">_u</a></code>&nbsp;in interface&nbsp;<code><a href="../../frege/rt/Lazy.html" title="interface in frege.rt">Lazy</a>&lt;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&gt;</code></dd>
<dt><span class="strong">Returns:</span></dt><dd><tt>true</tt> if this value is not yet evaluated, false otherwise.</dd></dl>
</li>
</ul>
<a name="call()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>call</h4>
<pre>public final&nbsp;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&nbsp;call()</pre>
<div class="block"><p> Implemenation of the <code>Callable</code> interface </p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code>call</code>&nbsp;in interface&nbsp;<code>java.util.concurrent.Callable&lt;<a href="../../frege/rt/Unknown.html" title="type parameter in Unknown">V</a>&gt;</code></dd>
<dt><span class="strong">Returns:</span></dt><dd>the result of <a href="../../frege/rt/Unknown.html#_e()"><code>_e()</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../frege/rt/SwingSupport.html" title="class in frege.rt"><span class="strong">Prev Class</span></a></li>
<li><a href="../../frege/rt/Value.html" title="interface in frege.rt"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?frege/rt/Unknown.html" target="_top">Frames</a></li>
<li><a href="Unknown.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
