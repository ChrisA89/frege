<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>frege.compiler.Scanner - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%) }
dt.clas { background: rgb(80%, 95%, 95%) }
dt.inst { background: rgb(95%, 90%, 95%) }
dt.data { background: rgb(95%, 95%, 95%) }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<H1>
<A name="package">Package <SPAN CLASS="code">frege.compiler.Scanner</SPAN></A></H1>
<P>
Compiled: Thu Oct 20 00:55:48 CEST 2011 from source file: <SPAN CLASS="code">.\frege\compiler\Scanner.fr</SPAN></P>
<H3>
Package Documentation</H3>
<P>
This is the scanner for the frege compiler.</P>
<P>
Essentialy, there are the following important functions:</P>
<UL>
<LI>
 the <A class="fref" href="#scan">scan</A> function turns a list of strings into a list of <A class="tref" href="./Data.html#Token">Data.Token</A>s. </LI>
<LI>
 the <A class="fref" href="#layout">layout</A> function takes the output from <A class="fref" href="#scan">scan</A> and inserts braces and semicolons according to layout rules.</LI>
<LI>
 the <A class="fref" href="#substAllOp">substAllOp</A> functions scans the output of the scan function and replaces sequences of single characters with operator symbols according to a table.</LI>
</UL>
<P>
The <A class="fref" href="#scan">scan</A> function has no way to know what operators are defined in the current source file or in imported packages. In previous versions of the compiler, this has been solved by calling import and updating the operator tree via a reference as soon as the parser reduced an "import" or "infix" declaration. Nowadays, we</P>
<OL>
<LI>
 build an initial operator table from the Prelude </LI>
<LI>
 scan without knowledge of the operators, </LI>
<LI>
 do the layout, </LI>
<LI>
 look for fixity definitions and imports </LI>
<LI>
 complete the operator table (which causes <A class="tref" href="../prelude/Base.html#IO">IO</A> actions in case of imports)</LI>
<LI>
 substitute characters with operators </LI>
</OL>
<P>
The resulting token list is ready to be passed to the parser. This way, parser and scanner are decoupled and are pure functions, with the exception of the part that builds the operator table.</P>
<H3>
Table of Content</H3>
<UL>
<LI>
<DIV>
<A HREF="#type">Type Aliases</A></DIV>
<DIV>
<A class="tref" href="#SMCT">SMCT</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#data">Data Types</A></DIV>
<DIV>
<A class="tref" href="#SM">SM</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#let">Functions and Values (alphabetically)</A></DIV>
<DIV>
<A class="fref" href="#buildSMCT">buildSMCT</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#chrlit">chrlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#commentStart">commentStart</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#findInfixImports">findInfixImports</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fltlit">fltlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#forbidden">forbidden</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#getop">getop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#hexlit">hexlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#iDent">iDent</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ident">ident</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#idop">idop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#interpret">interpret</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#is">is</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#isNot">isNot</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#kwtree">kwtree</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#layout">layout</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#opat">opat</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#opp">opp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#pass">pass</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#processImports">processImports</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#processInfix">processInfix</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#qualID">qualID</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#qualifier">qualifier</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#realop">realop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#regexp">regexp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scan">scan</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanChar">scanChar</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanCommentStart">scanCommentStart</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanId">scanId</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanNumber">scanNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanOp">scanOp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanQ">scanQ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanRegexp">scanRegexp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanSelect">scanSelect</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanSpecial">scanSpecial</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanString">scanString</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scancomment">scancomment</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#special">special</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#specialT">specialT</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#standardops">standardops</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#standardtops">standardtops</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#statemachine">statemachine</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strlit">strlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#substAllOp">substAllOp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#substOp">substOp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#validop">validop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#version">version</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#vor">vor</A></DIV>
</LI>
<LI>
<DIV>
<A HREF="#case">Functions and Values (by type)</A></DIV>
<DIV>
<A class="fref" href="#buildSMCT">buildSMCT</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#chrlit">chrlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#commentStart">commentStart</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#findInfixImports">findInfixImports</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#fltlit">fltlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#forbidden">forbidden</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#getop">getop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#hexlit">hexlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#iDent">iDent</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#ident">ident</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#idop">idop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#interpret">interpret</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#is">is</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#isNot">isNot</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#kwtree">kwtree</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#layout">layout</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#opat">opat</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#opp">opp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#pass">pass</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#processImports">processImports</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#processInfix">processInfix</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#qualID">qualID</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#qualifier">qualifier</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#realop">realop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#regexp">regexp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scan">scan</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanChar">scanChar</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanCommentStart">scanCommentStart</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanId">scanId</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanNumber">scanNumber</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanOp">scanOp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanQ">scanQ</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanRegexp">scanRegexp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanSelect">scanSelect</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanSpecial">scanSpecial</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scanString">scanString</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#scancomment">scancomment</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#special">special</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#specialT">specialT</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#standardops">standardops</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#standardtops">standardtops</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#statemachine">statemachine</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#strlit">strlit</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#substAllOp">substAllOp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#substOp">substOp</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#validop">validop</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#version">version</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#vor">vor</A>&nbsp;&nbsp;&nbsp; <A class="fref" href="#SM:SMT">SM.SMT</A></DIV>
</LI>
</UL>
<H3>
Imports</H3>
<UL>
<LI>
<DIV>
import <A HREF="../prelude/Base.html">frege.prelude.Base</A> as PreludeBase</DIV>
</LI>
<LI>
<DIV>
import <A HREF="../List.html">frege.List</A> as List</DIV>
</LI>
<LI>
<DIV>
import <A HREF="./Data.html">frege.compiler.Data</A> as Data</DIV>
</LI>
<LI>
<DIV>
import <A HREF="./Classtools.html">frege.compiler.Classtools</A> as Classtools</DIV>
</LI>
<LI>
<DIV>
import <A HREF="../IO.html">frege.IO</A> as IO</DIV>
</LI>
<LI>
<DIV>
import <A HREF="../Prelude.html">frege.Prelude</A> as Prelude</DIV>
</LI>
<LI>
<DIV>
import <A HREF="../prelude/Text.html">frege.prelude.Text</A> as PreludeText</DIV>
</LI>
<LI>
<DIV>
import <A HREF="./Utilities.html">frege.compiler.Utilities</A> as U</DIV>
</LI>
</UL>
<H2>
<A name="type">Type Aliases</A></H2>
<DL class="clas">
<DT class="clas">
<SPAN CLASS="code"><B>type </B><A name="SMCT">SMCT</A>  = <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="clas">
</DD>
</DL>
<H2>
<A name="data">Data Types</A></H2>
<DL class="data">
<DT class="data">
<SPAN CLASS="code"><B>data </B><A name="SM"> </A> <A class="tref" href="#SM">SM</A> a b</SPAN></DT>
<DD class="data">
<H3>
Constructors</H3>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="SMT">SMT</A> (<A class="tref" href="../List.html#Tree">List.Tree</A> a (<A class="tref" href="#SM">SM</A> a b))&nbsp;&nbsp; (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> b)</SPAN></DT>
<DD class="func">
</DD>
</DL>
</DD>
</DL>
<H2>
<A name="let">Functions and Values</A></H2>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A name="buildSMCT">buildSMCT</A> :: [(<A class="tref" href="../prelude/Base.html#String">String</A>, <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)] -&gt; <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
build a statmachine for character sequences from a list of type [(<A class="tref" href="../prelude/Base.html#String">String</A>, <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)]</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="chrlit">chrlit</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
matches a char literal</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="commentStart">commentStart</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
matches '{' or '-' start of a comment</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="findInfixImports">findInfixImports</A> :: <B>[<A class="tref" href="./Data.html#Token">Data.Token</A>]</B> -&gt; [[<A class="tref" href="./Data.html#Token">Data.Token</A>]]</SPAN></DT>
<DD class="func">
<P>
Find <SPAN CLASS="code">infix</SPAN> and <SPAN CLASS="code">import</SPAN> declarations in token stream.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="fltlit">fltlit</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
a decimal number</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="forbidden">forbidden</A> :: <B><A class="tref" href="../prelude/Base.html#Char">Char</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
tells if character is forbidden in operator</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="getop">getop</A> :: <B><A class="tref" href="../prelude/Base.html#String">String</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
look up a standardop</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="hexlit">hexlit</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
a hexadecimal number</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="iDent">iDent</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
matches Ident</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="ident">ident</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
matches identifier</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="idop">idop</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
an operator in backticks, either all word or all non word chars</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="interpret">interpret</A> :: <B>forall</B> a b.<A class="tref" href="../prelude/Base.html#Ord">Ord</A> a =&gt; <A class="tref" href="#SM">SM</A> a b -&gt; [a] -&gt; (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> b, [a])</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="is">is</A> :: <B><A class="tref" href="./Data.html#Token">Data.Token</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Char">Char</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
check whether <A class="tref" href="./Data.html#Token">Data.Token</A> is a specific char</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="isNot">isNot</A> :: <B><A class="tref" href="./Data.html#Token">Data.Token</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Char">Char</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
check whether <A class="tref" href="./Data.html#Token">Data.Token</A> is not a specific char</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="kwtree">kwtree</A> :: <A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
A map of keywords to <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>s</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="layout">layout</A> :: <B>[<A class="tref" href="../prelude/Base.html#Int">Int</A>]</B> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
This function does the layout on a list of <A class="tref" href="./Data.html#Token">Data.Token</A>s. The result is another list of <A class="tref" href="./Data.html#Token">Data.Token</A>s with some extra semicolons and braces in the correct places.</P>
<P>
The first argument is the context represented by a list of integers, where each element is either:</P>
<UL>
<LI>
 Zero, indicating that the enclosing context is explicit (i.e. the programmer supplied the opening brace). If the innermost context is 0, then no layout tokens will be inserted until either the enclosing context ends or a new context is pushed.</LI>
<LI>
 A positive integer, which is the indentation column of the enclosing layout context. </LI>
</UL>
<P>
The indentation of a token is the column number indicating the start of that token; the indentation of a line is the indentation of its leftmost lexeme. To determine the column number, assume a fixed-width font. For the purposes of the layout rule, Unicode characters in a source program are considered to be of the same, fixed, width as an ASCII character. The first column is designated column 1, not 0.</P>
<P>
The layout is done according to the following rules:</P>
<P>
1) an explicit '{' starts a new explicit context</P>
<P>
2) an explicit '}' can only occur in explicit context and closes this context</P>
<P>
3) if a <B><SPAN CLASS="code">let</SPAN></B>, <B><SPAN CLASS="code">do</SPAN></B>, <B><SPAN CLASS="code">where</SPAN></B> or <B><SPAN CLASS="code">of</SPAN></B> is not followed by '{' and the position of the next token is greater than the current context, insert '{' and push that position as new context.</P>
<P>
4) If the position of the first token on a line matches the context, a ';' is inserted before that token, except when the last token on the last line was already a semicolon.</P>
<P>
5) If the position of the first token on a line is less than the context, the context is closed and a closing brace is inserted.</P>
<P>
6) If <B><SPAN CLASS="code">in</SPAN></B> is found in layout mode without preceding closing brace, the closing brace is inserted and the context is closed</P>
<P>
7) At the end of the program, if there are open layout contexts, a corresponding number of closing braces is inserted.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="opat">opat</A> :: [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
makes a <A class="tref" href="../prelude/Base.html#Regex">Regex</A> that matches any string in <I>ops</I></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="opp">opp</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="pass">pass</A> :: (<A class="tref" href="../prelude/Base.html#String">String</A>-&gt;<A class="tref" href="../prelude/Base.html#ST">ST</A> <A class="tref" href="../prelude/Base.html#RealWorld">RealWorld</A> (<A class="tref" href="../prelude/Base.html#Either">Either</A> <A class="tref" href="../prelude/Base.html#JException">JException</A> (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> <A class="tref" href="./Classtools.html#OpArr">Classtools.OpArr</A>))) -&gt; <A class="tref" href="./Data.html#StIO">Data.StIO</A> <A class="tref" href="./Data.html#Global">Data.Global</A> [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="processImports">processImports</A> :: <B>forall</B> a.<A class="tref" href="../prelude/Base.html#String">String</A> -&gt; (<A class="tref" href="../prelude/Base.html#String">String</A>-&gt;<A class="tref" href="../prelude/Base.html#ST">ST</A> a (<A class="tref" href="../prelude/Base.html#Either">Either</A> <A class="tref" href="../prelude/Base.html#JException">JException</A> (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> <A class="tref" href="./Classtools.html#OpArr">Classtools.OpArr</A>))) -&gt; <A class="tref" href="../prelude/Base.html#Either">Either</A> (<A class="tref" href="../prelude/Base.html#Int">Int</A>, <A class="tref" href="../prelude/Base.html#String">String</A>) (<A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>) -&gt; [[<A class="tref" href="./Data.html#Token">Data.Token</A>]] -&gt; <A class="tref" href="../prelude/Base.html#ST">ST</A> a (<A class="tref" href="../prelude/Base.html#Either">Either</A> (<A class="tref" href="../prelude/Base.html#Int">Int</A>, <A class="tref" href="../prelude/Base.html#String">String</A>) (<A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>))</SPAN></DT>
<DD class="func">
<P>
build a map from <A class="tref" href="../prelude/Base.html#String">String</A>s to <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>s, which serves as dictionary of operators</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="processInfix">processInfix</A> :: <B>[[<A class="tref" href="./Data.html#Token">Data.Token</A>]]</B> -&gt; <A class="tref" href="../prelude/Base.html#Either">Either</A> (<A class="tref" href="../prelude/Base.html#Int">Int</A>, <A class="tref" href="../prelude/Base.html#String">String</A>) (<A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="qualID">qualID</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
Matches qualifier or constructor name. The pattern is <SPAN CLASS="code">Ident(.(Ident.)?)?</SPAN> If it matches and group 1 is present, then it's a qualifier else it's a constructor</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="qualifier">qualifier</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
matches Ident[.Ident].</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="realop">realop</A> :: <B><A class="tref" href="../prelude/Base.html#String">String</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
tells if the argument is a real operator, i.e. one that consists of non word characters only</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="regexp">regexp</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
matches a regular expression</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scan">scan</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Scans the string in the input list and returns a list of <A class="tref" href="./Data.html#Token">Data.Token</A>s. For each scanned token, there is one item giving</P>
<UL>
<LI>
 the token identifier that was recognized </LI>
<LI>
 the string that was matched </LI>
<LI>
 the line number where the string occured </LI>
<LI>
 the 1-based start position (column) of the token. </LI>
</UL>
<P>
The real work is done in various scan.... functions of type</P>
<PRE>
 Line -&gt; Matcher -&gt; [String] -&gt; [Token]</PRE>
<P>
where the following invariants are maintained:</P>
<P>
1) the <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> has just performed a successful match</P>
<P>
2) the <A class="tref" href="../prelude/Base.html#String">String</A> list is not empty</P>
<P>
3) the <A class="fref" href="../prelude/Base.html#head">head</A> of the <A class="tref" href="../prelude/Base.html#String">String</A>s is the one the <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> operates on</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanChar">scanChar</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Find a character literal.</P>
<P>
The matcher must point to a '\\''</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanCommentStart">scanCommentStart</A> :: <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
When the <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> points to a '{' or a '-' this can be the start of a block or line comment, where both may also be doc-comments. Otherwise it is just the character '/'</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanId">scanId</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Match identifier or keyword using <A class="fref" href="#ident">ident</A>.</P>
<P>
Precondition: the matcher points to a lowercase letter so that the pattern always matches.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanNumber">scanNumber</A> :: <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Find a numeric literal.</P>
<P>
The matcher must point to a digit.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanOp">scanOp</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Find an operator in backticks</P>
<P>
The matcher must point to a backtick.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanQ">scanQ</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Match qualifier or constructor name using <A class="fref" href="#qualID">qualID</A>. The <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> must point to an uppercase letter.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanRegexp">scanRegexp</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Find a regexp literal.</P>
<P>
The matcher must point to a '#'</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanSelect">scanSelect</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
This function selects the next scan function based on the next character.</P>
<P>
Earlier design tried one pattern after the other, but with the now immutable <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A>, this involves cloning of the matcher for each try. Which is, as some profiling exposed, the single most expensive operation. The new approach will need at most two tries.</P>
<P>
If the first character is</P>
<DL>
<DT>
{ or -</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanCommentStart">scanCommentStart</A> (1 find operation) </DIV>
</DD>
<DT>
a lowercase letter</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanId">scanId</A> (1 find operation) </DIV>
</DD>
<DT>
an uppercase letter</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanQ">scanQ</A> (1 find operation) </DIV>
</DD>
<DT>
a space character</DT>
<DD>
<DIV>
 we just skip and tailrecurse (1 find operation) </DIV>
</DD>
<DT>
a digit 0..9</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanNumber">scanNumber</A> (2 find operations) </DIV>
</DD>
<DT>
"</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanString">scanString</A> (1 find operation) </DIV>
</DD>
<DT>
#</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanRegexp">scanRegexp</A> (1 find operation) </DIV>
</DD>
<DT>
'</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanChar">scanChar</A> (1 find operation) </DIV>
</DD>
<DT>
anything else</DT>
<DD>
<DIV>
 we use <A class="fref" href="#scanSpecial">scanSpecial</A> (1 find operation) </DIV>
</DD>
</DL>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanSpecial">scanSpecial</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
match single character operators</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scanString">scanString</A> :: <B><A class="tref" href="../prelude/Base.html#Int">Int</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
find a string literal</P>
<P>
The matcher must point to a '"'</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="scancomment">scancomment</A> :: <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A> -&gt; <A class="tref" href="../prelude/Base.html#String">String</A> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
scan a block comment and recognize enclosed comment blocks, thereby collecting the comment text in case it is a doc comment.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="special">special</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
special operators or just character</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="specialT">specialT</A> :: <A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
special symbols in tree</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="standardops">standardops</A> :: [(<A class="tref" href="../prelude/Base.html#String">String</A>, <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)]</SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="standardtops">standardtops</A> :: <A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="statemachine">statemachine</A> :: <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; [([<A class="tref" href="../prelude/Base.html#Char">Char</A>], <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)] -&gt; <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="strlit">strlit</A> :: <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="substAllOp">substAllOp</A> :: <A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Substitute char sequences with operators, <A class="fref" href="./Data.html#TokenID:SOMEOP">Data.TokenID.SOMEOP</A> with operator, QULIFIER OP with a single token by constructing a statemachine and calling <A class="fref" href="#substOp">substOp</A> that does the real work.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="substOp">substOp</A> :: <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; <A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
Substitute char sequences with operators by recognizing the longest sequence that forms an operator without backtracking, <A class="fref" href="./Data.html#TokenID:SOMEOP">Data.TokenID.SOMEOP</A> with operator, <A class="fref" href="./Data.html#TokenID:QUALIFIER">Data.TokenID.QUALIFIER</A> OP with a single token.</P>
<P>
The first argument is a statemachine of type <A class="tref" href="#SMCT">SMCT</A> that reognizes all known operators.</P>
<P>
The statemachine was introduced when I tried out what would happen if I passed a file with wrong encoding or a binary file. In that case, long sequences of bytes are recognized by <A class="fref" href="#scan">scan</A> as <SPAN CLASS="code">Token { tokid = CHAR, ... }</SPAN> and then in the earlier version of <A class="fref" href="#substOp">substOp</A> the longest sequence of <A class="fref" href="./Data.html#TokenID:CHAR">Data.TokenID.CHAR</A> tokens was collected, a string was build, checked against the operator table and when there was no match, the last <A class="fref" href="./Data.html#TokenID:CHAR">Data.TokenID.CHAR</A> was pushed back and the processing repeated until we had a match or a string of length 0 and only then was the first character taken as <A class="fref" href="./Data.html#TokenID:CHAR">Data.TokenID.CHAR</A> and substOp continued with the rest of the sequence.</P>
<P>
While this is no problem with 2 or 3 character seqences, the runtime explodes with every additional character. To avoid this, I invented the statemachine that sees immediately when a string has no initial sequence that builds a known operator.</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="validop">validop</A> :: <B><A class="tref" href="../prelude/Base.html#String">String</A></B> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
checks if a user defined operator obeys certain rules:</P>
<UL>
<LI>
 it must not be one of "=" "|" "," ";" "." "\\" "_" "!" "?" "-" </LI>
<LI>
 it must not be one of "::" "&lt;-" "-&gt;" or "=&gt;" </LI>
<LI>
 it must not contain braces, square brackets or parentheses </LI>
<LI>
 it must not conatin one of the quoting characters " ' ` or # </LI>
<LI>
 it must not conatin digits </LI>
<LI>
 it must consist of either all word characters or all non word characters </LI>
</UL>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="version">version</A> :: <A class="tref" href="../prelude/Base.html#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
This is $Revision: 218 $</P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A name="vor">vor</A> :: <B><A class="tref" href="./Data.html#Token">Data.Token</A></B> -&gt; <A class="tref" href="./Data.html#Token">Data.Token</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
</DD>
</DL>
<H2>
<A name="case">Functions and Values by Type</A></H2>
<DL class="func">
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#substAllOp">substAllOp</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; <A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#substOp">substOp</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A> -&gt; [([<A class="tref" href="../prelude/Base.html#Char">Char</A>], <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)] -&gt; <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#statemachine">statemachine</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[(<A class="tref" href="../prelude/Base.html#String">String</A>, <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)] -&gt; <A class="tref" href="#SM">SM</A> <A class="tref" href="../prelude/Base.html#Char">Char</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#buildSMCT">buildSMCT</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[[<A class="tref" href="./Data.html#Token">Data.Token</A>]] -&gt; <A class="tref" href="../prelude/Base.html#Either">Either</A> (<A class="tref" href="../prelude/Base.html#Int">Int</A>, <A class="tref" href="../prelude/Base.html#String">String</A>) (<A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#processInfix">processInfix</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [[<A class="tref" href="./Data.html#Token">Data.Token</A>]]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#findInfixImports">findInfixImports</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[<A class="tref" href="../prelude/Base.html#Int">Int</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#layout">layout</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; <A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#opat">opat</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">(<A class="tref" href="../prelude/Base.html#String">String</A>-&gt;<A class="tref" href="../prelude/Base.html#ST">ST</A> <A class="tref" href="../prelude/Base.html#RealWorld">RealWorld</A> (<A class="tref" href="../prelude/Base.html#Either">Either</A> <A class="tref" href="../prelude/Base.html#JException">JException</A> (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> <A class="tref" href="./Classtools.html#OpArr">Classtools.OpArr</A>))) -&gt; <A class="tref" href="./Data.html#StIO">Data.StIO</A> <A class="tref" href="./Data.html#Global">Data.Global</A> [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#pass">pass</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="./Data.html#Token">Data.Token</A> -&gt; <A class="tref" href="./Data.html#Token">Data.Token</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#vor">vor</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="./Data.html#Token">Data.Token</A> -&gt; <A class="tref" href="../prelude/Base.html#Char">Char</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#is">is</A>, <A class="fref" href="#isNot">isNot</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#Char">Char</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#forbidden">forbidden</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scan">scan</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A> -&gt; <A class="tref" href="../prelude/Base.html#String">String</A> -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scancomment">scancomment</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#Int">Int</A> -&gt; <A class="tref" href="../prelude/Base.html#Matcher">Matcher</A> -&gt; [<A class="tref" href="../prelude/Base.html#String">String</A>] -&gt; [<A class="tref" href="./Data.html#Token">Data.Token</A>]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#scanChar">scanChar</A>, <A class="fref" href="#scanCommentStart">scanCommentStart</A>, <A class="fref" href="#scanId">scanId</A>, <A class="fref" href="#scanNumber">scanNumber</A>, <A class="fref" href="#scanOp">scanOp</A>, <A class="fref" href="#scanQ">scanQ</A>, <A class="fref" href="#scanRegexp">scanRegexp</A>, <A class="fref" href="#scanSelect">scanSelect</A>, <A class="fref" href="#scanSpecial">scanSpecial</A>, <A class="fref" href="#scanString">scanString</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#String">String</A> -&gt; <A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#getop">getop</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#String">String</A> -&gt; <A class="tref" href="../prelude/Base.html#Bool">Bool</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#realop">realop</A>, <A class="fref" href="#validop">validop</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#kwtree">kwtree</A>, <A class="fref" href="#specialT">specialT</A>, <A class="fref" href="#standardtops">standardtops</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code">[(<A class="tref" href="../prelude/Base.html#String">String</A>, <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>)]</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#standardops">standardops</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#Int">Int</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#version">version</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><A class="tref" href="../prelude/Base.html#Regex">Regex</A></SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#chrlit">chrlit</A>, <A class="fref" href="#commentStart">commentStart</A>, <A class="fref" href="#fltlit">fltlit</A>, <A class="fref" href="#hexlit">hexlit</A>, <A class="fref" href="#iDent">iDent</A>, <A class="fref" href="#ident">ident</A>, <A class="fref" href="#idop">idop</A>, <A class="fref" href="#opp">opp</A>, <A class="fref" href="#qualID">qualID</A>, <A class="fref" href="#qualifier">qualifier</A>, <A class="fref" href="#regexp">regexp</A>, <A class="fref" href="#special">special</A>, <A class="fref" href="#strlit">strlit</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a.<A class="tref" href="../prelude/Base.html#String">String</A> -&gt; (<A class="tref" href="../prelude/Base.html#String">String</A>-&gt;<A class="tref" href="../prelude/Base.html#ST">ST</A> a (<A class="tref" href="../prelude/Base.html#Either">Either</A> <A class="tref" href="../prelude/Base.html#JException">JException</A> (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> <A class="tref" href="./Classtools.html#OpArr">Classtools.OpArr</A>))) -&gt; <A class="tref" href="../prelude/Base.html#Either">Either</A> (<A class="tref" href="../prelude/Base.html#Int">Int</A>, <A class="tref" href="../prelude/Base.html#String">String</A>) (<A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>) -&gt; [[<A class="tref" href="./Data.html#Token">Data.Token</A>]] -&gt; <A class="tref" href="../prelude/Base.html#ST">ST</A> a (<A class="tref" href="../prelude/Base.html#Either">Either</A> (<A class="tref" href="../prelude/Base.html#Int">Int</A>, <A class="tref" href="../prelude/Base.html#String">String</A>) (<A class="tref" href="../List.html#Tree">List.Tree</A> <A class="tref" href="../prelude/Base.html#String">String</A> <A class="tref" href="./Data.html#TokenID">Data.TokenID</A>))</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#processImports">processImports</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="../List.html#Tree">List.Tree</A> a (<A class="tref" href="#SM">SM</A> a b) -&gt; <A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> b -&gt; <A class="tref" href="#SM">SM</A> a b</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#SM:SMT">SM.SMT</A></P>
</DD>
<DT class="func">
<SPAN CLASS="code"><B>forall</B> a b.<A class="tref" href="../prelude/Base.html#Ord">Ord</A> a =&gt; <A class="tref" href="#SM">SM</A> a b -&gt; [a] -&gt; (<A class="tref" href="../prelude/Base.html#Maybe">Maybe</A> b, [a])</SPAN></DT>
<DD class="func">
<P>
<A class="fref" href="#interpret">interpret</A></P>
</DD>
</DL>
<P>
<A HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></A></P>
</BODY>
</HTML>
