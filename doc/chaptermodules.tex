% $Revision$
% $Header: E:/iwcvs/fc/doc/chaptermodules.tex,v 1.4 2008/04/28 16:26:54 iw Exp $
% $Log: chaptermodules.tex,v $
% Revision 1.4  2008/04/28 16:26:54  iw
% - completed the expression chapter
% - started the definitions chapter
% - introduced some index entries
%
% Revision 1.3  2008/03/25 09:52:50  iw
% - lexical chapter completed and implementation adapted
%
% Revision 1.2  2007/09/23 12:09:26  iw
% - some more text
% - module chapter should be ready now up to explanation of the import list
%
% Revision 1.1  2007/09/22 16:01:18  iw
% - documentation
%
% Revision 1.2  2006/11/02 14:06:36  iw
% - something about modules, examples yet to be reviewed
%
% Revision 1.1  2006/06/29 21:14:24  iw
% initial revision (splitting up of Docu.tex)
%
%


\chapter{Packages} \label{packages} \index{package}

\frege{} code is organized in packages. One source file contains
exactly one package. Compilation of a package results in a \java{}
class, where the fully qualified class name equals the \frege{} package name.

For example:

\begin{code}
package pack.A;
// ... definitions ...
\end{code}

compiles to

\begin{code}
package pack;

class A {
    // compiled definitions
}
\end{code}


Each source file must start with a package declaration.
\ex{package A;}

The syntax of package names is given in \autoref{declarations}.

All components of the package name
except the last one should be in lowercase. This is because the \java{}
package name is derived from these components and \java{} has the
convention that the package name should be all lowercase.

The last component of the package name must match the source file
base name (i.e. the file name without the extension {\tt ".fr"}).
Since file systems used to store \frege{} source files may not support
case sensitive filenames, it will be wise to avoid package
names that differ in case only.

\section{Packages and Namespaces}

The package declaration creates a namespace, into which all items
defined in the package are compiled. The namespace has itself a name,
it is the last component of the package name. Namespace names must start
with an uppercase letter. They will never conflict with names of other
kinds like type names or value constructors. However, having a namespace and a type with the same name $N$ can lead to confusions when an item in the namespace $N$ has the same name $n$ as an item in the type $N$.
In that case, the qualified name \texttt{N.n} will always mean the item in the namespace.
The item in the type can still be named by qualifiying it with namespace and type name.

All items defined at the top level of the current namespace can be
accessed with unqualified names or with a name qualified by the
namespace.

\section{Importing Packages} \label{import} \index{package!import}

A package can import any other previously compiled package. An import
encloses the following steps:
\begin{itemize}
\item The class file corresponding to the imported package is loaded.
The class file must exist in the current class path or in a path given
with compiler command line flags.
\item A new namespace is created for the import. If no name for the name
space is specified, the last component of the given package name is
used.
\item Items defined in the imported package are extracted from the class
data and their definition is stored in the new name space.
\item If an import list was given, all items in the list are made
available also in the current namespace. An import list may be empty.

If no import list was given at all, all
defined items will be available in the current namespace.

\end{itemize}

It is not possible to import a \java{}-class file that does not result
from the compilation of a \frege{} source file.

Different packages must be imported into different name spaces.

It is possible to make use of types or classes that have no valid name in the current package. This is the case, for instance, when a package A declares a data type, package B imports this type and declares a function that returns values of this type and package C imports and uses that function from B, but does not import A. Apart from the fact that some type signatures can't be written in C this is no problem.

\subsection{Import lists}

All public definitions (i.e. functions, types, constructors,
instances and operators) of the imported package will be accessible in
the importing package through identifiers qualified with the associated
namespace name.

Instances declared in the imported package are automatically known in the current package. Since instances have no names, there is no way to refer to them explicitely.

Often one wishes to name some imported items without qualifiers. This
can be accomplished by listing those items in the import list:

\ex{import math.Rational(gcd Rat) as R;}

This causes the function {\tt Rational.gcd} to be known under the
name {\tt gcd} in the current package. Also, if there is a constructor
or type {\tt Rat} in {\tt math.Rational}, it will be known in the
current package. Both items can still be named as {\tt R.gcd} or {\tt
R.Rat}.

A value constructor may have the same name as a type constructor, type alias or class. It follows that mentioning an unqualified construtor name in an import list can be ambiguous. This is resolved in favour of type names, i.e. if a type, alias  or class with that name exists in the imported package, it will be imported. To import a value constructor with an ambiguous name, it must be qualified with it's type name in the import list.
\example{\\
package Imported;\\
class C where { ... };\\
data Notes = C | D | E | F | G | H | A | B;\\
\\
package Importing;\\
import Imported (C)       // class C\\
import Imported (Notes)   // data type Notes and its public constructors\\
import Imported (Notes.C) // just the data constructor
}

\subsection{Missing import list}

In addition, it is possible to import all public definitions of a
package into the
namespace of the importing package by not giving an import list.

\example{\\
import math.Rational;}

\subsection{Name clashes}

Once an item is imported into the current namespace it is not possible
to import an item with the same name and kind from another package
into the current namespace.

It is permitted to define an item that has the same name and kind (i.e. type, class, constructor, variable, function) like an imported one. 
The imported item will be overwritten, but is still available under its qualified name. 
However, the compiler will emit a warning in such cases.

\subsection{Aliasing the package name}
One can specify the name of the namespace into which
items will be imported. This makes it possible to disambiguate the
namespaces for imported packages.

For example, in

\begin{code}
import binary.Tree;
import balanced.Tree;    // wrong!
\end{code}

the second import would fail, because namespace \texttt{Tree} already
exists. The situation can be remedied like so:

\begin{code}
import binary.Tree;
import balanced.Tree as AVL;
\end{code}

\subsection{Multiple import}
One can import any package more than once, with different import
lists or different namespaces, as long as no name clashes occur. For
example

\begin{code}
import frege.List(map take);
import frege.List(sortBy);
import frege.List() as L;
\end{code}

This would be equivalent to \ex{
import frege.List(map take sortBy) as L;
import frege.List();
}

All public items of package \texttt{frege.List} can be named with qualifier \texttt{L.} or \texttt{List.} 
and the names of the functions \texttt{List.map},  \texttt{List.sortBy} and  \texttt{List.take} don't need to be qualified.

\subsection{Implicit \texttt{Prelude} import}
The compiler behaves as if the top declarations in
the source code contained
\ex{import frege.Prelude();}
This ensures that all prelude definitions can be accessed through
namespace \texttt{Prelude} and, at the same time, that no other package my be imported as {\tt Prelude}.


In addition, unless a user provided import clause explicitly imports package \texttt{frege.Prelude}, the
compiler automatically provides a
\ex{import frege.Prelude;}
This results
in the desired behaviour, namely that all common operators, types and
so on can be used with unqualified names.


\subsection{Examples}

\begin{code}
package A;
sqr x = x*x;
dbl x = x+x;
\end{code}

The package {\tt A} defines the functions
{\tt sqr} and {\tt dbl}.

\begin{code}
package modul.with.AnUnwieldlyLongName;
import A();
triple x = A.dbl x + x;
\end{code}

The package with the long name can
access
{\tt A}'s {\tt dbl} function with the qualified name
{\tt A.dbl}.

\begin{code}
package B;
import modul.with.AnUnwieldlyLongName() as L;
sixfold x = let x' = L.triple x in x' + x';
\end{code}

The author of package {\tt B} imported the symbols of {\tt
modul.with.AnUnwieldlyLongName} into the namespace {\tt L},
perhaps because he was too lazy to type the long name too often.


\begin{code}
package C;
import A();
import B;
sevenfoldsquared x =
    let
        x' = sixfold x
    in A.sqr (x+x');
\end{code}

Package {\tt C} imports all of {\tt B}'s symbols into its own
namespace, so {\tt B.sixfold} can be used unqualified.

\subsection{Rules for Namespaces}

When a package is imported, all symbols defined in that package are made
available and can then be used in the importing package either
with or without qualification.
However, this does not apply to namespace names themselves. Namespaces of imported packages can't be referenced.

Thus,
in package {\tt C} above, it is {\bf not} possible to reference the
{\tt triple} function via {\tt B.L.triple} or
{\tt B.modul.with.AnUnwieldlyLongName.triple}.


\subsection{Importing types with instances}

Conflicts may arise when an imported package contains an instance for
the same type class and data constructor as another imported package.
Unfortunately, it doesn't matter whether the package was explicitley or
implicitely imported. This is
because for each class there may be at most one
known instance per type constructor in the collection of namespaces that
is built during compilation of a package.

It is also not possible to prevent the automatic import of instances,
because the compiler has no way to check whether the instance has been
used in the imported package, that is, if compiled code already
references the instance by its \java{} class name.

In greater projects it is therefore advised to write different packages
for data declaration and instance declaration. When the instance
declaration is the only declaration in a package, one can decide not to
use it by not importing that package and any package that uses it.

The situation is still favorable in \frege{} compared to \java{} where
the implemented interfaces are part of the type declaration. In \frege{}
one can define an instance without even having the source code of the
definition of the instantiated type.
