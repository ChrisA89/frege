% $Revision$
% $Header: E:/iwcvs/fc/doc/chaptermodules.tex,v 1.4 2008/04/28 16:26:54 iw Exp $
% $Log: chaptermodules.tex,v $
% Revision 1.4  2008/04/28 16:26:54  iw
% - completed the expression chapter
% - started the definitions chapter
% - introduced some index entries
%
% Revision 1.3  2008/03/25 09:52:50  iw
% - lexical chapter completed and implementation adapted
%
% Revision 1.2  2007/09/23 12:09:26  iw
% - some more text
% - module chapter should be ready now up to explanation of the import list
%
% Revision 1.1  2007/09/22 16:01:18  iw
% - documentation
%
% Revision 1.2  2006/11/02 14:06:36  iw
% - something about modules, examples yet to be reviewed
%
% Revision 1.1  2006/06/29 21:14:24  iw
% initial revision (splitting up of Docu.tex)
%
%


\chapter{Packages} \label{packages} \index{package}

\frege{} code is organized in packages. One source file contains
exactly one package. Compilation of a package creates an  intermediary \java{}
source file that contains the definition of a public class whose fully qualified name equals the \frege{} package name. Finally, the \java{} compiler is invoked to compile the intermediate file, which results in at least one class file.

For example:

\begin{code}
package pack.A where  // frege code
// declarations and bindings
\end{code}

compiles to

\begin{code}
package pack;        // java code

public class A {
    // compiled declarations and bindings
}
\end{code}


Each source file must start with a \hyperref[packagedcl]{package declaration}.
The syntax of package names is given in \autoref{declarations}.

All components of the package name
except the last one should be in lowercase. This is because the \java{}
package name is derived from these components and \java{} has the
convention that the package name should be all lowercase.

Neither file name of the \frege{} source code file nor the path where that file is stored have to reflect or match the package name. However, the intermediate \java{} source file and the final class files are subject the the customs of \java{}. That means that the files reside in a path that resembles the package name and the file name is the class name plus a suffix.

\section{Packages and Namespaces}

The package declaration creates the namespace wherein all top level declarations 
of the package live. The namespace has itself a name,
it is the last component of the package name. Namespace names must start
with an uppercase letter. They will never conflict with names of other
kinds like type names or value constructors. 
However, having a namespace and a type with the same name $N$ can lead to confusions, as explained earlier in the section that deals with \hyperref[qualified names]{qualified names}.

All items defined at the top level of the current namespace can be
accessed with unqualified names or with a name qualified by the
namespace.

\section{Importing Packages} \label{import} \index{package!import}

A package can import any other previously compiled package with an import declaration.
The import declarations are processed in the order they occur in the program text. 
However, their placement relative to other declarations is immaterial. 
Even so, it is considered good style to write all import declarations somewhere near the top of the program.

\begin{flushleft}
\rul{pkgimport} \textbf{import} \nont{packagename} \opt{\nont{importlist}} \opt{\nont{namespace}}\\
\rul{importlist} \opt{\term{except}} \sym{(} \opt{\liste{importitem}{}} \sym{)} \\
\rul{importitem} \nont{varid} \oder{} \nont{conid}  \oder{} \nont{symop} \oder{} 
 \nont{conid}\sym{.}\nont{varid} \oder{} \nont{conid}\sym{.}\nont{conid}  \oder{} \nont{conid}\sym{.}\nont{symop} \\
\rul{namespace} \nont{conid} \\
\end{flushleft}

An import encloses the following steps:
\begin{itemize}
\item The class file corresponding to the imported package is loaded.
The class file must exist in the current class path or in a path given
with compiler command line flags.
\item A new namespace is created for the import. If no name for the name
space was specified, the last component of the given package name is
used.
\item Items defined in the imported package are extracted from the class file
data and their definition is stored in the new name space.
\item The import list will be processed as laid out in the following sections.
\end{itemize}

\note{It is not possible to import a \java{} class file that does not result
from the compilation of a \frege{} source file.}

Different packages must be imported into different name spaces.

It is possible to make use of types or classes that have no valid name in the current package. 
This is the case, for instance, when a package A declares a data type, 
package B imports this type and declares a function that returns values of this type 
and package C imports and uses that function from B, but does not import A. 
Apart from the fact that some type signatures can't be written in C this is no problem.

\subsection{Import lists}

All public definitions (i.e. functions, values, types, constructors,
type classes, instances and operators) of the imported package will be accessible in
the importing package through identifiers qualified with the associated
namespace name.

Instances declared in the imported package are automatically known in the current package. Since instances have no names, there is no way to refer to them explicitly.

Often one wishes to name some imported items without qualifiers. This
can be accomplished by listing those items in the import list:

\example{import math.Rational(gcd Rat)  R}

This causes the function {\tt Rational.gcd} to be known under the
name {\tt gcd} in the current package. Also, if there is a constructor
or type {\tt Rat} in {\tt math.Rational}, it will be known in the
current package. Both items can still be named as {\tt R.gcd} or {\tt
R.Rat}.

A value constructor may have the same name as a type constructor, type alias or class. It follows that mentioning an unqualified constructor name in an import list can be ambiguous. This is resolved in favor of type names, i.e. if a type, alias  or class with that name exists in the imported package, it will be imported. To import a value constructor with an ambiguous name, it must be qualified with its type name in the import list.
\example{\\
package Imported where\\
class C where { ... }\\
data Notes = C $|$ D $|$ E $|$ F $|$ G $|$ H $|$ A $|$ B\\
\\
package Importing where\\
import Imported (C)       // class C\\
import Imported (Notes)   // data type Notes and its public constructors\\
import Imported (Notes.C) // just the data constructor
}

\paragraph*{Empty import list} If the import list is empty, no items are imported to the current namespace. Nevertheless, as before, all items of the imported package can be accessed with qualified names.

\subsection{Importing all items}

In addition, it is possible to import all public definitions of a
package into the
namespace of the importing package by not giving an import list.

\example{\\
import math.Rational}

\subsection{Importing all but some items}

If the import list is preceded by the word "\term{except}", all items but the named ones are made available for unqualified access in the current package.

\example{import math.Rational except(gcd)}

\subsection{Name clashes}

Once an item is imported into the current namespace it is not possible
to import an item with the same name and kind from another package
into the current namespace.

It is permitted to re-introduce a previously imported name through a declaration or binding.
All unqualified uses of that name are resolved to refer to the declaration from the current package, but the imported item is still available under its qualified name.
The compiler shall emit a warning in such cases.

It is also possible that an import overwrites an item in the current namespace that was introduced through a previous import.
The compiler must emit a warning in such cases.
The last imported item of that name will be identified with the unqualified name.

It is advised to use selective import lists to avoid such clashes.


\subsection{Aliasing the package name}
One can specify the name of the namespace into which
items will be imported. This makes it possible to disambiguate the
namespaces for imported packages.

Consider the case that one needs two packages whose namespace names would come out equal, as in

\example{\\
import binary.Tree\\
import balanced.Tree    // wrong!
}

Here, the second import would fail, because namespace \texttt{Tree} already
exists. The situation can be remedied like so:

\example{\\
import binary.Tree\\
import balanced.Tree  AVL
}

\subsection{Multiple import}
One can import any package more than once, with different import
lists or different namespaces. 

\example{\\
import frege.List(map take)\\
import frege.List(sortBy)\\
import frege.List() L
}

This would be equivalent to 

\example{\\
import frege.List(map take sortBy)\\
import frege.List() L
}

All public items of package \texttt{frege.List} can be named with qualifier \texttt{L.} or \texttt{List.} 
and the names of the functions \texttt{List.map},  \texttt{List.sortBy} and  \texttt{List.take} don't need to be qualified.

Name clashes may occur if the effective import lists have elements in common. 

\subsection{Implicit \texttt{Prelude} import}
The compiler behaves as if the top declarations in
the source code contained the import declaration
\ex{import frege.Prelude()}
before all other import declarations.
This ensures that all prelude definitions can be accessed through
namespace \texttt{Prelude} and, at the same time, that no other package my be imported as {\tt Prelude}.

In addition, unless a user provided import clause explicitly imports package \texttt{frege.Prelude}, the
compiler automatically provides a
\ex{import frege.Prelude}
before all other import declarations.
This results
in the desired behaviour, namely that all common operators, types and
so on can be used with unqualified names.


\subsection{Rules for Namespaces}

When a package is imported, all symbols defined in that package are made
available and can then be used in the importing package either
with or without qualification.
However, this does not apply to namespace names themselves. 
Namespaces that were known in the imported package
because of package imports can't be referenced.

\subsection{Importing types with instances}

Ambiguities arise when an imported package contains an instance for
the same type class and data constructor as another imported package.

It is impossible to prevent the automatic import of instances,
because the compiler has no way to check whether the instance has been
used in the imported package, that is, if compiled code already
references the instance by its \java{} class name.

\todo{explain what happens in case of multiple instances}
