% $Revision$
% $Date$
% $Id$


\chapter{Packages} \label{packages} \index{package}

\frege{} code is organized in packages. One source file contains
exactly one package. Compilation of a package creates an  intermediary \java{}
source file that contains the definition of a public class whose fully qualified name equals the \frege{} package name. Finally, the \java{} compiler is invoked to compile the intermediate file, which results in at least one class file.

For example:

\begin{code}
package pack.A where  -- frege code
-- declarations and bindings
\end{code}

compiles to

\begin{code}
package pack;        // java code

public class A {
    // compiled declarations and bindings
}
\end{code}


Each source file must start with a \hyperref[packagedcl]{package declaration}.
The syntax of package names is given in \autoref{declarations}.

All components of the package name
except the last one should be in lowercase. This is because the \java{}
package name is derived from these components and \java{} has the
convention that the package name should be all lowercase.

Neither file name of the \frege{} source code file nor the path where that file is stored have to reflect or match the package name. However, the intermediate \java{} source file and the final class files are subject the the customs of \java{}. That means that the files reside in a path that resembles the package name and the file name is the class name plus a suffix.

\section{Packages and Namespaces}

The package declaration creates the namespace wherein all top level declarations 
of the package live. The namespace has itself a name,
it is the last component of the package name. Namespace names must start
with an uppercase letter. They will never conflict with names of other
kinds like type names or value constructors. 
However, having a namespace and a type with the same name $N$ can lead to confusions, as explained earlier in the section that deals with \hyperref[qualified names]{qualified names}.

All items defined at the top level of the current namespace can be
accessed with unqualified names or with a name qualified by the
namespace.


\section{Importing Packages} \label{import} \index{package!import}


A package can import any other previously compiled package with an import declaration.
A compiled package contains information about all non private type aliases, type classes, instances, 
data types, functions and values defined in it in a form that allows for quick reconstruction of the packages symbol table.
Hence, during compilation of the importing package the compiler will know the names, kinds and types of the imported items and can generate appropriate code to access them.

The import declarations are processed in the order they occur in the program text. 
However, their placement relative to other declarations is immaterial. 
Even so, it is considered good style to write all import declarations somewhere near the top of the program.

\begin{flushleft}
\rul{pkgimport} \textbf{import} \nont{packagename} \opt{\term{public}} {\nont{importlist}} \opt{\nont{namespace}}\\
\rul{importlist} \opt{\term{except}} \sym{(} \opt{\liste{\nont{importspec}}{\sym{,}}} \sym{)} \\
\rul{importspec} \opt{\term{public}} \nont{importitem} \opt{ \nont{alias}}\\
\rul{importitem} \nont{varid} \oder{} \nont{conid}\opt{\nont{members}}   \oder{} \nont{symop} \oder{} 
 \nont{conid}\sym{.}\nont{varid} \oder{} \nont{conid}\sym{.}\nont{conid}  \oder{} \nont{conid}\sym{.}\nont{symop} \\
\rul{alias} \nont{varid} \oder {} \nont{conid}  \oder {} \nont{symop} \gcom{must match the aliased item}\\
\rul{members} \sym{(} \opt{\liste{\nont{memspec}}{,}} \sym{)}\\
\rul{memspec} \opt{\term{public}} \nont{member} \opt{\nont{alias}}\\
\rul{member} \nont{varid}  \oder {} \nont{symop} \oder {} \nont{conid} \\
\rul{namespace} \nont{conid} \\
\end{flushleft}

An import encloses the following steps:
\begin{itemize}
\item The class file corresponding to the imported package is loaded.
The class file must exist in the current class path or in a path given
with compiler command line flags.
\item A new namespace is created for the import. If no name for the name
space was specified, the last component of the given package name is
used.
\item Items defined in the imported package are extracted from the class file
data and their definition is stored in the new name space.
\item The import list will be processed to give certain imported items names in the current namespace, so that they may be accessed with unqualified names. This process of linking is laid out in the following sections.
\end{itemize}

It is not possible to import a \java{} class file that does not result
from the compilation of a \frege{} source file.

Different packages must be imported into different name spaces.

It is possible to make use of types or classes that have no valid name in the current package. 
This is the case, for instance, when a package A declares a data type, 
package B imports this type and defines functions that use this type 
and package C imports and uses that function from B, but does not import A. 
Apart from the fact that some type signatures can't be written in C this is no problem.

\subsection{Import lists}

All non private definitions (i.e. functions, values, types, constructors,
type classes and operators) of the imported package will be accessible in
the importing package through identifiers qualified with the associated
name space name.

Instances play a special role insofar as they cannot be named and hence cannot appear in import lists. 
Therefore they will be automatically known, no matter how the import list looks like.  

Often one wishes to name some imported items without qualifiers. This
can be accomplished by listing those items in the import list:

\example{import math.Rational(gcd, Rat)  R}

This causes the function {\tt Rational.gcd} to be known under the
name {\tt gcd} in the current package. Also, if there is a constructor
or type {\tt Rat} in {\tt math.Rational}, it will be known in the
current package. Both items can still be named as {\tt R.gcd} or {\tt
R.Rat}.

A value constructor may have the same name as a type constructor, type alias or class. 
It follows that mentioning an unqualified constructor name in an import list can be ambiguous. 
This is resolved in favor of type names, i.e. if a type, alias  or class with that name exists in the imported package, 
it will be linked to the current namespace. 
To import a value constructor with an ambiguous name, it must be qualified with its type name in the import list.
\example{\\
package Imported where\\
class C where { ... }\\
data Notes = C $|$ D $|$ E $|$ F $|$ G $|$ H $|$ A $|$ B\\
\\
package Importing where\\
import Imported (C)       -- class C\\
import Imported (Notes)   -- data type Notes and its public constructors\\
import Imported (Notes.C) -- just the data constructor
}

\paragraph*{Controlling import of data constructors and members}

%A class name in an import list can be followed by a list of class operations that should be available in the namespace of the importing package. If the list is empty, only the class name itself is imported, access to the class operations are possible through names that are qualified with the class name. If the list is missing, all public class operations are available.

A type name in an import list can be followed by a list of names declared in that type that should be linked to the namespace of the importing package in addition to the type name itself. If the list is empty, no additional names are linked. If the list is missing, all public constructor names are linked.

This feature can be used to prevent unwanted linking of constructor names to avoid name clashes, like in the following example:

\example{\\
package A where data T1 = T ....\\

package B where data T2 = T ...\\

package C where\\
import A( T1() )\\
import B( T2 )  -- hence T means T2.T
}

Like with items in the import list, data members can be  \hyperref[renameitem]{renamed} 
or  \hyperref[reexport]{re-exported}.
  
An alternative solution for the constructor name clash problem would be:

\example{\\
package A where data T1 = T ....\\

package B where data T2 = T ...\\

package C where\\
import A( T1( T = TA) )  -- TA means A.T1.T \\
import B( T2( T = TB) )  -- TB means B.T2.T
}

\paragraph*{Empty import list} If the import list is empty, no named items are linked to the current namespace. Nevertheless, as before, all items of the imported package can be accessed with qualified names.

\subsection{Importing all public items}

In addition, it is possible to link all public definitions of a
package into the namespace of the importing package by not giving an import list at all.

This will not make available the items declared \term{protected}. 
Protected items are linked only when explicitly mentioned in an import list.

\example{\\
import math.Rational}

\subsection{Renaming on import} \label{renameitem}

An item can be put in the current namespace with a different name. However, \nont{conid}s can only be aliased to \nont{conid}s while \nont{varid}s and \nont{symop}s can not be aliased to \nont{conid}s.

This is useful to avoid name clashes or to adapt naming conventions\footnote{
Be aware, though, that error messages may report the original qualified name.}.

Multiple aliases are possible for a single item.

\example{\\
import math.Rational (gcd = greatestCommonDivisor, gcd = ggT)}

It is important to understand that the qualified name of an imported item remains unaffected by renaming. 
All names created by imports in the current namespace are merely symbolic links to the original item. 
Hence, after the import of the example, the names \term{Rational.gcd}, \term{greatestCommonDivisor} and \term{ggT} reference the same item. 

\subsection{Re-exporting imported items} \label{reexport}

It is possible to have a packages re-export all or some of its imported items 
along with the items declared in the package itself, if any\footnote{
It is perfectly legal for a package to contain nothing but import declarations.}, 
so that importing  packages can import many related items from possibly many different packages with one import.

A library designer can use this feature, especially in combination with item renaming, 
to hide implementation details of his library, 
such as package names, where and under what name exactly an item is defined etc.,
by providing a single package defining the "official" interface of the library. 
If the library is redesigned later, the package defining the interface can be adapted accordingly 
so that backwards source compatibility can be maintained\footnote{
However, binary backwards compatibility can not be achieved this way, because on the \java{} and JVM level any class,
method, etc. has only one unambiguous name.}.

To re-export a single item, one writes \term{public} before its name in the import list. Note that it is the alias name that will be exported for renamed items.
To re-export all items in the import list or just all public items when there is no import list, one writes \term{public} after the package name.

\example{\\
package x.y.API where\\
import x.y.z.Sub1 (public creat = create, public fold = reduce)\\
import x.y.z.Sub2 public except (deprecated1, deprecated2, ...)\\
import x.y.contributed.byXY.Utilities public\\

package XYClient where\\
import x.y.API   \\
-- makes available create, reduce, non deprecated items from Sub2\\
-- and public utiliities from contributor XY, but the client need not\\
-- know all those details.
}

\subsection{Importing all but some items}

If the import list is preceded by the word "\term{except}", all public items but the named ones are made available for unqualified access in the current namespace.

\example{import math.Rational except(gcd)}

Note that for the names listed in an except list, the re-export and the renaming syntax do not make sense. 
Anyway, it is still possible to re-export the items effectively linked this way by placing a "\term{public}" between the package name and "\term{except}".


\subsection{Name clashes}

%Once an item is imported into the current namespace it is not possible
%to import (implicitely or ecplicitely) an item with the same name and kind from another package
%into the current namespace.

It is permitted to overwrite a previously imported name through a declaration or binding.
All unqualified uses of that name are resolved to refer to the declaration from the current package, 
but the imported item is still available under its qualified name.
The compiler shall emit a warning in such cases.

It is also possible that an import overwrites an item in the current namespace that was introduced through a previous import.
The compiler must emit a warning in such cases.
The unqualified name will link to the last imported item.

It is advised to use the import features described above to avoid such clashes.

\subsection{Aliasing the package name}
One can specify the name of the namespace into which
items will be imported. This makes it possible to disambiguate the
namespaces for imported packages.

Consider the case that one needs two packages whose namespace names would come out equal, as in

\example{\\
import binary.Tree\\
import balanced.Tree    -- will fail, Tree is already a name space
}

Here, the second import would fail, because namespace \texttt{Tree} already
exists. The situation can be remedied like so:

\example{\\
import binary.Tree\\
import balanced.Tree  AVL  -- all items go in namespace AVL
}

\subsection{Multiple import}
One can import any package more than once, with different import
lists or different namespaces. 

\example{\\
import frege.List(map take)\\
import frege.List(sortBy)\\
import frege.List() L
}

This would be equivalent to 

\example{\\
import frege.List(map take sortBy)\\
import frege.List() L
}

All public items of package \texttt{frege.List} can be named with qualifier \texttt{L.} or \texttt{List.} 
and the names of the functions \texttt{List.map},  \texttt{List.sortBy} and  \texttt{List.take} don't need to be qualified.

Name clashes may occur if the effective import lists have elements in common. 

\subsection{Implicit \texttt{Prelude} import}
The compiler behaves as if the top declarations in
the source code contained the import declaration
\ex{import frege.Prelude()}
before all other import declarations.
This ensures that all prelude definitions can be accessed through
namespace \texttt{Prelude} and, at the same time, that no other package my be imported as {\tt Prelude}.

In addition, unless a user provided import clause explicitly imports package \texttt{frege.Prelude}, the
compiler automatically provides a
\ex{import frege.Prelude}
before all other import declarations.
This results
in the desired behaviour, namely that all common operators, types and
so on can be used with unqualified names.


\subsection{Rules for Namespaces}

When a package is imported, all symbols defined in that package are made
available and can then be used in the importing package.
However, this does not apply to namespace names themselves. 
Namespaces exist only during compilation and are a means to organize the symbol table.

Therefore, namespaces used in the source code of the imported package
cannot be referenced in importing packages.

\subsection{Importing packages with instances}

Ambiguities arise when an imported package contains an instance for
the same type class and data constructor as another imported package.

\todo{explain what happens in case of multiple instances}
