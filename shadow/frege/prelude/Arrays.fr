{-
    Copyright Â© 2011, Ingo Wechsung
 
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

    -   Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

    -   Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.
 
    *THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.*
-}

{--
 *
 * This package provides basic definitions for the Frege language.
 *
 * The _Prelude_ packages are imported explicitly or implicetly during compilation
 * of any other package.
 * They define basic data structures, classes and functions.
 *
 *
 * This package is _implementation specific_ insofar as the compiler may
 * assume that certain items are defined here in a certain way.
 * Changes may thus lead
 * to compiler crashes or java code that will be rejected by the java compiler.
 -}


protected package frege.prelude.Arrays where

import frege.prelude.PreludeBase 
import frege.prelude.PreludeList(ListSource, length, map, fold)
import frege.prelude.Maybe (mapMaybe)
import frege.prelude.PreludeMonad
import frege.prelude.PreludeIO
import frege.control.Semigroupoid
import frege.control.Category

--- warning: Array is deprecated
type Array e = STArray e 
instance Cloneable (STArray elem)
    
-- instance ListSource Array    
--- warning: STArray is deprecated
data STArray elem = native "frege.runtime.Array" where
    --- warning: STArray.new is deprecated
    native      new                           :: Int -> STMutable s (STArray elem)
    --- warning: STArray.length is deprecated
    pure native length                        :: STArray elem -> Int
    --- warning: STArray.setAt is deprecated
    native      setAt                         :: Mutable s (STArray elem) -> Int -> elem -> ST s ()

    --- warning: STArray.setAtMB is deprecated
    --- set array element to value v when passed @(Just v)@ or null (Nothing)
    native      setAtMB           setAt       :: Mutable s (STArray elem) -> Int -> Maybe elem -> ST s ()
    --- warning: STArray.getAt is deprecated
    --- Fetch array element and return @Just v@, if it is not a null value, otherwise @Nothing@
    native      getAt                         :: Mutable s (STArray elem) -> Int -> ST s (Maybe elem)
    --- warning: STArray.elemAt is deprecated
    --- Fetch array element  *without* checking for @null@ value.
    --- To be used only when it is sure that there are no @null@ values in the array.
    native      elemAt            getAt       :: Mutable s (STArray elem) -> Int -> ST s elem
    
    --- warning: STArray.frozenGetAt is deprecated
    --- Fetch array element form a frozen array
    pure native frozenGetAt       getAt       :: Array elem -> Int -> Maybe elem
    --- warning: STArray.frozenElemAt is deprecated
    --- Fetch array element from a frozen array *without* checking for @null@ value.
    pure native frozenElemAt      getAt       :: Array elem -> Int -> elem

    --- warning: STArray.fromListST is deprecated
    --- Create array from (finite) list.
    --- The resulting Array does not contain null values
    fromListST :: [elem] -> STMutable u (STArray elem)
    fromListST elems = (Array.new elems.length >>= loop 0 elems) where
        loop !j (x:xs) arr = do Array.setAt arr j x; loop (j+1) xs arr
        loop !j []     arr = return arr
    --- warning: STArray.fromList is deprecated
    --- create an immutable arra from a list
    fromList elems = ST.run (fromListST elems >>= readonly id)

    --- warning: STArray.toList is deprecated
    --- Collect non-null elements from an immutable array.
    toList a = elems a 0 -- [ e | Just e  <- [ a.[i] | i <- 0..a.length-1 ]];
        where
            elems a i
                | i < Array.length a = case Array.frozenGetAt a i of
                    Just s  -> s:elems a (i+1)
                    Nothing -> elems a (i+1)
                | otherwise = []

    --- warning: STArray.toInxList is deprecated
    {--
     * Extract all non null elements from an immutable array, togehther with
     * their indexes.
     * For arrays whose last element is not null, the following holds:
     > fromInxList (toInxList arr) == arr
     -}
    toInxList :: Array a -> [(Int, a)]
    toInxList arr = [ (i,x) | (i, Just x) <- [ (i, arr.frozenGetAt i) | i <- [0..arr.length-1]]]
    --- warning: STArray.fromInxListST is deprecated
    {--
      * Create a mutable array from a list of tuples ('Int', a).
      * The size of the array will be so that it can accomodate the
      * greatest index. Elements whose index does not appear in the list
      * reamin unset, i.e. they are initialised with the null value.
      *
      * Negative indexes cause java exceptions to be thrown.
      -}
    fromInxListST :: [(Int, a)] -> STMutable s (STArray a)
    fromInxListST xs = Array.new n >>= loop xs where
        n = 1 + fold max 0 (map fst xs)
        loop :: [(Int, a)] -> Mutable s (STArray a) -> STMutable s (STArray a)
        loop ((i,x):xs) arr = do
            Array.setAt arr i x
            loop xs arr
        loop [] arr = return arr
    --- create immutable array using frozen result of 'Array.fromInxListST'
    --- warning: STArray.fromInxList is deprecated
    fromInxList xs = ST.run (fromInxListST xs >>= readonly id)


