--- Code generation compatible with Java7 *or* Java8 syntax

{--
    ## Concepts

    ### Data types

    Representation of data types doesn't change.


    ### Instances

    Instance functions can now be called directly via the type class
    object, instead of first getting a function pointer.


    ### Higher order functions

    Arguments that have a function type are always strict.


    ### Function arity
    
    The code generator keeps track of the arity of functions.
    For example, in @flip :: (a -> b -> c) -> b -> a -> c@
    it will pass and expect a @Func2@. If you pass a function @f@ with
    arity 1 to @flip@, it will be wrapped in an extra lambda
    @\a\b -> (f a) $ b@.

    When you pass a function @g@ with a higher arity, say 4,
    it will be wrapped in a lambda @(\a\b -> (\x3\x4 -> g a b x3 x4))@.
    
    Fortunately, the compiler will have established type soundness
    during type checking, so that in the first case we know that
    the unary function actually returns another unary function and the
    application @flip g a b@ yields a binary function.


    ### Partial applications
    
    Partial applications like  @flip (-)@ are eta-expanded to  
    @\a\b -> flip (-) a b@. 
    
    A special case of partial application is when a function is not 
    applied at all - like in @fold (+) 0 xs@.


    ### Lazy values
    
    Lazy values will be instances of @java.run.Lazy@, that is in 
    Java8 notation @() -> some code@. Those are not shared.
    
    Shared lazy values (i.e. in @let@ or arguments for constructors) are 
    @new Thunk(() -> value)@.

    Thunk and Lazy know their return type, i.e. they are generic types.


    ## The Four Reasons for Stack Overflow

    ### Tail Calls

    Tail calls are dangerous, unless the tail called function is _tail call safe_.
    A function is _tail call safe_ if one of the following applies:

    - it is a constructor
    - it is a native function
    - it is not recursive and calls only tail call safe functions
    
    In particular, a function passed as argument is not tail call safe.
    
    If the result of a function that is not tail call safe is a (full)
    application of another function, and this function is itself not 
    tail call safe, or a full application of a non tail call safe function
    appears in a strict position, then a Lazy closure must be returned 
    instead of doing the call directly.
    
    Examples:
    
    > even 0 = true
    > even n = odd (n-a)
    > odd  0 = false
    > odd  n = even (n-1)
    
    Both @even@ and @odd@ are clearly unsafe, hence the code for @even@ 
    should be:
    
    > Lazy<java.lang.Boolean> even(int n) {
    >    if (n==0) then return new Thunk(true);
    >    return new Thunk(() -> even(n-1));
    > }
    
    ### @foldr@ Recursion
    
    > foldr f d [] = d
    > foldr f d (x:xs) = x `f` foldr f d xs
    
    If `f` is strict in its right argument, this leads to recursion as deep
    as the length of the list.
    This could be solved when the currently evaluating thread 
-}

module frege.compiler.passes.GenCode where

import Compiler.types.Global
import Compiler.gen.Common(mainClass)

pass :: StIO (String, Int)
pass = do
    g   ‚Üê getSTT
    liftIO $ g.printer.println "Thank you!"
    return ("Gen78", 1)
