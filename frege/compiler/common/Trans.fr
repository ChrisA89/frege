--- This is an undocumented module.
module frege.compiler.common.Trans where 
        -- generated by Splitter
import  frege.Prelude  hiding(<+>)
import  frege.data.TreeMap  as  TM(TreeMap, TreeSet, lookup, insert, keys, values, each, fromKeys, including, contains, union)
import  frege.compiler.types.Positions
import  frege.compiler.types.Tokens
import  frege.compiler.types.QNames
import  frege.compiler.types.Expression
import  frege.compiler.types.Symbols
import  frege.compiler.types.Global  as  G
import  frege.compiler.Utilities  as  U(allourvars, allvars)
{--
 * how often the symbol with 'Symbol.sid' is referenced in 'Expr' @x@
 -}
references sids x = U.foldEx true refs 0 x
    where
        refs n (Vbl {pos,name}) = do
            -- g <- getST
            -- E.logmsg TRACE7 pos ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice name g)
            sym <- U.findVD name
            if sym.sid `elem` sids then stio (Right (n+1)) else stio (Left n)
        refs n (Ifte c t e _) = do
            crefs <- references sids c
            trefs <- references sids t
            erefs <- references sids e
            stio (Right (n + crefs + max trefs erefs))
        refs n (Case {ex,alts}) = do
            xrefs <- references sids ex
            arefs <- mapSt altRefs alts
            stio (Right (n + xrefs + fold max 0 arefs))
        refs n (Lam {ex}) = do
            lrefs <- references sids ex
            stio (Right (n + lrefs))
        refs n (Let {env,ex}) = do
            syms  <- mapSt U.findV env
            srefs <-sequence [ subex | SymV{expr = Just subex} <- syms ] >>= mapSt (references sids) 
            lrefs <- references sids ex
            stio (Right (n + 2*sum srefs + lrefs))             
        refs n x = do
            -- g <- getST
            -- E.logmsg TRACE7 (getpos x) ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice x g)
            stio (Left n)
        altRefs (CAlt {ex}) = references sids ex


{--
 * [returns] *@true@* if expression is simple. See 'pass9' for more information.
 *
 * A simple expression can be translated to a java expression and will not need
 * blocks, if-then-else constructs, auxiliary declarations etc.
 -}
isSimple :: Global -> Expr -> Bool
isSimple g (App a b _)     = isSimple g a && isSimple g b
isSimple g (Ifte a b c _)  = isSimple g a && isSimple g b && isSimple g c
isSimple g (Ann {ex})      = isSimple g ex
isSimple g (Vbl {pos})     = true
isSimple g (Lit {pos})     = true
isSimple g (Con {pos})     = true
isSimple g (Lam {ex})      = isEasy g ex
isSimple g Mem{ex}         = isSimple g ex
isSimple g _               = false


{--
 * [returns] *@true@* if expression is easy. See 'pass9' for more information.
 *
 * An easy expression can be translated to a series of java statements
 * with a final return, i.e. to a valid method body.
 -}
isEasy :: Global -> Expr -> Bool
isEasy g (App a b _)       = isSimple g a && isSimple g b
isEasy g (Let {env,ex})    = isEasy g ex && all (isEasy g) xprs
    where
        xprs = [ ex | q <- env, sym <- g.findit q, ex <- sym.gExpr g]
isEasy g (Case {ex,alts})   = isSimple g ex && all (isEasy g â€¢ _.ex) alts
    
isEasy g (Ifte a b c _)     = isSimple g a && isEasy g b && isEasy g c
isEasy g (Ann {ex})        = isEasy g ex
isEasy g x                 = isSimple g x


--- @replSid sid r ex@ - replace local variables referncing sid with r in ex
replSid sid r ex = U.mapEx true action ex
    where
        action (v@Vbl {name=Local {}}) = do
            sym <- U.findVD v.name
            if sym.sid == sid then stio (Right r) else stio (Right v)
        action x = stio (Left x)


--- @replName sid nm ex@ - rename variables that references sid in ex
replName sid nm ex = U.mapEx true action ex
    where
        action (v@Vbl {name,pos}) = do
            sym <- U.findVD name
            if sym.sid == sid then do
                changeST Global.{sub <- SubSt.{
                           idKind <- insert (KeyTk pos.first) (Right nm)}}
                stio (Right v.{name=nm}) 
            else stio (Right v)
        action x = stio (Left x)


