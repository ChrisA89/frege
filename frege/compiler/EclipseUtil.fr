{--
    Provide functions for use in the fregIDE
-}


package frege.compiler.EclipseUtil where

import frege.compiler.Data
import frege.compiler.Utilities as U(isPSigma)
import frege.compiler.Import as I
import frege.List (each, values)
import Data.List as DL(sortBy)
import frege.compiler.DocUtils as DU(docit, docSym, DL, Doc, emitHtml)
import frege.lib.PP()
import frege.IO(PrintWriter, StringWriter)


--- create a list from an 'Array' backwards
backwards :: Array a  -> Int -> [a]
backwards array index
    | index > 0 = array.frozenElemAt index : backwards array (pred index)
    | otherwise = []

{--
    This resembles the SourceProposal class.
    The additional information must be lazy!
-}
data Proposal = Proposal {
        proposal :: String      --- The text shown to the user in the popup view
        newText    :: String    --- The new text being added/substituted if the user accepts this proposal
        prefix     :: String    --- The prefix being completed.
        off, len   :: Int       --- The range of text being replaced.
        cursor     :: Int       {-- The offset at which the insertion point should be 
                                    placed after completing using this proposal,
                                    relative to the end of the inserted text. -}
        ?additional:: String    {-- Additional information displayed in the pop-up view 
                                    to the right of the main proposal list view when 
                                    this proposal is selected. -}
    }

{-- 
    Called by Eclipse Content Proposer to make proposals.
    
    Usage: @proposeContent global offset tokens index@
    
    [global] a symbol table, preferably with type information
    [offset] position of the caret
    [tokens] array of tokens
    [index]  index into the array, points to the token that starts before  the caret
    -}
proposeContent :: Global -> Int -> Array Token -> Int -> [Proposal]
proposeContent !global !offset !tokens !index = propose 
    where
        snekot = backwards tokens index
        token  = if null snekot then Token{tokid=LEXERROR, value="", line=1, col=0, offset}
                    else tokens.frozenElemAt index
        inside = token.offset + token.length > offset
        direct = token.offset + token.length == offset                    
        -- pref = if inside then token.value.substring 0 (token.offset-offset) else ""
        nullProposal = Proposal {proposal = "", newText = "", 
            prefix = if inside then substr token.value 0 (offset-token.offset) else "", 
            off    = if inside then token.offset else offset, 
            len    = if inside then offset-token.offset else 0, 
            cursor = 0, additional=""}
        propose 
            | null snekot = [nullProposal.{
                proposal = "module template",
                newText  = "--- This is an undocumented module\nmodule Proposed where\n\nimport Data.List\n",
                cursor   = -33}]
            | otherwise   = envProposal (thisTab global)
        envProposal :: Symtab -> [Proposal]
        envProposal symtab = sortBy (comparing Proposal.proposal) [ nullProposal.{
                                    proposal = sym.name.base,
                                    newText  = sym.name.base,
                                    additional = (fst . (symbolDocumentation sym).run) global} |
                sym::Symbol <- values symtab,
                sym.name.base !~ ´^\(´,
                if length nullProposal.prefix > 0 
                    then sym.name.base.startsWith nullProposal.prefix
                    else true  
            ]
        
{--
    Create a list of triples with  position, namespace and package
    for every import except the automatic ones.
    -}
imports :: Global -> [(Position, String, String)]
imports g = [ (pos, NSName.unNS ns, Pack.un pack) | 
                (ns, pos) <- (sortBy (comparing snd) • each) g.sub.nsPos,
                pos != Position.null,
                pack <- maybe [] (:[]) (g.namespaces.lookup ns) ]

{--
    Create the list of symbols ordered by position
    -}
symbols :: Symtab -> [Symbol]
symbols tab = (sortBy positionAndName • filter wanted • values) tab
    where
        positionAndName a b = case Symbol.pos a <=> Symbol.pos b of
                                    Eq -> comparing (QName.base • Symbol.name) a b
                                    ne -> ne 
        wanted :: Symbol -> Bool 
        wanted sym 
            | sym.{alias?}                       = false
            | Local{} <- sym.name                = true
            -- sym.vis == Private                 = false
            | sym.name.base ~ ´^(chg|upd|has|let|anon|lc)\$´ = false
            | otherwise                          = true

exprSymbols = U.foldEx false collectsyms []
    where
        collectsyms acc Let{env} = do
            syms <- mapSt U.findV env
            stio (Left (acc ++ syms))
        collectsyms acc _        = stio (Left acc)

verbose g t
    | isPSigma t = "?"
    | otherwise    = t.rho.nicer g

{--
    Make a label for a symbol
    -}
label g SymI{clas,typ} = clas.nicer g ++ "  "   ++ verbose g typ
label g SymV{name,typ} = name.base    ++ " :: " ++ verbose g typ 
label g SymD{name,typ} = name.base    ++ " :: " ++ verbose g typ
label g SymC{name,tau} = name.base    ++ " :: " ++ show tau.kind             
label g sym
    | sym.{kind?}      = sym.name.base ++ " :: " ++ show sym.kind
    | otherwise        = sym.name.base 
                    
{--
    Increment the pass number in the state
    -}
passDone = changeST Global.{sub <- SubSt.{nextPass <- (1+)}}    

{--
    Failure tolerant version of 'Global.thisTab' for use in TreeModelBuilder.
    In case of syntax errors, there is no symtab yet, hence Global.thisTab
    is undefined. This, in turn, causes an exception in Eclipse. We can avoid
    this by just pretending the symbol table was empty.
    -}
thisTab :: Global -> Symtab
thisTab g = case g.packages.lookup g.thisPack of
        Just st -> st
        Nothing -> Symtab.Nil

-- a java string writer
-- data StringWriter s = native java.io.StringWriter where
--     native new :: () -> ST s (StringWriter s)
--     native printer new :: StringWriter RealWorld -> IO PrintWriter
--     native flush :: StringWriter RealWorld -> IO ()
--     native toString :: StringWriter RealWorld -> IO String

packDocumentation :: String -> StG String
packDocumentation pack = do
    g <- getST
    r <- I.getFP pack
    case r of
        Right (Just fp) -> case fp.doc of
            ""   -> return ("Undocumented package " ++ pack)
            text -> do 
                let doc = Doc $ docit g (Just text)
                sw <-  doio $  StringWriter.new ()
                p  <-  doio $  StringWriter.printer sw
                changeST Global.{gen <- GenSt.{printer=p}}
                emitHtml false doc      -- html without CSS, eclipse does not understand    
                doio $ g.printer.close
                -- doio $ sw.flush
                result <- doio $ sw.toString
                return result
        Left ex -> return (ex.getMessage)            
        sonst   -> return ("(java class?) " ++ pack)
     
symbolDocumentation :: Symbol -> StG String
symbolDocumentation sym = do
    sw <-  doio $  StringWriter.new ()
    p  <-  doio $  StringWriter.printer sw
    changeST Global.{gen <- GenSt.{printer=p}}
    g <- getST
    let ds = docSym g sym
        dl = DL (Just "func") [ds]
        doc = Doc [dl]
    emitHtml false doc      -- html without CSS, eclipse does not understand    
    doio $ g.printer.close
    -- doio $ sw.flush
    result <- doio $ sw.toString
    return result

{--
    Correct the result of 'frege.compiler.Scanner.dependencies',
    which returns a singleton list with one element @"frege.prelude.PreludeBase"@
    for source files that don't have any import clauses. Yet, unless this is a
    prelude package itself, @"frege.Prelude"@ will be imported.
    
    This discrepancy leads to files not compiling in the FregIDE builder 
    because they are queued before @"frege/Prelude.fr"@
-}    
correctDependenciesFor ["frege.prelude.PreludeBase"] !source
    | source !~ ´/frege/prelude/\w+\.fr$´,
      source !~ ´/frege/Prelude.fr$´      = ["frege.Prelude"]    -- most likely not itself a prelude package
correctDependenciesFor other source       = other


    