{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
 * This package defines most data structures used in the compiler.
 * Anything else is only used locally.
 -}


package frege.compiler.Data
        inline (stio, changeST, putST, getST) 
    where


import Data.TreeMap (Tree, each)
import Java.Net(URLClassLoader)
import Control.monad.State public(State)

import Compiler.enums.Flags as Compilerflags(Flag, Flags)
import Compiler.enums.TokenID(TokenID)
import Compiler.enums.RFlag(RState)

import Compiler.types.Kinds
import Compiler.types.Positions
import Compiler.types.Tokens

import frege.compiler.Classtools    as CT()

import Data.Bits public(BitSet.BitSet, BitSet.member member, 
    BitSet.union bitunion, BitSet.intersection intersection, 
    BitSet.difference difference)

infixr 6 intersection difference
infixr 5 bitunion

-- import outsourced modules
import  frege.compiler.types.Strictness
import  frege.compiler.enums.Visibility
import  frege.compiler.enums.SymState
import  frege.compiler.types.NSNames

--- compiler options
data Options = !Options {
    source :: String   --- our source file
    sourcePath :: [String] --- path names where source files can be found
    flags :: Flags     --- some 'Flag's
    dir::String        --- value of the -d option or "."
    path::[String]     --- value of the -fp option plus classpath depending on WITHCP
    prefix::String     --- value of the -prefix option or ""
    encoding :: Maybe String    --- used for construction of input file
    tRanges :: [(Int, Int)]     --- ranges for trace output
  }


data Severity = HINT | WARNING | ERROR


data Message = !Msg { pos :: Position, level :: Severity, text :: String }


{--
    Informs how tokens like 'VARID', 'CONID' and 'QUALIFIER' have been
    resolved.
    
    [Left ()] this is a namespace name
    [Right _] this is a type name, member name, constructor or (local) variable 
-}
type IdInfo = Either () QName


--- items that are created early and seldom changed later so that copying them all the time is costly
data SubSt = !Sub {
    loader      :: URLClassLoader       --- class loader for access to imported classes
    cache       :: IORef (Tree String CT.FregePackage)
                                        {-- cache of packages where we know the class file is
                                            up to date, used/set in Main.fr and Import.fr -}
    optab       :: Tree String TokenID  --- operator table
    toks        :: JArray Token         --- array of tokens returned from scanner
    idKind      :: Tree KeyToken IdInfo --- information about how id tokens got resolved
    packageDoc  :: Maybe String         --- documentation for this package
    definitions :: [DefinitionS]        --- package definitions
    numErrors   :: Int                  --- number of errors found so far
    resErrors   :: Int                  --- number of variable resolution errors found so far
    messages    :: [Message]            --- list of 'Message's (used when 'IDE' is on, contains messages in reverse order
    nextPass    :: Int                  --- next pass (used in fregIDE only)
    cancelled   :: IO Bool              {-- Tell if processing is cancelled. The eclipse IDE will put a value here that
                                            checks a progress monitor. In batchmode this is of course always false.
                                            We need this because certain passes can take a long time,
                                            but usually do a 'foreach'-loop that could be terminated after
                                            a substep. See 'forsome' -}
    thisPack    :: Pack                 --- the current package
    thisPos     :: Position             --- from *package* ... *where* 
    nsPos       :: Tree NSName Position --- where NS was introduced
    stderr      :: PrintWriter    --- error messages go here, UTF-8 encoded
    toExport    :: [SName]        --- inlineable functions from this package
}


--- items that are set and used during code generation
data GenSt = !Gen {
    printer :: PrintWriter       --- generated java code goes here, UTF-8 encoded
    tunique :: Int                     --- unique numbers for taus
    runique :: Int                     --- unique numbers for rhos
    sunique :: Int                     --- unique numbers for sigmas
    xunique :: Int                     --- unique numbers for exprs
    kunique :: Int                     --- unqiue numbers for kinds
    tTree   :: Tree TauA Int           --- tau table
    rTree   :: Tree RhoA Int           --- rho table
    sTree   :: Tree SigmaA Int         --- sigma table
    xTree   :: Tree ExprA Int          --- expr table
    kTree   :: Tree KindA Int          --- kind table
    consts  :: Tree (Literalkind, String) Int   --- constant table
    lambdas :: Tree Symbol (Maybe JName)        --- table of functions we need a FuncN for
    syminfo :: Tree Symbol SymInfo      --- cached information about symbols return/arg types
    jimport :: Tree String Pack         --- packages we have a java import statement for, by base name
}


--- compiler state, appears like it was global, but threaded through 'StIO' monad
data Global = !Global {
    options  :: Options                  --- compiler options
    sub      :: SubSt                    --- seldom changed items
    gen      :: GenSt                    --- things used in code generation
    unique   :: Int                      --- source for uniq integers
    packages :: Tree Pack Symtab         --- map packages to symbol table
    namespaces  :: Tree NSName Pack      --- map namespaces to packages
    javaEnv :: Tree String ([String],[QName]) --- names of supertypes and types that implement a certain java type
    genEnv  :: [Symbol]                  --- symbols of function that is being compiled
    locals :: Tree Int Symbol            --- local ids identified by name
    typEnv :: [QName]                    --- names of functions being type checked
    tySubst :: Tree Int Tau              --- substitutions for type variables
} where
    --- true if and only if we are generating code for a top level item
    toplevel (g::Global)    = null g.genEnv
    -- make it look like all the items live in Global
    optab (g::Global)       = g.sub.optab
    tRanges (g::Global)     = g.options.tRanges
    sourcePath (g::Global)  = g.options.sourcePath
    packageDoc (g::Global)  = g.sub.packageDoc
    definitions (g::Global) = g.sub.definitions
    cache       (g::Global) = g.sub.cache
    stderr  (g::Global)     = g.sub.stderr
    printer (g::Global)     = g.gen.printer
    tunique (g::Global)     = g.gen.tunique
    runique (g::Global)     = g.gen.runique
    sunique (g::Global)     = g.gen.sunique
    xunique (g::Global)     = g.gen.xunique
    kunique (g::Global)     = g.gen.kunique
    tTree (g::Global)       = g.gen.tTree
    rTree (g::Global)       = g.gen.rTree
    sTree (g::Global)       = g.gen.sTree
    xTree (g::Global)       = g.gen.xTree
    kTree (g::Global)       = g.gen.kTree
    thisPack (g::Global)    = g.sub.thisPack
    resolved :: Global -> Token -> Maybe IdInfo 
    resolved g t = g.sub.idKind.lookup (KeyTk t)
    -- namespaces (g::Global)  = g.sub.namespaces
    errors (g::Global)      = if IDE `member` g.options.flags 
                                then g.sub.numErrors - g.sub.resErrors
                                else g.sub.numErrors
    -- genEnv (g::Global)      = g.genEnv
    thisTab :: Global -> Symtab
    thisTab g = case g.packages.lookup g.thisPack of
        Just st -> st
        Nothing -> if  IDE `member` g.options.flags 
            then  error ("no symtab for package " ++ show (g.thisPack.unpack g))
            else  empty -- be tolerant in the IDE


--- the symbol table
type Symtab = Tree String Symbol


{--
 * A package name can not be read without resort to the global state,
 * because it includes the prefix given on the command line.
 * However, one can compare them, i.e. @p == P "frege.Prelude"@
 -}
abstract data Pack = P String where
    new s = P s
    un (P s) = s
    unpack :: Pack -> Global -> String
    unpack (P s) g = g.options.prefix ++ s
    --- Make a namespace name from a package name by taking the trailing word characters
    --- For always-to-import Prelude packages, the namespace name is derived from 'preludePacks'
    nsName p | [n] <- [ NSX s | (p', Just s) <- preludePacks, p' == p ] = n
    nsName (P (m~#(\w+)$#)) = NSX (unJust (m.group 1))
    nsName (P s) = Prelude.error ("nsName: illegal package name " ++ s.show)
    --- convert to JName
    className p g
        | m~#^((\S+)\.)?(\w+)$# <- unpack p g
        = case (m.group 2, m.group 3) of
            (Just qn, Just base) = JName qn base
            (Nothing, Just base) = JName "" base
            _ -> JName "unbekannte" "Klasse"    -- should not happen
        | otherwise = error ("bad package name " ++ un p)

    nice p g
        -- p == pPrelude   = "Prelude"
        | p == Global.thisPack g = ""
        | otherwise = case filter ((p==) • snd) ((Global.namespaces g).each) of
                ((NSX s, _):_) -> s
                _              -> (nsName p).unNS
    (P a) ==  (P b) = a String.==  b
    (P a) <=> (P b) = a String.<=> b
    hashCode (P a) = String.hashCode a


instance Eq   Pack


instance Ord  Pack


derive   Show Pack


{--
    When a package name consists of more than just a 'CONID' 
    and the first character is an uppercase letter, then this 
    letter is replaced by its lowercase equivalent and the
    string @"frege."@ prepended to form the real package name.
    
    > magicPack "Data.List" = "frege.data.List"
    > magicPack "List"      = "List"  
    -}
magicPack (nm@´\.´)
    | fst.isUpperCase = "frege." ++ fst.toLowerCase.display ++ tail nm
    where 
        fst = String.charAt nm 0
magicPack nm = nm


--- a prominent package
pPrelude = (Pack.new • fromMaybe "frege.Prelude" • System.getProperty) "frege.prelude"


pPreludeBase    = Pack.new "frege.prelude.PreludeBase"


pUtilRegex      = Pack.new "frege.java.util.Regex"


pPreludeText    = Pack.new "frege.prelude.PreludeText"


pPreludeList    = Pack.new "frege.prelude.PreludeList"


pPreludeMonad   = Pack.new "frege.prelude.PreludeMonad"


pPreludeIO      = Pack.new "frege.prelude.PreludeIO"


pPreludeMath    = Pack.new "frege.prelude.Math"


pControlSemi    = Pack.new "frege.control.Semigroupoid"


pPreludeArrays  = Pack.new "frege.prelude.PreludeArrays"


{-- List of Prelude packages and the namespace that needs to be assigned on import time

    These are automatically recognized as Prelude-Packages.

    For each of them, a java import will be generated and
    names from them appear in Class.name form in java code.

    If the package's namespace must be present at compile time,
    the second component of the tuple must be given as 'Just' @name@
-}
preludePacks = (pPreludeBase,  Just "PreludeBase") : map fppack [
                    -- ("Native", Just "PreludeNative"),     -- because of various literals
                    ("List",   Just "PreludeList"),       -- because of list comprehension
                    ("Text",   Just "PreludeText"),       -- because of derive Show
                    ("Monad",  Just "PreludeMonad"),      -- because of derive Show
                    ("IO",     Just "PreludeIO"),         -- because of derive Exceptional
                    ("Arrays", Just "PreludeArrays"),     -- because of derive ArrayElement 
               ] ++ [
                    (pUtilRegex, Just "Regexp"),          -- because of regex litreals & patterns 
               ]
       where
            fppack (s,mb) = (Pack.new ("frege.prelude.Prelude" ++ s), mb)


--- The list of imports that must always be performed, constructed from 'preludePacks'
importAlways = [ ImpDcl {pos=Position.null, pack=Pack.un p, as=Just n, imports = linkNone} |
                    (p, Just n) <- preludePacks ]


{--
    This predicate tells if a certain package is a Prelude package
    (and so does not need a Prelude import)

    Treatment as Prelude package can be forced
    by prepending the *package* keyword with *protected*
-}
inPrelude :: Pack -> Global -> Bool
inPrelude p g = (p `elem` map fst preludePacks)
              || Flags.member INPRELUDE g.options.flags


-- copied over from Utilities, sorry
{--
 * determine 'QName' of type given in an instance definition
 -}
private instTSym (ForAll _ (RhoTau _ tau)) g = instTauSym tau g
private instTSym _ g = Nothing


--- return type symbol for constructor of tau, if any
private instTauSym tau g = case tau of
        TCon {name} -> QName.findit name g
        -- TApp (TApp TCon{name} _) ty | name == TName{pack=pPreludeIO, base="Mutable"} 
        TApp a _    -> instTauSym a g
        _           -> Nothing


--- qualified name
data QName =
        !TName   { pack :: Pack,  base :: String }
        | !VName { pack :: Pack,  base :: String }
        | !MName { tynm :: QName, base :: String }
        | !Local { uid  :: Int,   base :: String }
    where
        getpack (TName p _) = p
        getpack (VName p _) = p
        getpack (MName (TName p _) _) = p
        getpack (MName _ _) = Prelude.error "illegal MName"
        getpack (Local{}) = Pack.new ""

        key (TName _ s)  = "T+" ++ s
        key vmName       = vmName.base

        find :: QName -> Global -> Maybe Symbol
        find (this@Local{uid})  g =  g.locals.lookupI uid {- loop g.env where
            loop []     = Nothing
            loop (e:es) = case Tree.lookupS e k of
                Nothing -> loop es
                just    -> just-}
        find (this@TName p s) g = case g.packages.lookup p of
            Just env -> env.lookupS (key this)
            Nothing  -> Nothing
        find (this@VName p s) g = case g.packages.lookup p of
            Just env -> env.lookupS s
            Nothing  -> Nothing
        find (MName t s) g = findMName t s g where
            findMName t s g = case findit t g of
                Just sy | sy.{env?} = sy.env.lookupS s
                Just (SymA {typ}) = case instTSym typ g of
                    Just sym 
                        | Just r <- find (MName sym.name s) g = Just r
                        | ForAll _ (RhoTau{tau=tau1}) <- typ,       -- look if its 
                          [TCon{name}, _, tau2] <- tau1.flat,       -- type T = Mutable s X
                          name == TName pPreludeIO "Mutable",       -- and look into X
                          Just other <- instTauSym tau2 g = find (MName other.name s) g
                        | otherwise = Nothing  
                    Nothing  -> Nothing
                _ -> Nothing
        --- like 'QName.find', but follow aliases
        findit :: QName -> Global -> Maybe Symbol
        findit t g = case find t g of
            Just sy -> sy.follow g
            Nothing -> Nothing
        istuple s   = QName.base s ~ #^\(,+\)$#
        --- tell if a 'Qname' is from the module we're just compiling
        public our :: QName -> Global -> Bool
        our     (TName p  _) g = p.== (Global.thisPack g)
        our     (VName p  _) g = p.== (Global.thisPack g)
        our     (MName t  _) g = our t g
        our     (Local {})    g = true
        qual    (TName p  _)   = TName p
        qual    (VName p  _)   = VName p
        qual    (MName t  _)   = MName t
        qual    (Local {uid})  = Local uid
        nice    (TName p s)  g
            | inPrelude p g  = s
            | p.== (Global.thisPack g) = s
            | otherwise = p.nice g ++ "." ++ s
        nice    (VName p s)  g
            | inPrelude p g  = s
            | p.== (Global.thisPack g) = s
            | otherwise = p.nice g ++ "." ++ s
        nice    (MName t s)    g = t.nice g ++ "." ++ s
        nice    (Local {uid, base}) g = base ++ "{" ++ show uid ++ "}"
        --- 'nicer' gives a short form of a 'TName' if it can be found locally
        nicer (Local {uid, base}) g = base
        nicer (qn@TName p s) g
            | findit qn g == findit (TName g.thisPack s) g = s
        nicer    (MName t s)    g = t.nicer g ++ "." ++ s
        nicer  qn g = nice qn g
        --- tell if this is the name of a let or lambda bound item
        isLocal (Local{}) = true
        isLocal _         = false


derive Eq   QName


derive Ord  QName


derive Show QName


data JName = !JName {qual :: String, base :: String} where
        show (JName "" x) = x
        show (JName p  x) = p ++ "." ++ x


instance Show JName


instance Eq   JName where
    ja == jb = show ja == show jb
    hashCode ja = hashCode ja.show


{--
    The information stored in the 'Symtab' nodes.
    -}
data Symbol =
        !SymT    {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
                 kind::Kind, typ::Sigma, env::Symtab, nativ::Maybe String,
                 product::Bool, enum::Bool, pur::Bool, newt::Bool, mutable::Bool}  --- data type
        | !SymL  {sid::Int, pos::Position, vis::Visibility, name::QName,
                 alias::QName}                                      --- alias name
        | !SymD  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
                 cid::Int   --- constructor number
                 typ::Sigma, flds::[ConField QName],
                 strsig :: Strictness }                             --- data constructor
        | !SymC  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
                 tau::Tau, supers::[QName], insts::[(QName, QName)],
                 env::Symtab}                         --- class
        | !SymI  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
                 clas::QName, typ::Sigma, env::Symtab}              --- instance
        | !SymV  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
                 typ::Sigma, expr::Maybe Expr, nativ::Maybe String,
                 pur::Bool, anno::Bool, exported::Bool, state::SymState,
                 strsig :: Strictness, depth :: Int, rkind :: RState,
                 throwing :: [Tau]  {-- list of exceptions thrown  -}
                 over :: [QName ]   {-- list of overloaded members -} } --- variable or function
        | !SymA  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
                 kind::Kind, typ::Sigma, vars::[Tau]}                           --- type alias
    where
        follow (ali@SymL {alias}) g = alias.findit g
        follow sym g = Just sym
        category (SymT {name}) g = "data type"
        category (SymD {name}) g = "constructor"
        category (SymC {name}) g = "class"
        category (SymI {name}) g = "instance"
        category (SymV {name,nativ, expr}) g = if isJust nativ then "native " ++ fun else fun
            where fun | MName t b <- name, Just sym <- t.find g
                                          = sym.category g ++ " member " ++ funval
                      | MName _ _ <- name = "member " ++ funval
                      | otherwise         = funval
                  funval | isJust nativ = "function"
                         | Just (Lam {}) <- expr = "function"
                         | otherwise = "value"
        category (SymA {name}) g = "type alias"
        category (SymL {alias}) g = case alias.find g of
            Just sym -> "alias for " ++ sym.category g
            Nothing  -> "alias"
        nice (sym@SymL {alias}) g = category sym g ++ " `" ++ alias.nice g ++ "`"
        nice sym g = category sym g ++ " `" ++ sym.name.nice g ++ "`"
        nicer (sym@SymL {alias}) g = category sym g ++ " `" ++ alias.nicer g ++ "`"
        nicer sym g = category sym g ++ " `" ++ sym.name.nicer g ++ "`"
        --- Symbols are ordered *only* by the @sid@ field, which is a unique number
        sym1 <=> sym2 = (Symbol.sid sym1).<=> (Symbol.sid sym2)
        sym1 == sym2  = (Symbol.sid sym1).==  (Symbol.sid sym2)
        hashCode sym  = (Symbol.sid sym)
        our sy g = (Symbol.name sy).our g


instance Ord Symbol


data ConField s = !Field { pos :: Position,   name, doc :: Maybe String, 
                           vis :: Visibility, strict :: Bool,   typ :: SigmaT s }


{--
 * type to model type variables in type checking
 -}
data MetaTvT s =
          !Flexi {uid::Int, ref :: (IORef (Maybe (TauT s))), hint::String, kind::Kind}
        | !Rigid {uid::Int, hint::String, kind::Kind}
        where
            --- tell if the 'MetaTv' is bound
            bound (Flexi{ref}) = doio (ref.get)
            bound (Rigid{})   = stio Nothing
            --- tell if the 'MetaTv' is flexible
            isFlexi (Flexi{}) = true
            isFlexi _         = false


instance Eq MetaTvT s where
    tv1 == tv2  = tv1.uid.== tv2.uid
    hashCode x = x.uid


instance Ord MetaTvT s where
    Flexi{} <=> Rigid{}   = Lt
    Rigid{} <=> Flexi{}   = Gt
    tv1     <=> tv2       = tv1.uid.<=> tv2.uid


type MetaTv = MetaTvT QName


{--
 * The type for modelling tau-types.
 -}
data TauT s =
      !TApp (TauT s) (TauT s)
    -- !TFun (TauT s) (TauT s)
    -- TAli pos::Position name::s (SigmaT s)
    | !TCon {pos::Position, name::s}
    | !TVar {pos::Position,  kind::Kind, var::String}
    | !Meta (MetaTvT s)
    where
        varkind (TVar{var,kind}) = (var,kind)
        varkind _ = error "varkind only applicable to TVar"
        tfun a b = TApp (TApp (TCon Position.null (TName pPreludeBase "->")) a) b
        getFun (TApp (TApp TCon{name = TName p "->"} a) b) | p == pPreludeBase = Just (a,b)
        getFun _ = Nothing
        isFun    = maybe false (const true) • getFun 
        {--
         * Convert a flat type application to a 'TApp'
         * obeying the law
         > flat (mkapp con ts) == con:ts
         -}
        mkapp a xs = fold TApp a xs
        {-- a nonempty list where the head element is the type constructor and the tail are the args -}
        flat (TApp a b) = flatapp a [b] where
            flatapp (TApp a b) ts = flatapp a (b:ts)
            flatapp t ts          = t:ts
        -- flat (TFun a b) = [TCon 0 (TName pPrelude "->"), a, b]
        flat t = [t]


-- flat form of types, used in "GenMeta"
data TauA = !TauA {kind::Int, tcon::Maybe QName, suba::Int, subb::Int, tvar::String}


data RhoA = !RhoA {rhofun::Bool, cont::[ContextA], sigma::Int, rhotau::Int}


data ContextA = !CtxA {clas::QName, tau::Int}


data SigmaA = !SigmaA {bound::[String], kinds::[Int], rho::Int}


data ExprA = !ExprA {xkind::Int, name::Maybe QName, lkind::Int, varval::Maybe String,
                    alts :: [Int], subx1 :: Int, subx2 :: Int, subx3 :: Int}


data KindA = !KindA {kind, suba, subb :: Int}


derive Eq  TauA


derive Ord TauA


derive Eq  ContextA


derive Ord ContextA


derive Eq  RhoA


derive Ord RhoA


derive Eq  SigmaA


derive Ord SigmaA


derive Eq  ExprA


derive Ord ExprA


derive Eq KindA


derive Ord KindA


nApp a b = App a b Nothing

infixl 16 `App` `nApp`  `TApp`  
infixr 16 `TFun`


--- tau types as created by parser
type TauS = TauT SName


--- tau types use in TC
type Tau = TauT QName


{--
 * The type for modelling sigma types
 -}
data SigmaT s = !ForAll { bound :: [(String, Kind)], rho :: RhoT s } where
    vars (ForAll b _)  = map fst b
    kinds (ForAll b _) = map snd b


--- sigmas as returned from parsing
type SigmaS = SigmaT SName


--- sigmas after translation
type Sigma =  SigmaT QName


{--
 * The type for modelling class assertions
 -}
data ContextT s = Ctx {!pos :: Position, !cname :: s, !tau :: TauT s }


type Context    = ContextT QName


type ContextS   = ContextT SName


{--
    The type for modelling rho types
 -}
data RhoT s =
      !RhoFun {context::[ContextT s], sigma::SigmaT s, rho::RhoT s}
    | !RhoTau {context::[ContextT s], tau::TauT s}


--- rho as returned from parsing
type RhoS = RhoT SName


--- rho as used in typechecker
type Rho  = RhoT QName


--- an unresolved, maybe qualified identifier
data SName = ! Simple { id :: Token } --- syntactically forced to be VARID, CONID or LOP1..NOP16
           | ! With1  { ty :: Token, id :: Token }
           | ! With2  { ns, ty :: Token, id :: Token }


instance Show SName where
    show (Simple t)           = t.value
    show (With1 {ty, id})     = ty.value ++ "." ++ id.value
    show (With2 {ns, ty, id}) = ns.value ++ "." ++ ty.value ++ "." ++ id.value


derive Eq SName


instance Ord SName where
    Simple t1    <=> Simple t2    = t1.value.<=> t2.value
    (s1@With1{}) <=> (s2@With1{}) = (s1.ty.value, s1.id.value).<=> (s2.ty.value, s2.id.value)
    (s1@With2{}) <=> (s2@With2{}) = (s1.ns.value, s1.ty.value, s1.id.value).<=>
                                        (s2.ns.value, s2.ty.value, s2.id.value)
    s1 <=> s2 = (constructor s1).<=> (constructor s2)


prelToken = Token CONID "Prelude" 1 0 0 []


baseToken = Token CONID "PreludeBase" 1 0 0 []


listToken = Token CONID "PreludeList" 1 0 0 []


monadToken = Token CONID "PreludeMonad" 1 0 0 []


listSourceToList = With2 listToken listToken.{value="ListSource"} listToken.{tokid=VARID, value="toList"}


emptyEmpty = With2 listToken listToken.{value="Empty"} listToken.{tokid=VARID, value="empty"}


underlineToken = Token VARID "_" 1 0 0 []


protoSimple = Simple underlineToken


wellKnown :: Token -> String -> SName
wellKnown t s = With1 baseToken t.{tokid=VARID, value=s}


baseFlip t = wellKnown t "flip"


--- simple name that must be known in this context
contextName :: Token -> String -> SName
contextName t s = Simple t.{tokid=VARID, value=s}


qBy :: Token -> SName -> SName
qBy t (Simple con) {- con.tokid == CONID -} = With1 con t
qBy t (With1 ty id){- id.tokid  == CONID -} = With2 ty id t
qBy t  name = error ("Can't qualify " ++ t.value ++ " by " ++ show name)


withNS :: String -> SName -> SName
withNS s (Simple t) = With1 t.{tokid=CONID, value=s} t
withNS s (With1 c t) = With2 c.{tokid=CONID, value=s} c t
withNS s name = error ("Can't set namespace " ++ s ++ " for " ++ show name)


--- The names of the java primitive types 
primitiveTypes = ["byte", "short", "boolean", "char", "int", "long", "float", "double" ]


--- The names of certain classes in @java.lang@
{-- If we have a package imported whose base name is one of this, we better do not
    generate a java import statement for it and use it unqualified.
    -}
javaLangNames = [
    "Appendable", "AutoCloseable", "CharSequence", "Cloneable", "Comparable",
    "Iterable", "Runnable", 
    "Boolean", "Byte", 
    "Character", "Class", "ClassLoader", "ClassValue", "Compiler",
    "Double", "Enum", "Float",
    "InheritableThreadLocal", "Integer",
    "Long", "Math", "Number", "Object",
    "Package", "Process", "ProcessBuilder",
    "Runtime", "RuntimePermission",
    "SecurityManager", "Short", "StackTraceElement", "StrictMath", 
    "String", "StringBuffer", "StringBuilder", "System",
    "Thread", "ThreadGroup", "ThreadLocal", "Throwable",
    "Void"]


type SigExs = (SigmaS, [TauS])


{--
 * definitions
 -}
data DefinitionT =
      ImpDcl    {pos::Position, pack::String, as::Maybe String,
                    imports::ImportList}
    | FixDcl    {pos::Position, opid::TokenID, ops::[String]}
    | DocDcl    {pos::Position, text::String}
    | TypDcl    {pos::Position, vis::Visibility, name::String,
                    vars::[TauS], typ::SigmaS, doc::Maybe String}
    | ClaDcl    {pos::Position, vis::Visibility, name::String,
                    clvar::TauS, supers::[SName],
                    defs::[DefinitionT], doc::Maybe String}
    | InsDcl    {pos::Position, vis::Visibility,
                    clas::SName, typ::SigmaS,
                    defs::[DefinitionT], doc::Maybe String}
    | DrvDcl    {pos::Position, vis::Visibility,
                    clas::SName, typ::SigmaS,
                    doc::Maybe String}
    | AnnDcl    {pos::Position, vis::Visibility, name::String, typ::SigmaS, doc::Maybe String}
    | NatDcl    {pos::Position, vis::Visibility, name::String, txs::[SigExs],
                    meth::String, isPure::Bool, doc::Maybe String}
    | FunDcl    {poss::[Position]            --- because of multiple clauses
                    vis::Visibility, name::String,
                    pats::[PatternS], expr::ExprS,
                    doc::Maybe String}
    | DatDcl    {pos::Position, vis::Visibility, name::String,
                    vars::[TauS], ctrs::[DCon], defs::[DefinitionT],
                    doc::Maybe String}
    | JavDcl    {pos::Position, vis::Visibility, name::String, isPure::Bool, isMutable::Bool,
                    jclas::String, vars::[TauS], defs::[DefinitionT],
                    doc::Maybe String}


type DefinitionS = DefinitionT


type Definition  = DefinitionT


{--
    structure of an import list
--}
data ImportList = Imports {
        publik, except :: Bool,     -- kind of import list
        items :: [ImportItem]
    }


{--
    a single import item
--}
data ImportItem = Item {
        publik :: Bool,             -- re-export this one
        name :: SName,              -- to be resolved in the imported package
        members :: Maybe [ImportItem],    -- members
        alias :: String             -- guaranteed to be unqualified through syntax
    } where
        export :: ImportItem -> ImportItem
        export it = it.{publik = true, members <- fmap (map export)}


--- Prototype for an 'Item'
protoItem = Item { publik = false, name = protoSimple, members = Nothing, alias = "" }


--- 'ImportList' used when none is specified
linkAll  = Imports { publik = false, except = true,  items = [] }


--- 'ImportList' for ()
linkNone = Imports { publik = false, except = false, items = [] }


{--
    Alternatives (constructors) in a data declaration.
    
    Note: every field has its own strictness information, the overall strictness 
    of the data constructor is derived from that.
 -}
data DCon = DCon {pos::Position, vis::Visibility, name::String, -- strict::Bool,
                        flds::[ConField SName], doc::Maybe String}


type DConS = DCon


{--
 * Literals
 -}
data Literalkind =
      LBool
    | LChar
    | LString
    | LInt
    | LBig
    | LLong
    | LFloat
    | LDouble
    | LRegex


derive Enum Literalkind


derive Show Literalkind


{--
    expressions
 -}
data ExprT q =
      Vbl      { pos::Position, name::q, typ::Maybe (SigmaT q) }
    | Con      { pos::Position, name::q, typ::Maybe (SigmaT q) }
    | ConFS    { pos::Position, name::q, fields::[(String, ExprT q)],  typ::Maybe (SigmaT q) }
    | !App     { fun::ExprT q, arg::ExprT q,  typ::Maybe (SigmaT q)}
    | !Lit     { pos::Position, kind::Literalkind, value::String,  typ::Maybe (SigmaT q)}
    | !Let     { env::[QName], defs::[Definition], ex::ExprT q, typ::Maybe (SigmaT q)}
    | !Lam     { pat:: PatternT q,   ex::ExprT q, typ::Maybe (SigmaT q)}
    | !Ifte    { cnd::ExprT q, thn::ExprT q, els::ExprT q, typ::Maybe (SigmaT q)}
    | !Mem     { ex::ExprT q, member::Token, typ::Maybe (SigmaT q)}
    | !Case    { ckind::CKind, ex::ExprT q, alts::[CAltT q], typ::Maybe (SigmaT q)}
    | !Ann     { ex::ExprT q,  typ::Maybe (SigmaT q)}


type Expr  = ExprT QName


type ExprS = ExprT SName


{--
    case alternative 
 -}
data CAltT q = !CAlt {pat::PatternT q, ex::ExprT q}


type CAltS = CAltT SName


type CAlt  = CAltT QName


{--
 * case kind
 -}
data CKind =
      CNormal       --- normal case
    | CWhen         --- case that falls through
    | CNoWarn       --- compiler generated, do not emit warnings


derive Eq CKind


derive Enum CKind


{--
 * patterns
 -}
data PatternT q =
      !PVar    { pos::Position, uid::Int, var::String }                     -- x
    | PCon     { pos::Position, qname::q, pats :: [PatternT q] }            -- Con
    | PConFS   { pos::Position, qname::q, fields::[(String, PatternT q)] }  -- Con { field, ... }
    | !PAt     { pos::Position, uid::Int, var::String, pat::PatternT q}     -- a@pat
    | !PUser   { pat :: PatternT q, lazy :: Bool}                           -- !pat or ?pat
    | !PLit    { pos::Position, kind::Literalkind, value::String}           -- 42 #foo#
    | !PAnn    { pat::PatternT q, typ::SigmaT q}                            -- pat::forall a.Eq a => a -> a
    | !PMat    { pos::Position, uid::Int, var::String, value::String}


-- m~#foo#

type PatternS = PatternT SName


type Pattern  = PatternT QName


{-- Convenience function for injecting an @a@ into ('StG').
    This is just 'StG.return' typed as @a -> State Global a@ -}
stio :: a -> StG a
stio !a = StG.return a


{-- Convenience function for doing IO in a ('StG') action.
    
    The correct way would be of course to use a 'State' monad transformer
    with an inner 'IO' monad, and indeed this was how it was implemented first.
    
    This version is there for better performance.
    -}

doio :: IO a -> StG a
doio act = return (IO.performUnsafe act)


{--
    Convenience function for getting the state.
    This replaces the ugly:
    > (s::Global) <- State.get
-}
getST :: StG Global
getST = State.get


{--
    Convenience function for putting the state back.
    This is just 'State.put' retyped.
    -}
putST :: Global -> StG ()
putST s = State.put s


{--
    Convenience function for changing the state.
    This is just 'State.change' retyped.
    -}
changeST :: (Global -> Global) -> StG ()
changeST f = State.modify f


--- absurd true message aborts the compiler with "message"
absurd :: Bool -> String -> StG ()
absurd c msg = if c then error msg else stio ()


{-- do a 'StG' action for each element of a list -}
foreach :: [a] -> (a -> StG b) -> StG ()
foreach list f = foldr (>>) (stio ()) (map f list)


{-- do a 'StG' action for each element of a list while not cancelled -}
forsome [] f = stio ()
forsome (a:as) f = do
    g <- getST
    b <- doio g.sub.cancelled
    if b then stio () else do
        f a
        forsome as f


{-- map a 'StG' action over each element of a list and return the resulting list in 'StG' -}
mapSt :: (a -> StG b) -> [a] -> StG [b]
mapSt f [] = stio []
mapSt f (a:as) = do
    a <- f a
    as <- mapSt f as
    stio (a:as)


{-- fold with 'StG' action -}
foldSt :: (a -> b -> StG a) -> a -> [b] -> StG a
foldSt f a [] = stio a
foldSt f a (b:bs) = do
        a <- f a b
        foldSt f a bs


-- ------------  position functions ------------------
--- Position of the *package* keyword. If there is none falls back to 'Position.null'
packageStart :: Global -> Position
packageStart g = case filter ((PACKAGE ==) • Token.tokid) g.sub.toks.toList of
    t:_ -> Pos t t
    _   -> Position.null


--- Position of the last character in the file. If there is none falls back to 'Position.null'
packageEnd :: Global -> Position
packageEnd g = case dropWhile ((Int.maxBound.==) • Token.offset) (reverse g.sub.toks.toList) of
    (tok:_) -> positionOf tok.{value=" ", offset = tok.offset + tok.length - 1, col = tok.col + tok.length - 1}
    _       -> Position.null


--- get the tokens that make up this item
tokens :: Position -> Global -> [Token]
tokens pos
    | pos == Position.null = const [pos.first]
    | otherwise = filter wanted
                 • takeWhile ((< e) • Token.offset)
                 • dropWhile ((< s) • Token.offset)
                 • toList
                 • SubSt.toks
                 • Global.sub
         where
            -- wanted :: Token -> Bool
            wanted t
                | id.== COMMENT = false
                | id.== DOCUMENTATION = false
                | otherwise = true
                where id = Token.tokid t
            e = pos.end
            s = pos.start


-- ##################### Code Gen Stuff #################################
{--
    Model of Java types
 -}
data JType =
      --- frege type (extends Algebraic)
      !Ref   { jname :: JName,  typeargs :: [JType] }
    | --- type argument @A@  
      !TArg  { var   :: String }                    
    | {-- 
        Native or array type
        
        An array type looks like
        >  Nativ { type = "[]", typeargs = [elem]}
        where @elem@ is the element type.
        -} 
      !Nativ { typ   :: String, typeargs :: [JType] }  
    | --- lazy type that yields etype
      !Lazy  { yields :: JType }                    
    -- | !Func  { args :: Int, yields :: JType }       {-- function that can take so many
    --                                                     arguments before yielding a result -} 
    | Lambda            --- some function
    | Something         {-- something unknown that can be casted
                            to the desired type -} 
    | Applicable        --- result of apply


{--
    Information needed for generating function calls, etc.
    
    -}
data SymInfo = SI {
        returnJT    :: JType     --- the type delivered by a call to this function
        argJTs      :: [JType]   --- declared argument java types
        argSigs     :: [Sigma]   --- argument sigma types
        retSig      :: Sigma     --- return sigma type
    }


--- avoid writing 'State' 'Global' all the time
type StG = State Global


--- things that need the environment to print nicely
class Nice a where
    nice :: a -> Global -> String
    nicer :: a -> Global -> String
    nicer a g = nice a g


-- default

instance Nice String where
    nice s _ = s


instance Nice QName


instance Nice SName where
    nice s _ = s.show


instance Nice Symbol


