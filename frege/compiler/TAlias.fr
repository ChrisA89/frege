// enable UTF-8 ««««««««««««««•••••••••••••»»»»»»»»»»»»¦¦¦¦¦¦¦¦
/**
 * This is pass 4 of the compiler, implemented in 'pass'.
 * We must make sure that *type* definitions are not self-referential
 * directly or indirectly.
 */
/*
 * $Author: ingo $
 * $Revision: 64 $
 * $Date: 2011-01-06 16:50:41 +0100 (Do, 06 Jan 2011) $
 * $Id: TAlias.fr 64 2011-01-06 15:50:41Z ingo $
 */

package frege.compiler.TAlias where

/// This is $Revision: 64 $
public version = v "$Revision: 64 $" where
    v (m ~ #(\d+)#) | Just g <- m.group 1 = g.atoi
    v _ = 0


import frege.List (joinStr)
import frege.IO(`<<` stdout stderr)

import frege.compiler.Data
import frege.compiler.Utilities() as U
import frege.compiler.Transdef()  as T

/// post condition is true
post = do
    stio true

pass = do
    g <- getST
    let (adefs,other) = partition isTypDcl g.definitions
        adeps = map aliasdep adefs
        agrps = U.tsort adeps
        aflat = [ a | grp <- agrps, a <- grp ]
        sdefs = [ d | a <- aflat, d <- adefs, QName.base a == Definition.name d ]
        isTypDcl (TypDcl {pos}) = true
        isTypDcl _              = false
        aliasdep (TypDcl {pos, name, rho}) = (tn, filter (flip QName.our g) deps) where
                    tn = TName g.thisPack name
                    deps = collectRho rho []
        aliasdep x = error "no TypDcl"
        collectSigma (ForAll _ rho) acc = collectRho rho acc
        collectRho (RhoFun _ sig rho) acc = collectRho rho (collectSigma sig acc)
        collectRho (RhoTau _ tau)     acc = collectTau tau acc
        collectTau (TVar _ _ _) acc = acc
        collectTau (Meta _)   acc = acc
        collectTau (TApp a b) acc = collectTau a (collectTau b acc)
        collectTau (TFun a b) acc = collectTau a (collectTau b acc)
        collectTau (TCon _ n) acc = case U.nstname n g of
            Nothing -> acc
            Just tn
                | tn `elem` acc = acc
                | Just (SymA {name}) <- tn.findit g = if name `elem` acc then acc else name:acc
                | otherwise = acc   // do not complain about unknown type constructors
        getpos tn
            | Just (SymA {pos}) <- QName.findit tn g = pos
            | otherwise = 0
        checkmutual [] = stio ()
        checkmutual [a] = stio ()
        checkmutual (a:as) = U.error (getpos a) ("Mutual recursive type aliases "
                                ++ joinStr ", " (map (flip QName.nice g) (a:as)))
        checkselfref (tn, deps)
            | tn `elem` deps = U.error (getpos tn) ("Self referential type alias `"
                                ++ QName.nice tn g ++ "`")
            | otherwise = stio ()
    changeST Global.{sub <- SubSt.{definitions=reverse other}}     // no more type aliases henceforth
    foreach agrps checkmutual
    foreach adeps checkselfref
    foreach sdefs (T.transdef (VName g.thisPack))
    stio ("type aliases", length adefs)                