{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
 * Simple utility functions for the frege compiler
 -}

package frege.compiler.Utilities
    where

import frege.Prelude except (error, print, println, break, <+>)
import Data.TreeMap (Tree, updatekv, insertkv, lookup, each, insert,
                    union, including, contains, keys, values, fromKeys)
import Data.List as DL(partitioned, sortBy, minimumBy)

import Lib.PP(fill, break, pretty, text, nest, msgdoc, <+>, <>, DOCUMENT)

import Compiler.enums.Flags 
import Compiler.enums.TokenID(TokenID)
import Compiler.enums.RFlag(RState)
import Compiler.enums.Visibility
import Compiler.enums.SymState


import  Compiler.types.Positions
import  Compiler.types.Tokens
import  Compiler.types.Strictness
import  Compiler.types.NSNames
import  Compiler.types.JNames
import  Compiler.types.SNames
import  Compiler.types.Packs
import  Compiler.types.QNames
import  Compiler.types.Types
import  Compiler.types.Patterns
import  Compiler.types.Symbols
import  Compiler.types.Definitions
import  Compiler.types.Global as G

import  Compiler.classes.Nice(Nice)

import  Compiler.common.Mangle
import  Compiler.common.Errors as E()
import  Compiler.common.Resolve as R

import  Compiler.instances.Nicer 

import frege.compiler.Classtools    as CT()

import  frege.compiler.common.SymbolTable

-- import outsourced modules


--- the path separator used here
pathSep = fromMaybe ":"  (System.getProperty "path.separator")


--- a pattern that can be used to 'Regex.split' a 'String' by the path separator
pathRE = case regcomp pathSep.quote of
    Right p -> p
    Left _ -> Prelude.error ("cannot regcomp " ++ pathSep.quote)


--- the class path this JVM started with, as ['String']
classPath = (pathRE.splitted • fromMaybe "." • System.getProperty) "java.class.path"


--- get us the one and only class loader
theClassLoader opt = CT.makeClassLoader (ourPath opt)


--- our complete path
ourPath opt = result where
    flags  = Options.flags opt
    result = if isOn flags WITHCP then classPath ++ (opt.dir : opt.path)
                else (opt.dir : opt.path)


--################### functions operating on the state ##############################
{-- trace output from stateful computation -}
debugST :: Flag -> String -> StG Bool
debugST f s = do
    g <- getST
    return (debug f s g)


{-- trace from anywhere -}
debug :: Flag -> String -> Global -> Bool
debug f s g = if isOn g.options.flags f
    then traceLn (show f ++ ": " ++ s)
    else false


unflatx xs = unflat (reverse xs) where
    unflat [(e,t)] = e
    unflat ((h,t):es) = App (unflat es) h t
    unflat [] = Prelude.error "unflat: cannot happen"


--- Get the variables in a pattern in the form of 'PVar's
--- This does not care about duplicates, but duplicates are forbidden anyway.
patVars :: PatternT a -> [PatternT a]
patVars = loop [] where
    loop acc (p@PVar{})           = p:acc
    loop acc PAt{pos,var,uid,pat} = loop nacc pat where nacc = PVar{pos,var,uid} : acc
    loop acc PMat{uid,pos,var}    = PVar{pos,var,uid} : acc
    loop acc p | p.{pat?}         = loop acc p.pat
    loop acc PCon{pats}           = fold loop acc pats
    loop acc PConFS{fields}       = fold loop acc (map snd fields)
    loop acc _                    = acc


--- Get the variables in a pattern in the form of 'Local's
patNames :: PatternT a -> [QName]
patNames = loop [] where
    loop acc (p@PVar{})           = Local p.uid p.var:acc
    loop acc PAt{pos,var,uid,pat} = loop nacc pat where nacc = Local uid var : acc
    loop acc PMat{uid,pos,var}    = Local uid var : acc
    loop acc p | p.{pat?}         = loop acc p.pat
    loop acc PCon{pats}           = fold loop acc pats
    loop acc PConFS{fields}       = fold loop acc (map snd fields)
    loop acc _                    = acc



--- get the 'Position' of a rho type
rhoPos = Rho.getpos

--- get the 'Position' of a tau type
tauPos = Tau.getpos


{- ########### expression and pattern manipulation ############## -}
--- create a constructor for an n-tuple
tuple n = let
        i = n-1
        commas = repeat ","
        string = "(" ++ fold (++) "" (take i commas) ++ ")"
    in string


tupleName i = With1 baseToken baseToken.{tokid=CONID, value=tuple i}


mkTuple con (pos::Position) [x] = x
mkTuple con pos xs = fold app (con (pos.change CONID (tuple n)) (tupleName n) Nothing) xs
    where !n = length xs
          app a b = App a b Nothing


mkpTuple (pos::Position) [p] = p
mkpTuple pos xs = PCon (pos.change CONID (tuple n)) (tupleName n) xs
    where !n = length xs


{- ######################### symbol handling ######################## -}
{--
 *  determine the name of an instance based on class and type
 -}
insName :: DefinitionS -> String;
insName idcl | idcl.{clas?}, idcl.{typ?} = clas ++ "_" ++ tcon idcl.typ where
    clas = idcl.clas.id.value
    tcon (ForAll _ rho) = rhoTcon rho
    rhoTcon (RhoFun _ _ _)  = "->"
    rhoTcon (RhoTau _ tau)  = tauTcon tau
    -- tauTcon (TCon {name=m~#^PreludeBase\.(\S+)$#}) = unJust (m.group 1)
    tauTcon (TCon {name}) = case name of
        Simple t = t.value
        With1{}
            | name.ty.value == "PreludeBase" = name.id.value
            | otherwise  = name.ty.value ++ "_" ++ name.id.value
        With2{}  = Prelude.error ("insName: should not happen " ++ show name)
    tauTcon (TApp a _)     = tauTcon a
    tauTcon (TVar {var})  = var     -- undefined
    tauTcon (Meta _)      = "meta"  -- undefined
    -- tauTcon (TFun _ _)    = "->"
insName _ = Prelude.error "not an instance"


{-- create a symbolic link to given qname -}
linkq :: QName -> Symbol -> StG ()
linkq from sym = linkqv from sym sym.vis


-- create a symbolic link to a given 'Symbol' with a given 'Visibility'
linkqv :: QName -> Symbol -> Visibility -> StG ()
linkqv from sym vis = do
    g <- getST
    E.logmsg TRACE3 sym.pos (text ("`" ++ from.nice g ++ "` link to " ++ sym.nice g))
    enter (SymL {sid=0, pos=sym.pos, vis, -- doc=Nothing,
                    name=from, alias=sym.name})


-- create a symbolic link to a given 'Symbol' with a given 'Visibility' and 'Position'
linkqvp :: QName -> Symbol -> Visibility -> Position -> StG ()
linkqvp from sym vis pos = do
    g <- getST
    E.logmsg TRACE3 pos (text ("`" ++ from.nice g ++ "` link to " ++ sym.nice g))
    enter (SymL {sid=0, pos=pos, vis, -- doc=Nothing,
                    name=from, alias=sym.name})


--- Associate a java class name with a type
nativeType nativ tname = do
    g <- getST
    case lookup g.javaEnv nativ of
        Just (cs,ls) -> do
            let newl = tname : filter (tname!=) ls
            -- doio $ traceStrLn ("old: " ++ show ls)
            -- doio $ traceStrLn ("new: " ++ show newl)
            changeST Global.{javaEnv <- insertkv nativ (cs;newl) }
        nothing -> do
            -- doio $ traceStrLn ("new: " ++ show [tname])
            changeST Global.{javaEnv <- insertkv nativ ([];[tname])}


--- Associate a java class name with a list of supertypes
nativeSupers nativ classes = do
    g <- getST
    let !strings = map Class.getName classes
    case lookup g.javaEnv nativ of
        Just (_,ls) -> do
            changeST Global.{javaEnv <- insertkv nativ (strings;ls) }
        nothing -> do
            changeST Global.{javaEnv <- insertkv nativ (strings;[])}


--- Find the types that are associated with a native type.
typesOfNativ :: String -> Global -> [QName]
typesOfNativ nativ g = case lookup g.javaEnv nativ of
    Just (_,ls)  -> ls
    nothing -> []


--- Find the proper super types that are associated with a native type.
--- (i.e. the type itself is not in the list)
supersOfNativ :: String -> Global -> [String]
supersOfNativ nativ g = case lookup g.javaEnv nativ of
    Just (cs, _)  -> cs
    nothing -> []


{- ############ find a specific symbol or die ############### -}
findC qname = do
    g <- getST
    case g.findit qname of
        Just (symc@SymC {pos}) -> stio symc
        Just sym -> E.fatal sym.pos (fill (break ("looked for class " ++ qname.nice g ++ ", found "
                                    ++ sym.nice g)))
        Nothing -> E.fatal Position.null (fill (break ("looked for class " ++ qname.nice g ++ ", found Nothing")))


findI qname = do
    g <- getST
    case g.findit qname of
        Just (symc@SymI {pos}) -> stio symc
        Just sym -> E.fatal sym.pos (fill (break ("looked for instance " ++ qname.nice g ++ ", found "
                                    ++ sym.nice g)))
        Nothing -> E.fatal Position.null (fill (break ("looked for instance " ++ qname.nice g ++ ", found Nothing")))


findT qname = do
    g <- getST
    case g.findit qname of
        Just (symc@SymT {pos}) -> stio symc
        Just sym -> E.fatal sym.pos (fill (break("looked for type " ++ qname.nice g ++ ", found "
                                    ++ sym.nice g)))
        Nothing -> E.fatal Position.null (fill (break ("looked for type " ++ qname.nice g ++ ", found Nothing")))


findV qname = do
    g <- getST
    case g.findit qname of
        Just (symc@SymV {pos}) -> stio symc
        Just sym -> E.fatal sym.pos (fill (break ("looked for function " ++ qname.nice g ++ ", found "
                                    ++ sym.nice g)))
        Nothing -> E.fatal Position.null (fill (break ("looked for function " ++ qname.nice g ++ ", found Nothing")))


findVD qname = do
    g <- getST
    case g.findit qname of
        Just (symc@SymV {pos}) -> stio symc
        Just (symc@SymD {pos}) -> stio symc
        Just sym -> E.fatal sym.pos (fill (break ("looked for function or constructor " ++ qname.nice g ++ ", found "
                                    ++ sym.nice g)))
        Nothing -> E.fatal Position.null (fill (break ("looked for function " ++ qname.nice g ++ ", found Nothing")))


findD qname = do
    g <- getST
    case g.findit qname of
        Just (symc@SymD {pos}) -> stio symc
        Just sym -> E.fatal sym.pos (fill (break ("looked for constructor " ++ qname.nice g ++ ", found "
                                    ++ sym.nice g)))
        Nothing -> E.fatal Position.null (fill (break ("looked for constructor " ++ qname.nice g ++ ", found Nothing")))


{-- interpret NS.T or T as type name -}
nstname :: SName -> Global -> Maybe QName
nstname s g = case s of
    Simple t   -> Just (TName g.thisPack t.value)
    With1 ns t -> case g.namespaces.lookup (NSX ns.value) of
        Just p  -> Just (TName p t.value)
        Nothing -> Nothing
    _           -> Nothing


--- return a list of 'TVar's that are unbound in the type
--- the first argument is the list of 'TVar' names bound outside this rho
freeTVars :: [String] -> RhoT a -> [TauT a]
freeTVars bound rho = values (freeRhoTVars bound Tree.empty rho)


--- like freeTVars, but returns only 'TVar'  names
freeTVnames :: [String] -> RhoT a -> [String]
freeTVnames bound rho = keys (freeRhoTVars bound Tree.empty rho)


freeRhoTVars bound collected (RhoFun ctx (ForAll bndleft rho1) rho2) =
    freeRhoTVars (map fst bndleft ++ bound) (freeRhoTVars bound ctxcoll rho2) rho1
        where ctxcoll = freeCtxTVars bound collected ctx
freeRhoTVars bound collected (RhoTau ctx tau) = freeTauTVars bound ctxcoll tau
        where ctxcoll = freeCtxTVars bound collected ctx


--- @freeCtxTVars bnd coll ctxs@
--- add the 'TVar's that occur in the contexts in @ctxs@ and are not elemnt of @bnd@ to 'OrdSet' @coll@
freeCtxTVars bnd coll cs = fold ctxTVars coll cs
    where
        ctxTVars t ctx = freeTauTVars bnd t (Context.tau ctx)


freeTauTVars :: [String] -> Tree String (TauT β) -> TauT β -> Tree String (TauT β)
freeTauTVars bound collected (tv@TVar{var})
    | var `elem` bound = collected
    | otherwise = insert collected var tv
freeTauTVars bound collected (TApp a b)
                = freeTauTVars bound (freeTauTVars bound collected a) b
-- freeTauTVars bound collected (TFun a b)
--                 = freeTauTVars bound (freeTauTVars bound collected a) b
freeTauTVars _ collected _ = collected


--- note: type must not contain bound Metas
substSigma :: Tree String (TauT t) ->  SigmaT t  -> SigmaT t
substSigma t (ForAll bndrs rho) = ForAll bndrs (substRho t' rho)
    where t' = fold Tree.delete t (map fst bndrs)


substRho t (RhoFun ctx sig rho) = let
            ctx' = map (substCtx t) ctx
            sig' = substSigma t sig 
            rho' = substRho t rho 
        in (RhoFun ctx' sig' rho')
substRho t (RhoTau ctx tau)  = RhoTau (map (substCtx t) ctx) (substTau t tau)


substTau t (tau@TCon{})      = tau
substTau t (TApp a b)        = TApp (substTau t a) (substTau t b)

{-
    We use IO.performUnsafe *only* to check if our premise, that no bound
    Meta variable ever occurs in 'substTau'  always holds.
    
    Note that substTau was in the StG monad earlier, and we
    followed bound Meta. On a second thought, it would appear
    to be better to remove that if it wasn't necessary.
    
    Hence we want to make sure that the property introduced
    post factum holds.
-}

-- substTau t (typ@Meta Flexi{ref}) = case IO.performUnsafe (ref.get) of
--         Just t -> t -- Prelude.error ("bound Meta not allowed in substTau")
--         _      -> typ
substTau t (typ@Meta _)      = typ     -- Meta must be unbound

substTau t (typ@TVar {var})  = case Tree.lookupS t var of
        Just tau -> tau
        Nothing  -> typ


substCtx :: Tree String (TauT a) -> ContextT a -> ContextT a        
substCtx t x  = x.{tau <- substTau t}


-- {--
--  * Make sure that the type application is indeed a type.
--  *
--  * If the first arg is @true@, partial applications are allowed.
--  -}
-- checkTApp :: Bool -> [Tau] -> StG Tau
-- checkTApp partial (con:as) = do
--         g <- getST
--         let t = Tau.mkapp con as
--             units   = repeat (TCon {pos=Position.null, name=TName pPreludeBase "()"})  -- for err correction
--         case con of
--             TCon {pos,name} -> case name.findit g of
--                 -- Just (SymT {typ=ForAll bs _}) | null as, null bs = stio con
--                 Just (SymT {typ=ForAll bs _}) -> if length as <= length bs then stio t  -- no kind errors
--                     else if length as < length bs then if !partial then do
--                         error pos (fill
--                             (break "too few arguments for application of type constructor"
--                                 ++ [text (name.nice g) <> text ","]
--                                 ++ break "there must be"
--                                 ++ [lit (length bs)]))
--                         stio (Tau.mkapp t (take (length bs - length as) units))
--                       else do stio t
--                     else do error pos (fill (break "too many arguments for application of type constructor"
--                                     ++ [text (name.nice g) <> text ","]
--                                     ++ break "at most" ++ [lit (length bs)]
--                                     ++ break "are allowed."))
--                             stio (Tau.mkapp con (take (length bs) as))
--                 _ -> fatal (tauPos t) (fill (break "not a type constructor: " ++ [text (name.nice g)]))
--             TVar {pos} -> stio t
--             _ -> fatal (tauPos t) (fill (break "type application of " ++ [text (con.nice g)]))
-- checkTApp _ _ = undefined       -- must only be called with tau.flat
-- {-
-- checkTApp partial (con@TCon {pos,name}) = do
--         g <- getST
--         let units   = repeat (TCon {pos=0, name=TName pPrelude "()"})
--         case name.findit g of
--             Just (SymT {typ=ForAll bs _}) -> if length bs == 0 then stio con
--                     else if !partial && length bs > 0 then do
--                         error pos ("too few arguments for application of type constructor "
--                             ++ name.nice g ++ ", there must be " ++ show (length bs))
--                         stio (Tau.mkapp con (take (length bs) units))
--                     else stio con
--             _ -> fatal (tauPos t) ("not a type constructor: " ++ name.nice g)
-- checkTApp t = do
--     g <- getST
--     fatal (tauPos t) ("not a type application: " ++ t.nice g)
--     -}

--- numbers from 0 on
numbers = iterate (1+) 0


--- return a list of constructors in this environment ordered by constructor number
envConstructors :: Symtab -> [Symbol]
envConstructors env = sortBy (comparing Symbol.cid) [ sy | (sy::Symbol) <- values env, sy.{cid?} ]


--- provide a new Position for a Pattern
pPos newp (p@PCon{}) = do
    pats <- mapSt (pPos newp) p.pats
    return p.{pats}
pPos newp (p@PConFS{}) = do
    let ret (nm, pat) = do p <- pPos newp pat; return (nm, p)
    fields <- mapSt ret p.fields
    return p.{fields}
pPos newp p
    | p.{pat?} = pPos newp p.pat >>= return .  p.{pat=}
    | p.{pos?} = return p.{pos=newp}
    | otherwise = do
        g <- getST
        E.error newp (text ("pPos: strange pattern: " ++ nice p g)) 
        return p


--- provide (a new) uid for a Pattern
pReturn (p@PCon{}) = do
    pats <- mapSt pReturn p.pats
    return p.{pats}
pReturn (p@PConFS{}) = do
    let ret (nm, pat) = do p <- pReturn pat; return (nm, p)
    fields <- mapSt ret p.fields
    return p.{fields}
pReturn (p@PUser{pat}) = do
    pat <- pReturn pat
    return p.{pat}
pReturn (p@PAnn{pat}) = do
    pat <- pReturn pat
    return p.{pat}
pReturn (p@PLit{}) = return p
pReturn (p@PVar{}) = do
    uid <- uniqid
    return p.{uid}
pReturn (p@PMat{}) = do
    uid <- uniqid
    return p.{uid}
pReturn (p@PAt{}) = do
    uid <- uniqid
    pat <- pReturn p.pat
    return p.{pat,uid}


--- the local 'QName' that belongs to this 'Pattern', it must have fields 'Pattern.uid' and 'Pattern.var'.
pVarLocal :: PatternT a -> QName
pVarLocal p  = Local p.uid p.var


{-- @patLocal pos name@ creates a local variable symbol from pos and name -}
patLocal pos uid name = vSym pos (Local uid name)


--- set uid for a local symbol
setuid uid = Symbol.{sid=uid, name <- QName.{uid}}


{--
    Make a new local symbol from  a 'PVar' and enters it in the symbol table.
    Will fail if argument is not a 'PVar'
    -}
mkLocal :: Pattern -> StG Symbol
mkLocal pvar = do
    let sym = patLocal pvar.pos (abs pvar.uid) pvar.var
    enter sym
    stio sym


--- update the local names uids in an expression that match one of the symbols by name
replaceLocals :: [Symbol] -> Expr -> StG (Either Expr Expr)
replaceLocals syms (v@Vbl {name = Local 0 s}) = case DL.find (\sym -> (Symbol.name sym).base == s) syms of
        Just sym -> stio (Right v.{name = sym.name})
        other    -> stio (Right v)
replaceLocals syms x = stio (Left x)


{--
 *  @vSym pos name@ creates a 'SymV' symbol with all fields except 'Symbol.pos'
 *  and 'Symbol.name' set to standard values.
 * If the name is a 'Local' one, the 'Symbol.sid' is set to the 'QName.uid'
 -}
vSym pos name = SymV {pos,
                    sid= if QName.{uid?} name then name.uid else 0,
                    name, vis=Private, doc=Nothing,
                    typ=pSigma, expr=Nothing, nativ=Nothing,
                    pur=false, anno=false, exported=false, 
                    state=Unchecked,
                    strsig = Strictness.U, depth = 0, 
                    rkind = RState.empty,
                    throwing = [], over = [] }


--- check how man lambdas are nested inside each other
lambdaDepth (Lam {ex}) = 1 + lambdaDepth ex
lambdaDepth ex = 0


{--
 * make a rho type from a tau type
 -}
rhoTau tau
    | Just (a,b) <- Tau.getFun tau = RhoFun [] (ForAll [] (rhoTau a)) (rhoTau b)
rhoTau tau        = RhoTau [] tau


{--
 * validSigma - make sure the user provided 'Sigma' is valid:
 * 1) if there are no variables in forall, look up all free variables and provide them
 * 2) if there are variables in forall, make sure there are no free variables in the type
 * 3) make sure the variables in forall actually do appear in the type
 -}
validSigma :: SigmaT a -> StG (SigmaT a)
validSigma (ForAll [] rho) = do
    let vs = freeTVars [] rho
    rho <- validRho (map Tau.var vs) rho
    stio (ForAll  (map Tau.varkind vs)  rho)
validSigma sig = validSigma1 [] sig


validSigma1 outer (ForAll bound rho) = do
    g <- getST
    -- logmsg TRACE5 (rhoPos rho) ("outer: " ++ display outer)
    -- logmsg TRACE5 (rhoPos rho) ((ForAll bound rho).nice g)
    let vs = freeTVnames (map fst bound++outer) rho
        fs = freeTVnames outer rho
        ov = [ v | (v,_) <- bound, v `notElem` fs ]
    -- logmsg TRACE5 (rhoPos rho) ("vs: " ++ display vs)
    -- logmsg TRACE5 (rhoPos rho) ("fs: " ++ display fs)
    -- logmsg TRACE5 (rhoPos rho) ("ov: " ++ display ov)
    unless (null vs)
        (E.error (rhoPos rho) (fill (break ("free type variable(s) " ++ joined ", " vs ++ " not allowed"))))
    unless (null ov)
        (E.error (rhoPos rho) (fill (break ("bound type variable(s) " ++ joined ", " ov
            ++ " not appearing in type"))))
    rho <- validRho (vs ++ map fst bound ++ outer) rho
    stio (ForAll bound rho)


{--
 * check that contexts only contain type variables refernced in rho
 * Since well formed types contain no free type variables,
 * this are exactly the types bound in the outer *forall*s
 *
 * While we are using the version 2 compiler, we must also
 * extract the contexts from the type. For this purpose, we assume
 * sigmas to be of the form @Sigma [] rho@
 -}
-- validRho :: [String] -> RhoT Ord:a -> StG (RhoT a)
validRho bound rho = do
        foreach (Rho.context rho) check
        case rho of
            RhoFun _ sig r -> do
                 sig <- validSigma1 bound sig
                 r   <- validRho    bound r
                 stio rho.{sigma=sig, rho=r}
            _ -> stio rho
    where
        check (Ctx pos qname tau) = do
            let vars = keys (freeTauTVars [] Tree.empty tau)
                bads = filter (`notElem` bound) vars
            unless (null bads) do
                E.error pos (fill (break ("context must not name type variables " ++ joined "," bads)))
            stio ()


{--
 * check a sigma and translate it to 'QName' form.
 -}
transSigma sigma = validSigma sigma >>= transSigma1 []


{--
    check a sigma with outer bound vars
-}
private transSigma1 outer sigma = do
    -- sigma <- validSigma1 outer sigma
    case sigma of 
        ForAll bound rho -> do
                rho <- transRho (outer ++ map fst bound) rho
                let free = freeTVars outer rho
                    constraints rho = case rho of 
                        RhoTau{} -> (rho.context, rho.{context=[]})
                        RhoFun{} -> (rho.context ++ subctx, rho.{context=[], rho=subrho})
                                    where (subctx, subrho) = constraints rho.rho
                    (ctx, rrho) = constraints rho
                    nrho = rrho.{context=ctx} 
                case rho of
                    RhoTau _ _ -> return (ForAll (map Tau.varkind free) nrho)
                    _          -> return (ForAll (map Tau.varkind free) (unTau nrho))


{--
 * transform a string context to q 'QName' context
 -}
transCtx (Ctx pos name tau) = do
        name <- defaultXName pos (TName pPreludeBase "Eq") name
        tau  <- transTau tau >>= forceTau
        stio (Ctx pos name tau)


{--
 * check a rho and translate it to 'QName' form
 -}
transRho :: [String] -> RhoS -> StG Rho
transRho outer (RhoFun ctx sig rho) = do
        sig <- transSigma1 outer sig
        rho <- transRho outer rho
        ctx  <- mapSt transCtx ctx
        stio (RhoFun ctx sig rho)
transRho outer (RhoTau ctx tau) = do
        sig  <- transTau tau
        ctx  <- mapSt transCtx ctx
        stio $ sig.rho.{context <- (++ ctx)}


{--
    check a tau and translate it to 'QName' form
 -}
transTau :: TauT SName -> StG (SigmaT QName)
transTau (TVar{pos,var,kind}) = return (tauAsSigma (TVar {pos,var,kind}))

transTau (t@Meta _) = do    -- Meta must not happen at this time
    g <- getST
    E.fatal (tauPos t) (text("meta type must not occur at this time: " ++ t.nice g))

transTau (con@TCon {pos,name}) = transTApp [con]
transTau (t@TApp _ _) = transTApp t.flat


transTApp (con:as) = do
     case con of
        TCon {pos,name} -> do
            tname <- resolveTName pos name
            g <- getST
            case tname of
                Nothing -> unit
                -- check if this is really a type constructor
                Just tn -> case g.findit tn of
                    Just (SymT {name,typ=ForAll bs _}) -> do
                            let ncon = TCon {pos, name}
                            as <- mapSt transTau as
                            appTauSigmas ncon as
                            -- checkTApp partial (ncon:as)
                    Just (alias@SymA {typ})
                        | ForAll _ (RhoTau _ tau) <- typ,
                          length as >= length alias.vars = do
                                as <- mapSt transTau as  -- partial args allowed in alias
                                tas <- mapSt forceTau as
                                let env = Tree.fromList (zip (map Tau.var alias.vars) tas)
                                    ras = drop (length alias.vars) as
                                let nt = substTau env tau
                                -- make sure errors are flagged on the right position
                                let posnt = case Tau.flat nt of
                                        (tcon:xs) | tcon.{pos?} = Tau.mkapp tcon.{pos} xs
                                        other -> nt
                                appTauSigmas posnt ras
                        | ForAll _ (RhoTau _ tau) <- typ,
                          length as < length alias.vars = do
                                E.error pos (msgdoc ("apply " ++ alias.nice g ++ " to at least "
                                        ++ show (length alias.vars)
                                        ++ " type arguments"))
                                unit
                        {-
                            When we have a function alias, the number of type arguments
                            must match exactly, because the result will be a sigma,
                            and we can't apply remaining arguments to this.
                        -}
                        | length as == length alias.vars = do
                            sargs <- mapSt transTau as
                            targs <- mapSt forceTau sargs
                            let env = Tree.fromList (zip (map Tau.var alias.vars) targs)
                            return (substSigma env alias.typ)
                        | otherwise = do E.error pos (msgdoc("Apply " ++ alias.nice g
                                            ++ " to exactly " ++ show alias.vars.length
                                            ++ " type arguments."))
                                         unit
                    Just sym -> do
                        E.error pos (msgdoc("`" ++ tn.nice g ++ "` is not a type constructor."))
                        unit
                    Nothing -> do
                        E.error pos (msgdoc("Can't find `" ++ tn.nice g ++ "`"))
                        unit
          where unit = return (tauAsSigma (TCon {pos, name=TName pPreludeBase "()"}))
        other -> do
            con <- transTau con >>= forceTau
            as  <- mapSt transTau as
            appTauSigmas con as
transTApp _ = undefined                   -- must only be used with tau.flat


--- wrap a 'Tau' in a 'Sigma'
tauAsSigma t = ForAll [] (unTau (RhoTau [] t))


{--
    Extract a 'Tau' from a 'Sigma' of the form:
    
    > ForAll [] (RhoTau [] t)
    > ForAll [] (RhoFun [] a b) 
-}
sigmaAsTau (ForAll [] (RhoTau [] t)) = Just t
sigmaAsTau (ForAll [] (r@RhoFun{})) | RhoTau [] t <- tauRho r  = Just t
sigmaAsTau _ = Nothing


forceTau sig = case (sigmaAsTau sig) of
    Just t  -> return t
    Nothing -> do
        g <- getST
        E.error sig.getpos (msgdoc ("illegal type  " ++ nicer sig g 
            ++ ", forall types are not allowed here."))
        return TCon{pos=sig.getpos, name=TName pPreludeBase "()"}


{--
    > appTauSigmas tau sigs  
    
    Apply a list of 'Sigma's to a type constructor
    
    This will result in errors whenever one of 'Sigma's is not really a 'Tau'
-}
appTauSigmas tau sigs = foldM appTauSig tau sigs >>= return . tauAsSigma
    where
        appTauSig tau sig = maybe noway (return . TApp tau) (sigmaAsTau sig)
            where 
                noway = do
                    g <- getST
                    E.error tau.pos (msgdoc ("illegal type argument  " ++ nicer sig g 
                        ++ " in type application of  " ++ nicer tau g
                        ++ ", forall types are not allowed here."))
                    return tau


{-- 
    Print a warning or hint regarding a symbol only if the documentation comment
    does not start with "nowarn:"
    -} 
symWarning :: (Position -> DOCUMENT -> StG ()) -> Symbol -> DOCUMENT -> StG ()
symWarning warn sym msg = do
     case sym.doc of
        Just ´^\s*nowarn:´ -> return ()
        other -> warn sym.pos msg


-- dlDistance src dst = at t3 m n
--     where
--         at t i j = case lookup t (i,j) of
--             Nothing -> 0
--             Just n  -> n
--         m = length src
--         n = length dst
--         ins tree (x,y) = insert tree x y
--         t1 = fold ins Nil [ ((i,0), i) | i <- enumFromTo 0 m ]
--         t2 = fold ins t1  [ ((0,j), j) | j <- enumFromTo 0 n ]
--         t3 = loop t2 1 1
--         loop t i j
--             | i <= m, j <= n = loop (insert t (i,j) dijx) i (j+1)
--             | i <  m, j >  n = loop t (i+1) 1
--             | otherwise = t
--             where
--                 du  = at t (i-1) j
--                 dl  = at t i (j-1)
--                 dul = at t (i-1) (j-1)
--                 cost = if src.[i-1] == dst.[j-1] then 0 else 1
--                 dij  = min (dl + 1) (min (du + 1) (dul + cost))
--                 dijx = if i > 1 && j > 1
--                                 && src.[i-1] == dst.[j-2]
--                                 && src.[i-2] == dst.[j-1]
--                     then min dij (at t (i - 2) (j - 2) + cost)
--                     else dij

{- ################# functions introduced through Classes.fr ############## -}
{-- @isSuper x g y@ is true if /x/ is the same as /y/ or any direct superclass /s/ of
    /y/ in environment /g/ @isSuper x g s@ is true

    For example @isSuper Eq g Ord@ will be true.
 -}
isSuper x g y | x == y = true
              | ysym@Just (SymC {supers}) <- Global.findit g y = any (isSuper x g) supers
              | otherwise = false


{- ################## functions introduced through Transform.fr ############ -}
{--
 * fold an 'Expr'
 *
 * @foldEx b f a ex@ passes accumulator /a/ and each subexpression of /ex/
 * (including /ex/ itself, of course) to /f/
 * which either returns 'StIO' ('Left' /na/) or 'StIO' ('Right' /na/) where /na/ is
 * the updated accumulator.

 * In the latter case, the visitor function /f/ alone is responsible for recursion
 * into the subexpression passed to it, 'foldEx' will abstain from recursing in this
 * case. If however, a 'Left' value is returned, 'foldEx' will continue with the
 * subexpressions of the expression just passed.

 * 'foldEx' will make sure that the correct environment is in place when subexpressions
 * are visited.

 * If /b/ is true, 'foldEx' will also traverse the right hand sides of *@let@* definitions.

 * Example: count the number of constructors in an expression, but do
 * not include those on the right hand side of let-definitions

 > conCount a (Con {pos}) = stio (Right (a+1))
 > conCount a _           = stio (Left a)
 > ncons ex = foldEx false conCount 0 ex

 * Example: find out maximal nesting depth

 > nestDepth a _ = do
 >          g <- getST
 >          stio (Left (max a (length g.env)))
 > nestEx ex = do
 >          a <- foldEx true nestDepth 0 ex
 >          g <- getST
 >          stio (a - length g.env)
 -}
foldEx :: Bool -> (a -> Expr -> StG (Either a a)) -> a -> Expr -> StG a
foldEx b f a ex = do
        result <- f a ex
        case result of
            Right a  -> stio a
            Left  a  -> case ex of
                Vbl {pos} = stio a
                Con {pos} = stio a
                Lit {pos} = stio a
                ConFS {fields} = E.fatal (ex.getpos) (text("foldEx: ConFS should this happen?"))
                App g x _ = do
                    a <- foldEx b f a g
                    foldEx b f a x
                Let {env,ex}
                    | b = do
                        syms <- mapSt findV env
                        let xs = [ x | SymV {expr=Just x} <- syms ]
                        a <- foldSt (foldEx b f) a xs
                        foldEx b f a ex
                    | otherwise = foldEx b f a ex
                Lam {ex} = foldEx b f a ex
                Ifte {cnd,thn,els} = do
                    a <- foldEx b f a cnd
                    a <- foldEx b f a thn
                    foldEx b f a els
                Mem {ex} = foldEx b f a ex
                Case {ex,alts} = do
                    a <- foldEx b f a ex
                    foldSt foldAlt a alts
                  where foldAlt a (CAlt {ex}) = foldEx b f a ex
                Ann {ex} = foldEx b f a ex


{--
 * @mapEx b f ex@ applies function /f/ to 'Expr' /ex/ and, depending on the result, to
 * all subexpressions of /ex/ and reconstructs the expressions with the results.
 *
 * if b is true, 'mapEx' descends also in the right hand sides of let definitions.
 *
 * /f/ is a function that returns ('Left' /x/) or ('Right' /x/) in the 'StIO' monad.
 * In the former case, expression /x/ in the 'StIO' monad is the result of 'mapEx'.
 * When /f/ returns a 'Left' value, however, 'mapEx' continues recursively into the
 * returned expression.
 *
 * 'mapEx' makes sure that subexpressions of expressions with environments find the
 * correct list of local environment in the global state.
 -}
mapEx :: Bool -> (Expr -> StG (Either Expr Expr)) -> Expr -> StG Expr
mapEx b f x = do
    xx <- f x
    case xx of
        Right fx -> stio fx
        Left  fx -> case fx of
            Vbl {pos} = stio fx
            Con {pos} = stio fx
            Lit {pos} = stio fx
            ConFS {fields} = E.fatal (getpos fx) (text ("mapEx: ConFS should this happen?"))
            App g x typ = do
                g <- mapEx b f g
                x <- mapEx b f x
                stio (App g x typ)
            Let {env,ex,defs,typ}
                | b = do
                    syms <- mapSt findV env
                    let xs = [ sy | sy@SymV {expr=Just _} <- syms ]
                    foreach xs mapsub
                    ex  <- mapEx b f ex
                    stio (Let {env,ex,defs,typ})
                | otherwise = do
                    ex <- mapEx b f ex
                    stio (Let {env,ex,defs,typ})
                where mapsub (sy@SymV {expr=Just x}) = do
                        x <- mapEx b f x
                        changeSym sy.{expr=Just x}
                      mapsub sy = do
                        g <- getST
                        E.fatal sy.pos (text ("mapEx: strange symbol in let def rhs: "
                                    ++ sy.nice g))
            Lam {pat,ex,typ} = do
                ex <- mapEx b f ex
                stio (Lam {pat,ex,typ})
            Ifte {cnd,thn,els,typ} = do
                cnd <- mapEx b f cnd
                thn <- mapEx b f thn
                els <- mapEx b f els
                stio (Ifte cnd thn els typ)
            Mem {ex,member,typ} = do
                ex <- mapEx b f ex
                stio (Mem {ex,member,typ})
            Case {ckind,ex,alts,typ} = do
                ex <- mapEx b f ex
                alts <- mapSt (mapAlt b f) alts
                stio (Case {ckind,ex,alts,typ})
              where mapAlt b f (CAlt {pat,ex}) = do
                        ex <- mapEx b f ex
                        stio (CAlt {pat,ex})
            Ann {ex,typ} = do
                ex <- mapEx b f ex
                stio (Ann {ex,typ})


--- a variant of 'mapEx' that passes all outer lambdas and invokes 'mapEx' on the body
mapExBody b f (Lam {pat,ex,typ}) = do
        ex <- mapExBody b f ex
        stio (Lam {pat,ex,typ})
mapExBody b f x = mapEx b f x


{-- @localSyms ex@ returns the set of all local uids mentioned in /ex/
 -}
localSyms ex = foldEx true collect Tree.empty ex where
    collect acc (Vbl {name=nm@Local {uid}}) = do
        --sym <- findV nm
        stio (Left (acc `including` uid))
    collect acc _ = stio (Left acc)


--- replace a set of uids
replUids :: Tree Int Int -> Expr -> StG Expr
replUids t = mapEx true rep where
    rep (v@Vbl{name=Local{uid}}) = case t.lookupI uid of
        Just nid -> stio (Right v.{name <- QName.{uid=nid}})
        Nothing  -> stio (Right v)
    rep x = stio (Left x)


{--
    Copy an expression, all patterns will be refreshed and references
    renamed accordingly. The new expression will have the same type as the old one.
    -}
copyExpr :: Maybe Position -> Tree Int Int -> Expr -> StG Expr    
copyExpr mbp t x = mapEx false (copy t) x where
    ins t (k::Int,v) = Tree.insertI t k v
    copy tree (Lam{pat,ex,typ}) = do
        let qnames  = patNames pat
            olduids = map QName.uid qnames
        pat <- pReturn pat
        pat <- maybe (return pat) (flip pPos pat) mbp
        let newuids = map QName.uid (patNames pat)
            ntree   = fold ins tree (zip olduids newuids)
        ex <- copyExpr mbp ntree ex
        mapM_ (copySym mbp ntree) qnames
        stio (Right Lam{pat,ex,typ})
    copy tree (Case ckind x alts typ) = do
        x    <- copyExpr mbp tree x
        alts <- mapSt copyAlt alts
        stio (Right (Case ckind x alts typ))
      where
        copyAlt CAlt{pat,ex} = do
            let qnames  = patNames pat
                olduids = map QName.uid qnames
            pat <- pReturn pat
            pat <- maybe (return pat) (flip pPos pat) mbp
            let newuids = map QName.uid (patNames pat)
                ntree   = fold ins tree (zip olduids newuids)
            ex <- copyExpr mbp ntree ex
            mapM_ (copySym mbp ntree) qnames
            stio CAlt{pat,ex}
    copy tree (Let{env,ex,typ}) = do
        let olduids = map QName.uid env
        newuids <- sequence (map (const uniqid) olduids)
        let ntree = fold ins tree (zip olduids newuids)
        nenv <- mapSt (copySym mbp ntree) env
        ex   <- copyExpr mbp ntree ex
        stio (Right Let{env=nenv,ex,typ,defs=[]})
    copy tree (v@Vbl{name=Local{uid}}) = case tree.lookupI uid of
        Just nid -> stio (Right v.{pos <- flip fromMaybe mbp, name <- QName.{uid=nid}})
        Nothing  -> stio (Right v.{pos <- flip fromMaybe mbp})
    copy _ (x@Ann{}) = stio (Left x)        -- keep annotations!
    copy _ x = stio (Left x)


--- copy a local symbol
copySym mbp tree qname = do
    sym <- findV qname
    case tree.lookupI (Symbol.sid sym) of
        Just nuid ->  do
                mbx <- maybeST sym.expr (copyExpr mbp tree)
                let name = sym.name.{uid=nuid}
                    -- nsig = if sym.anno || isNothing sym.expr then sym.typ else pSigma
                    nsym = sym.{pos <- flip fromMaybe mbp, name, expr = mbx, sid = nuid}
                enter nsym
                stio name
        Nothing -> Prelude.error ("Can't find sid " ++ show sym.sid ++ " for name " ++ show sym.name)


maybeST (Just f) act = do
    f <- act f
    stio (Just f)
maybeST Nothing _ = stio Nothing


{--
    @untypeExpr x@ removes all type information from @x@
    all local symbols bound inside the expression are set back to 'pSigma' and state 'Unchecked'
-}
untypeExpr x = mapEx true unty x
    where
        untySy qn = do
            sym <- findV qn
            changeSym sym.{typ   = if sym.anno then sym.typ else pSigma,
                           state = Unchecked}
        unty (x@Ann{}) = return (Left x)    -- keep type signatures intact
        unty (x@Lam{pat}) = do
            foreach (patNames pat) untySy
            return (Left x.{typ=Nothing})
        unty (x@Case{alts}) = do
            foreach [ q | alt <- alts, q <- patNames (CAlt.pat alt) ] untySy
            return (Left x.{typ=Nothing})
        unty (x@Let{env}) = do
            foreach env untySy
            return (Left x.{typ=Nothing})
        unty x = return (Left x.{typ=Nothing})


{-- @ourGlobalFuns mtree ex@ returns the set of all global symbols mentioned in /ex/
 *
 * /mtree/ is a 'Tree' 'String' ['Symbol'] mapping unqualified member names to
 * potential actual members. This is so that if we see @x.foo@ in some expression
 * we make sure to first type check @T.foo@ forall our /T/ that has a /foo/.
 -}
ourGlobalFuns :: Tree String [Symbol] -> Expr -> StG (Tree Symbol ())
ourGlobalFuns mtree ex = foldEx true collect Tree.empty ex where
    collect acc (Vbl {name})
        | Local {} <- name = stio (Left acc)
        | otherwise = do
            sym <- findVD name
            case sym of
                SymV{} -> stio (Left (acc `including` sym))
                sonst  -> stio (Left acc)
    collect acc (Mem {member})
        | Just list <- Tree.lookupS mtree member.value
                    = stio (Left (fold including acc list))
        | otherwise = stio (Left acc)
    collect acc _ = stio (Left acc)


symVD f g sym = case sym of
    SymV{} -> f sym
    SymD{} -> g sym
    other  -> Prelude.error (sym.name.base ++ " is neither SymV nor SymD")


{--
 * [usage] @fundep expr@
 * [returns] a list of our 'QName's that are directly mentioned in /ex/
 -}
fundep (SymV {name, expr=Just x})  = do
    g <- getST
    deptree <- ourGlobalFuns Tree.empty x
    let dep = [ Symbol.name sy | sy <- keys deptree, g.our sy.name ]
    stio (name, dep)
fundep (SymV {name, expr=Nothing}) = stio (name, [])
fundep other = do
   g <- getST
   E.fatal other.pos (text("fundep: strange symbol: " ++ other.nice g))


--- a, b, ..., z, aa, ab, ac, ...
allBinders = single ++ [ s1++s2 | s1 <- allBinders, s2 <- single ]
    where single = [ctos c | c <- "αβγδεζηθιßκλμνξοπρςστυφχψω" ]   -- 'a' .. 'z' ]


allAsciiBinders = single ++ [ s1++s2 | s1 <- allBinders, s2 <- single ]
    where single = [ctos c | c <- enumFromTo 'a' 'z' ]


--- find all our 'SymV' symbols
allourvars :: Global -> [Symbol]
allourvars g = 
    let collectedenvs = g.thisTab : [ Symbol.env sy | sy <- values g.thisTab, Symbol.{env?} sy ]
    in [ v | env <- collectedenvs, v@SymV {name} <- values env, g.our name]


--- find all 'SymV' symbols, be they ours or not
allvars = do
    g <- getST
    let envEnvs env = env : [Symbol.env sy | sy <- values env, Symbol.{env?} sy]
        packEnvs = values g.packages
        collectedenvs = fold (++) [] (map envEnvs packEnvs)
        collectedvars = [ v | env::Symtab <- collectedenvs, v@SymV {name} <- env.values]
    stio collectedvars


{--
 * find a name of the same shape that is not used yet
 -}
unusedName qn g
    | Nothing <- Global.find g qn  = qn
    | otherwise = head [ m | b <- allBinders, m = qn.qual (qn.base ++ b), isNothing (g.find m)]


{--
 * convenience 'StIO' printing functions
 -}
print x = do
    g <- getSTT
    liftIO $ g.printer.print (display x)
    return ()


println x = do
    g <- getSTT
    liftIO $ g.printer.println (display x)
    return ()


{--
 * [usage] @returnType rho@
 * [returns] the 'Tau' type of the last 'Rho' in a sequence of 'RhoFun' (which is a 'RhoTau')
 * and the list of argument types (which are 'Sigma's)
 *
 * By definition, the length of the list of argument types is the arity of the function,
 * yet the actual number of formal arguments derived from the
 * number of nested lambdas (given in 'Symbol.depth') may be smaller and even 0.
 -}
returnType (RhoFun _ sig rho) =  (tau, sig:sigs) where (tau, sigs) = returnType rho
returnType (RhoTau _ tau)     =  (tau, [])


{--
 * [usage] @returnTypeN n rho@
 * [returns] the 'Rho' type that would be the result of applying @n@ arguments to a function
 * of the type given in @rho@ and the @n@ 'Sigma' types of the arguments.
 * [undefined] if @n@ is greater than the 'arity' of the type. This should never happen after
 * type check and hints at a compiler error.
 -}
returnTypeN 0 !rho = (tauRho rho, [])
returnTypeN n (RhoFun _ sig rho) = (r, sig:sigs) where (r, sigs) = returnTypeN (n-1) rho
returnTypeN n rho = Prelude.error "returnTypeN: too many arguments"


{--
 * make @RhoFun a b@ to @RhoTau (TFun a b)@ if possible
 -}
tauRho (RhoFun ctxs (ForAll [] (RhoTau [] a)) rho2)
    | RhoTau _ b <- tauRho rho2 = RhoTau ctxs (Tau.tfun a b)
tauRho r = r


{--
    make @RhoTau (TFun a b)@ into @RhoFun (RhoTau a) (unTau (RhoTau b))@
 -}
unTau (RhoTau ctx fun)
    | Just (a,b) <- fun.getFun = RhoFun ctx (ForAll [] (RhoTau [] a)) (unTau (RhoTau [] b))
unTau (RhoFun ctx sig rho)     = RhoFun ctx sig                       (unTau rho)
unTau rho = rho


{--
 * tell if a given type is a java type
 -}
isJavaType (TCon {name}) = do
    sym <- findT name
    stio (isJust sym.nativ)
isJavaType (tapp@TApp _ _) = isJavaType (head tapp.flat)
isJavaType (Meta tv) | tv.isFlexi = do
    g <- getST
    let mbt = g.bound tv
    maybe (stio false) isJavaType mbt
isJavaType _ = stio false


{--
 * Arity of a 'Symbol' based on its type
 -}
arity sym = case returnType (Symbol.typ sym).rho of
    (_, xs) -> length xs


-- base32str = "ABCDEFGHIJKLMNOPQRSTUVWXYZÄÖÜËÏŸ".toLowerCase
-- a32 = length base32str    -- 32
-- 
-- 
-- base32 num
--     | num < 1 = "ß"
--     | otherwise = repljavakws (packed (code [] num))
--     where
--         code !xs 0 = xs
--         code !xs n = code (c:xs) r
--             where
--                 !c = base32str.charAt (n `band` 31)
--                 r = n `bshr` 5


{--
 * [usage] @javaName g qname@
 * [return] a java identifier for the corresponding java object, if there is one
 * [requires] the named item must be in scope
 -}
javaName :: Global -> QName -> JName
javaName g (Local uid s) = JName "" (mangled s ++ "_" ++ show uid)

javaName g qname = case g.findit qname of
        Just sym -> case sym of
            SymT {name} -> t "T" name
            SymD {name = MName tname base} -> case g.findit tname of
                Just (SymT {product,enum}) -> if enum
                    then memberOf (t "T" tname) (mangled base)
                    else if product
                        then t "T" tname
                        else memberOf (t "T" tname) ("D" ++ mangled base)
                fail -> Prelude.error "javaName: tname is no SymT"
            SymC {name} -> t "C" name
            SymI {name} -> t "I" name
            SymV {name = MName tname base} = case g.findit tname of
                    Just (SymT {product=false,enum=false,newt=false,nativ=Nothing}) 
                                      = memberOf (memberOf tjname "M") mbase
                    Just (SymC {sid}) = memberOf (memberOf tjname "I") mbase
                    otherwise         = memberOf tjname mbase
                where tjname = javaName g tname
                      mbase  = mangled sym.name.base
            SymV {name = VName pname base}
                | pname == g.thisPack   = JName jpack.base vbase
                | hasJavaImport pname g = JName jpack.base vbase
                | otherwise = memberOf jpack vbase
                where 
                    vbase = mangled sym.name.base
                    jpack = g.packClass pname
            other -> Prelude.error ("javaName: strange symbol " ++ nice sym g)
        Nothing -> Prelude.error ("javaName: cannot findit " ++ nice qname g)
    where
        -- vid name = mangled name
        t letter (TName pack base)
            | pack == g.thisPack   = JName    ""                   (letter ++ mangled base)
            | hasJavaImport pack g = JName    (g.packClass pack).base (letter ++ mangled base)
            | otherwise            = memberOf (g.packClass pack)   (letter ++ mangled base)
        t _ _ = Prelude.error "t: need a TName"


{-- By convention, if the classname base of some package is unique among
    all known packages, an import statement will be generated so that we can
    use the package base name unqualified.
    
    This is to avoid even more clutter in java code.
    -}
hasJavaImport :: Pack -> Global -> Bool    
hasJavaImport p g = case g.gen.jimport.lookup ((g.packClass p).base) of
    Just imported -> imported == p
    otherwise     -> false


isList (TApp (TCon {name = TName p "[]"}) ty) | p == pPreludeBase = Just ty
isList _                                                          = Nothing


isUnit (ty@TCon {name = TName p "()"}) | p == pPreludeBase = Just ty
isUnit _                                               = Nothing


isMaybe (TApp (TCon {name = TName p "Maybe"}) ty) | p == pPreludeBase = Just ty
isMaybe _ = Nothing


{-- 
    @isException g tau@ returns 'Just' (_left_, _right_) if and only if the following
    conditions both hold:
    - _tau_ is of the form 'Either' _left_ _right_
    - _left_ is ('isThrowable' g _left_) or ('isException' g _left_) is not 'Nothing'    
-}  
isException g (TApp (TApp con ex) ty) 
    | isEither con, isEx ex = Just (ex, ty)
    where
        isEither  TCon {name = TName p1 "Either"} = p1 == pPreludeBase
        isEither  _                               = false 
        isEx (TApp (TApp con a) b) = isEither con && isEx a && isThrowable g b
        isEx x = isThrowable g x 
isException g _ = Nothing


{-- 
    @true@ if and only if in environment _g_, 
    type _t_ denotes a sub type of @java.lang.Throwable@ 
-}
isThrowable g ty = case instTauSym ty g of
        Just SymT{nativ=Just x} -> x == "java.lang.Throwable" 
                                     || "java.lang.Throwable" `elem` supersOfNativ x g
        other -> false


isIO (TApp (TApp (TCon {name = TName p "ST"}) st ) ty)
    | p == pPreludeBase = Just (st, ty)
isIO _ = Nothing


{--
    > isClassMember sym = Just SymC{}
    If  @sym@ is a class member, return the class it belongs to,
    otherwise 'Nothing'. 
-}
isClassMember SymV{name} g
    | MName{tynm} <- name,
      found <- Global.findit g tynm,
      Just SymC{} <- found = found 
isClassMember _ _ = Nothing


-- sigma manipulation stuff
{--
 * Unify 2 Sigmas
 *
 * The first one is a quantified type from some symbol table item.
 * The second one is the actual type of some expression and must be an instance
 * of the first one.
 *
 * > unifySigma (forall a b. Maybe a -> [b]) (Maybe Int -> [Float]) ==> [(a,Int), (b, Float)]
 -}
unifySigma g (ForAll [] _) _ = Tree.empty
unifySigma g s1 (ForAll _ rho) = unifyRho g Tree.empty s1.rho rho


unifyRho :: Global -> Tree String Tau -> Rho -> Rho -> Tree String Tau
unifyRho g t (rho1@RhoFun{}) rho2
    | RhoFun{}      <- rho2       = result
    | rfun@RhoFun{} <- unTau rho2 = unifyRho g t rho1 rfun
    | otherwise                   = t           -- no match
    where
        result = unifyRho g t2 rho1.rho rho2.rho
        t2     = unifyRho g t  rho1.sigma.rho rho2.sigma.rho
-- rho1 must be a RhoTau as the first clause catches all cases where it is a RhoFun
unifyRho g t rho1 rho2
    | RhoTau{}      <- rho2        = unifyTau   t  rho1.tau   rho2.tau
    | rtau@RhoTau{} <- tauRho rho2 = unifyRho g t  rho1       rtau
unifyRho g t _ _ = t


-- unifyTau :: Tree String (TauT δ) -> TauT α -> TauT δ -> Tree String (TauT δ)
unifyTau t (TVar {var}) b = insert t var b
unifyTau t (tau1@TApp a b) (tau2@TApp c d) = unifyApp a c
    where
        -- do not match unequals!
        unifyApp TVar{} _ 
            = unifyTau  (unifyTau  t a c) b d
        unifyApp TCon{name=n1} TCon{name=n2}
            | n1 == n2 = unifyTau  (unifyTau  t a c) b d
            | otherwise = t
        unifyApp (TApp x _) (TApp y _) = unifyApp x y
        unifyApp _ _ = t
unifyTau t _ _ = t


{--
 * [usage] @sigmaInst sigma1 sigma2@
 * [returns] a list of 'Tau' types that are substituted for
 * the bounded variables of @sigma1@ in @sigma2@
 * which must be a valid substitution of the former (up to contexts).
 -}
sigmaInst g sigma1 sigma2 = [ s | Just s <-  map (Tree.lookupS tree) (Sigma.vars sigma1) ]
    where tree =  unifySigma g sigma1 sigma2


{--
 * @tauToCtx pos tau@ tries to convert a tau to a context list.
 * @tau@ could be a tuple, in that case the list is made up of 'Ctx's
 * made from the subtypes in the local function tauCtx.
 *
 * If @tau@ is not a tuple, it is handed down to tauCtx.
 * A valid context is a tyname applied to a type variable or an application of type variables.
 -}
tauToCtx :: TauS -> StG [ContextS]
tauToCtx tau
    | TApp _ _ <- tau = case tau.flat of
        (TCon {name = With1{ty, id}} : subtaus)
          | ty.value==baseToken.value, id.value ~ ´^\(,+\)$´ = do
            ctxss <- mapSt tauCtx subtaus
            let ctxs = [ ctx | ctxs <- ctxss, ctx <- ctxs ]
            stio ctxs
        _ -> tauCtx tau
    | otherwise = bad tau
    where
        bad tau = do
            g <- getST
            E.error (getpos tau) (msgdoc ("expected class context, found " ++ nice tau g))
            E.hint  (getpos tau) (msgdoc ("A class context is of the form  C t  where C is a class name "
                    ++ " and t is a type variable or a type application involving only "
                    ++ "type variables."))
            stio []
        tauCtx (TApp (TCon {pos=tpos, name}) tvapp)
            | isTvApp tvapp = do
                let pos = tpos.merge (getpos tvapp)
                stio [Ctx {pos, cname=name, tau = tvapp}]
        tauCtx tau = bad tau


