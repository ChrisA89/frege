// enable UTF-8 ««««««««««««««•••••••••••••»»»»»»»»»»»»¦¦¦¦¦¦¦¦
/**
 * Java code generation for the frege compiler
 */
/*
 * $Author$
 * $Revision$
 * $Date$
 * $Id$
 *
 */

package frege.compiler.GenJava where

/// This is $Revision$
public version = v "$Revision$" where
    v (m ~ #(\d+)#) | Just g <- m.group 1 = g.atoi
    v _ = 0


import frege.List (joinStr Tree values keys each insert lookup)

import frege.compiler.Data                                  except(version) D
import frege.compiler.Utilities(flag isOn setFlag)          U
import frege.compiler.GenMeta(pp Anno)                      GM
import frege.lib.PP(`<>` `<+>` `</>` `<+/>` `<~/>` text bracket)    PP
import frege.compiler.Transform(patternStrictness)          T
import frege.compiler.TCUtil(sameTau)                       TC
import frege.compiler.Typecheck(mainSigma)                  TY

infixr 6 `<>`

/**
 * Java Attributes like *@final@*, *@static@* etc.
 */
data JAttr = JUnchecked | JFinal | JPrivate | JPublic | JProtected | JStatic
derive Enum JAttr

data RMode = RNative | RBoxed | RLazy
derive Eq   RMode
derive Ord  RMode
derive Show RMode
rmode n = case n `band` 7 of
    0 -> RLazy
    1 -> RBoxed
    2 -> RLazy
    4 -> RBoxed
    5 -> RBoxed
    6 -> RNative
    7 -> RNative


instance Anno JAttr where
    anno JUnchecked = text "@SuppressWarnings(\"unchecked\")"
    anno JFinal     = text "final"
    anno JPrivate   = text "private"
    anno JPublic    = text "public"
    anno JProtected = text "protected"
    anno JStatic    = text "static"

/** construct an integer that holds the attributes */
attrs = fold setFlag 0
attrFinal = attrs [JFinal]
annoAttrs flags = PP.spread [ anno a | a <- JUnchecked .. JStatic, isOn flags a ]
annoGenerics [] = PP.nil
annoGenerics [x] = text "<" <> anno x <> text ">"
annoGenerics xs = bracket "<" (PP.sep "," (map anno xs)) ">"
annoImplements _ [] = PP.nil
annoImplements s xs = text s <+> PP.sep "," (map anno xs)
annoArg (0, _, jt, s) = JType.anno jt <+> text s
annoArg (n, _, jt, s) = annoAttrs n <+> JType.anno jt <+> text s
annoArgDef  []   = text "()"
annoArgDef  args = bracket "(" (PP.sep "," (map annoArg args)) ")"
annoArgList []   = text "()"
//annoArgList [a]  = text "(" <> anno a <> text ")"
annoArgList args = bracket "(" (PP.sep "," (map anno args)) ")"

/**
 * Java Declarations
 */
data JDecl =
      JComment String
    | JClass {attr::Int, jtype :: JType,
                extend :: Maybe JType, implement :: [JType], defs :: [JDecl] }
    | JInterface {attr::Int, jtype :: JType,
                implement :: [JType], defs :: [JDecl] }
    | JTCInterface {attr::Int, jtype :: JType,
                implement :: [JType], defs :: [JDecl] }
    | JMethod {attr::Int, gargs :: [JType], jtype:: JType, name :: String,
               args::[(Int, Sigma, JType, String)], body:: JStmt}
    | JConstr {attr::Int, jtype::JType, args::[(Int, Sigma, JType, String)], body:: JStmt}
    | JMember {attr::Int, jtype::JType, name::String, init::Maybe JExpr}

instance Anno JDecl where
    anno (JComment s)       = text "// " <> text s // <> PP.line
    anno (cl@JClass {attr}) = annoAttrs attr <+> text "class"
                        <+> JType.anno (defining cl.jtype)
                        <+> bracket ""
                             (maybe PP.nil ((text "extends" <+>) • JType.anno) cl.extend
                             <+> annoImplements "implements" cl.implement) ""
                        <+> PP.block "{" (PP.stack (map anno cl.defs)) "}"
    anno (cl@JInterface {attr}) = annoAttrs attr <+> text "interface"
                        <+> JType.anno (defining cl.jtype)
                        <+> bracket "" (annoImplements "extends" cl.implement) ""
                        <+> PP.block "{" (PP.stack (map anno cl.defs)) "}"
    anno (cl@JTCInterface {attr}) = annoAttrs attr <+> text "interface"
                        <+> JType.anno (definingTC cl.jtype)
                        <+> bracket "" (annoImplements "extends" cl.implement) ""
                        <+> PP.block "{" (PP.stack (map anno cl.defs)) "}"
    anno (m@JMethod {attr}) = annoAttrs m.attr
                        <+> annoGenerics (map introduce m.gargs)
                        <+> m.jtype.anno
                        <+> text m.name
                        <> annoArgDef m.args
                        <+> m.body.anno
    anno (m@JConstr {attr}) = annoAttrs m.attr
                        <+> (defining m.jtype).{targs = []}.anno
                        <> annoArgDef m.args
                        <+> m.body.anno
    anno (m@JMember {attr}) = annoAttrs m.attr
                        <+> m.jtype.anno <+> text m.name
                        <+> bracket (maybe "" (const ("= ")) m.init)
                                        (maybe PP.nil (JExpr.anno) m.init)
                                    ";"

/**
 * A java statement
 */
data JStmt =
    JError String           /// code that makes javac fail (generated by incomplete code generation)
    | JEmpty                /// empty statement
    | JBlock [JStmt]        /// { statements }
    | JReturn JExpr         /// return expr
    | JThrow  JExpr         /// throw expr
    | JAssert JExpr         /// assert expr
    | JEx     JExpr
    | JAssign JExpr JExpr   /// a = b
    | JLocal  {decl::JDecl}
    | JCond   {keyword :: String, jex :: JExpr, stmts :: [JStmt]}   /// if/while (cond) { ... }
    | JBlockX {keyword :: String, stmts :: [JStmt]}      /// try/else/catch ... { .... }



instance Anno JStmt where
    anno (JError s) = (JComment s).anno </> text "FIX: incomplete code generation;"
    anno JEmpty = text ";"
    anno (JBlock []) = text "{}"
    anno (JBlock stmts) = PP.block "{" (PP.stack (map anno stmts)) "}"
    anno (JReturn ex) = text "return" <+> PP.nest 4 (ex.anno <> text ";")
    anno (JThrow ex)  = text "throw" <+> PP.nest 4 (ex.anno <> text ";")
    anno (JAssert ex)  = text "assert" <+> PP.nest 4 (ex.anno <> text ";")
    anno (JEx ex) = ex.anno <> text ";"
    anno (JAssign x1 x2) = x1.anno <+> text "=" <+> x2.anno <> text ";"
    anno (JLocal jdecl) = jdecl.anno
    anno (JCond k x stmts) = text k <+> bracket "(" x.anno ")"
                        <+>  anno  (JBlock stmts)
    anno (JBlockX k stmts) = text k <+> anno (JBlock stmts)

/**
 * A java expression
 */
data JExpr =
    JAtom {name :: String}              /// local variable, null, this, true, false, literal etc.
    | JNew JType [JExpr]                /// @new Foo(...)@
    | JNewClass JType [JExpr] [JDecl]   /// @new Foo(...) {...}@
    | JNewArray JType JExpr             /// @new Foo[...]
    | JInvoke JExpr [JExpr]             /// @foo(...)@
    | JCast JType JExpr                 /// (T)(x)
    | JStMem {jname :: JName, targs :: [JType]}         /// @X.<a,b,c>name@
    | JExMem {jex :: JExpr, name :: String}             /// obj.m
    | JExMemG {jex :: JExpr, name :: String, targs :: [JType]}
    | JUnop { op :: String, jex :: JExpr }              /// @!x@
    | JBin {j1 :: JExpr, op::String, j2 :: JExpr}       /// @a + b@
    | JQC {j1 :: JExpr, j2 :: JExpr, j3 :: JExpr}       /// a ? b : c


junop = constructor (JUnop "!" (JAtom "null"))

paren :: JExpr -> PP.DOCUMENT
paren j | constructor j >= junop = text "(" <> anno j <> text ")"
        | otherwise = anno j

instance Anno JExpr where
    anno (JAtom {name}) = text name
    anno (JNew jt exs) = text "new" <+> jt.anno <> annoArgList exs
    anno (JNewClass jt exs decls) = text "new"
                            <+> jt.anno
                            <>  annoArgList exs
                            <+> (PP.block "{" (PP.stack (map JDecl.anno decls)) "}")
    anno (JNewArray jt ex) = text "new"
                            <+> jt.anno
                            <>  text "[" <> anno ex <> text "]"
    anno (JInvoke (JStMem (JName a b) gs) exs) = text a <~/> PP.nest 4 (
                                    text "." <> annoGenerics gs <> text b <> annoArgList exs)
    anno (JInvoke (JExMem jex s) exs) = paren jex <~/> PP.nest 4 (
                                    text "." <> text s <> annoArgList exs)
    anno (JInvoke (JExMemG jex s gs) exs) = paren jex <~/> PP.nest 4 (
                                    text "." <> annoGenerics gs <> text s <> annoArgList exs)
    anno (JInvoke x exs) = anno x <> annoArgList exs
    anno (JCast jt x) = text "(" <> jt.anno <> text ")(" <> anno x <> text ")"
    anno (JStMem (JName a b) gs) = text a <> text "." <> annoGenerics gs <> text b
    anno (JExMemG jex s gs) = paren jex <> text "." <> annoGenerics gs <> text s
    anno (JExMem jex s) = paren jex <> text "." <> text s
    anno (un@JUnop op j1) = text op <+> paren j1
    anno (bin@JBin j1 op j2) = paren j1 <+> text op <+> paren j2
    anno (jqc@JQC j1 j2 j3) = paren j1
                        <+> PP.nest 4    (text "?" <+> paren j2
                                    <+/> (text ":" <+> paren j3))

/**
 * Check if a 'JExpr' is cheap enough so that we can save a local variable
 *
 * Cheap java expressions are:
 * 1. a local variable
 * 2. literal, this, null etc.
 * 3. a cast of a cheap expression
 * 4. a static variable X.m
 * 5. access to a member of a cheap expression.
 *
 * This is transitive, so that X.y.z.a.b.c.d.e.f would be "cheap", but we will not
 * see this because member variables of frege types are all lazy, i.e., there will
 * be an _e() needed to go deeper. But _e() is of course not cheap.
 */
cheap (JAtom _) = true
cheap (JCast _ ex) = cheap ex
cheap (JStMem _ _) = true
cheap (JExMem ex _) = cheap ex
cheap _ = false

/**
 * a Java type
 */
data JType =
      Ref   { jname :: JName,  targs :: [JType] }
    | TArg  { var   :: String }
    | TVbl  { var   :: String }
    | Nativ { typ   :: String, targs :: [JType] }
    | Arr   { etype :: JType }


/// changes 'JName' of a 'Ref' so that it is suitable for the place where it is defined
defining (t@Ref {jname}) = t.{jname <- JName.{qual=""}, targs <- map introduce}
defining x = x
/// like defining, but suitable for type classes, TArgs will not extend Lazy
definingTC (t@Ref {jname}) = t.{jname <- JName.{qual=""}}
definingTC x = x

introduce (TArg s) = TVbl s
introduce t = t

/// the type constructor for 'Void'
voidTau = TCon {pos=0, name = TName pPrelude "Void"}
voidJT  = Ref (JName "" "Boxed") [Nativ "Void" []]

instance Anno JType where
    anno (Ref  {jname,targs}) = text (show jname) <> annoGenerics targs
    anno (TArg var          ) = text var
    anno (TVbl var          ) = text var <+> text "extends" <+> anno (lazy (TArg var))
    anno (Nativ {typ,targs} ) = text typ  <> annoGenerics targs
    anno (Arr  {etype}      ) = anno etype <> text "[]"

sigmaJT (ForAll _ rho)        = rhoJT rho
subSigmaJT (ForAll [] rho)    = rhoJT rho
subSigmaJT (ForAll bound rho) = do
    let tree = Tree.fromList (zip bound (repeat voidTau))
    rho <- U.substRho tree rho
    rhoJT rho
rhoJT  (fun@RhoFun _ _ _) = do
        staus <- mapSt subSigmaJT sigs
        rtau  <- tauJT tau
        stio (Ref (JName "" funN) (staus ++ [rtau]))
    where
        (tau, sigs) = U.returnType fun
        funN = "Fun" ++ show (length sigs)
rhoJT  (RhoTau {tau}) = tauJT tau

tauJT :: Tau -> StG JType
tauJT (fun@TFun a b) = do
    a <- tauJT a
    b <- tauJT b
    stio (Ref (JName "" "Fun") [a,b])

tauJT (app@TApp a b) = case app.flat of
    (tcon@TCon {pos}):rest -> do
        taux  <- tauJT tcon
        tauxs <- mapSt tauJT rest
        symt  <- U.findT tcon.name
        // vjt   <- voidJT
        let arity   = length symt.typ.bound
            restjts = take arity (tauxs ++ repeat voidJT)
        case taux of
            ref@Ref (JName "" "Boxed") [nat@Nativ _ _] -> do
                let targs = if symt.pur then restjts else take (arity-1) restjts
                stio ref.{targs=[nat.{targs}]}
            ref@Ref {targs} -> stio ref.{targs = restjts}
            nat@Nativ _ _   -> stio nat
            _ -> do
                g <- getST
                U.fatal (U.tauPos app) ("tauJT: " ++ nicer app g)
    other -> tauJT a /*do
        a <- tauJT a
        b <- tauJT b
        stio (Ref (JName "" "TyApp") [a,b]) */
        // voidJT
tauJT  (app@TCon {name}) = do
    g <- getST
    sym <- U.findT name
    // vjt <- voidJT
    case sym of
        SymT {product,nativ,enum,pur}
            | Just s <- nativ = stio (boxed (Nativ s args))
            | enum            = stio (Ref (JName "" "Boxed.Int") [])
            | otherwise       = stio (Ref {jname = U.javaName g name, targs = args})
            where args
                    | Just _  <- nativ,
                      not pur,
                      not (null sym.typ.bound) = take  (length sym.typ.bound - 1) (repeat voidJT)
                    | otherwise = take (length sym.typ.bound) (repeat voidJT)
        other -> undefined   // can not happen because catched in U.findT


tauJT  (TVar {var}) = stio (TArg {var = greek var})
tauJT  (Meta tv) | not tv.isFlexi = stio voidJT
tauJT  (Meta tv) = do
        g <- getST
        U.warn 0 (nice (Meta tv) g ++ " shouldn't appear anymore!")
        stio voidJT

targ s = TArg {var = greek s}

/**
 * [usage] @prodArity g (SymT ....)@
 * [returns] arity of first constructor of the type described by SymT
 * [undefined] if the symbol does not describe a type that has constructors
 */
prodArity g (SymT {env}) = length args where
    (_, args) = U.returnType con1.typ.rho
    con1 = head [ con | con@SymD {pos} <- values env ]

greek (s@#^[a-z]$#) = ctos (alphabet.charAt (ord (s.charAt 0) - ord 'a'))
greek s = "Σ" ++ s
alphabet = "αβγδεζηθιßκλμνξοπρςστυφχψωﬁﬂƒ"


numbers = (map show (iterate (1+) 1))
xxxNames xxx = zipWith (++) (repeat xxx) numbers
/// arg1, arg2, arg3, ....
argNames = xxxNames "_arg"
/// ctx1, ctx2, ctx3, ...
ctxNames = xxxNames "_ctx"
/// m1, m2, m3 ...
memNames = xxxNames "m"

jtValue  = Ref {jname = JName "" "Value", targs = []}
jtLazy x = Ref {jname = JName "" "Lazy",  targs = [x]}
boxed (Ref {jname = JName "" "Lazy", targs = [x]}) = x
boxed (Nativ "boolean" []) = Ref {jname = JName "" "Boxed.Bool", targs = []}
boxed (Nativ "char" [])    = Ref {jname = JName "" "Boxed.Char", targs = []}
boxed (Nativ "int" [])     = Ref {jname = JName "" "Boxed.Int", targs = []}
boxed (Nativ "long" [])    = Ref {jname = JName "" "Boxed.Long", targs = []}
boxed (Nativ "double" [])  = Ref {jname = JName "" "Boxed.Double", targs = []}
boxed (Nativ "float" [])   = Ref {jname = JName "" "Boxed.Float", targs = []}
boxed (prim@Nativ _ _)     = Ref {jname = JName "" "Boxed", targs = [prim]}
boxed (arr@Arr _)          = Ref {jname = JName "" "Boxed", targs = [arr]}
boxed x = x
lazy x = jtLazy (boxed x)
strict x = case boxed x of
    Ref {jname = JName "" "Boxed", targs = [x]} -> x
    Ref {jname = JName "" "Boxed.Bool"}   -> Nativ "boolean"  []
    Ref {jname = JName "" "Boxed.Char"}   -> Nativ "char" []
    Ref {jname = JName "" "Boxed.Int"}    -> Nativ "int" []
    Ref {jname = JName "" "Boxed.Long"}   -> Nativ "long" []
    Ref {jname = JName "" "Boxed.Double"} -> Nativ "double" []
    Ref {jname = JName "" "Boxed.Float"}  -> Nativ "float" []
    other -> other

jtRmode (Ref (JName "" "Lazy") _) = RLazy
jtRmode (Nativ _ _) = RNative
jtRmode _ = RBoxed

/**
 * [usage] @erased jtype@
 * [returns] if @jtype@ is a generic reference type, the type without type arguments
 */
erased (Ref x _) = Ref x []
erased x = x
/// like 'erased', but replaces type arguments with BoxedVoid
erasedObj (Ref x targs) = Ref x (map (const voidJT) targs)
erasedObj x = x

isPrimitive (ref@Ref _ _) | n@Nativ _ _ <- strict ref = isPrimitive n
isPrimitive (Nativ (m ~ #^(byte|short|boolean|char|int|long|double|float)$#) _) = m.group 1
isPrimitive _ = Nothing

post = stio true

pass = do
    g <- getST

    U.print "final public class "
    U.print (g.thisPack.className g).base
    U.println " {"
    let vals = values g.thisTab

    makeConstants

    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymT {sid} <- vals ])
        >>= ppSS
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymC {sid} <- vals ])
        >>= ppSS
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymI {sid} <- vals ])
        >>= ppSS
    foreach (sortBy (comparing Symbol.name) [ s | s@SymV {sid} <- vals ]) printCode




    let toMaybe | g.thisPack == pPrelude = [mkMaybe false, mkMaybe true]
                | otherwise = []
        /*
         * Code for the _toMaybe function(s)
         */
        mbSigma  = ForAll ["a"] (RhoTau [] mbTau)
        mbTau    = TApp (TCon {pos=0, name = TName pPrelude "Maybe"}) tvara
        tvara    = TVar {var = "a", pos=0, classes = []}

        mkMaybe boxd = toMaybeMethod
            where
                boxeda   = if boxd then Ref (JName "" "Boxed") [targ "a"] else targ "a"
                toMaybeMethod = JMethod {attr = attrs [JFinal, JPublic],
                                gargs = [],
                                jtype = Nativ "static" [],
                                name = if boxd then "<α> TMaybe<Boxed<α>> _toMaybe"
                                               else "<α extends Lazy<α>> TMaybe<α> _toMaybe",
                                args = [(attrFinal,
                                    ForAll [] (RhoTau [] tvara),
                                    if boxd then targ "a" else lazy (targ "a"),
                                    "arg")],
                                body = JBlock [JReturn toMBex]}
                toMBex = JQC (JBin (JAtom "arg") "==" (JAtom "null"))
                            (JInvoke (JStMem (JName "TMaybe.DNothing" "mk") [boxeda]) [])
                            (JInvoke (JStMem (JName "TMaybe.DJust" "mk")    [boxeda]) [boxArg])
                boxArg = if boxd
                    then JInvoke (JStMem (JName "Boxed" "mk") [targ "a"]) [JAtom "arg"]
                    else JAtom "arg"


    invokeMain <- genMain
    ppSS [invokeMain, toMaybe]
    U.println "}"
    // pp (anno theClass)
    stio ("java class", 1)

ppSS xss = foreach (concat xss) (pp • anno)
printCode sym = do
    defs <- symCode Nil sym
    foreach defs (pp • anno)


findConst (Lit {pos,kind,value})
    | kind `elem` [LInt, LLong, LBig] = stio (JName "C" (kinda kind ++ value))
    | kind == LBool = case value of
        "true" -> stio (JName "Boxed.Bool" "t")
        _      -> stio (JName "Boxed.Bool" "f")
    | otherwise  = do
        g <- getST
        case g.gen.consts.lookup (kind,value) of
            Just u -> stio (JName "C" (kinda kind ++ show u))
            Nothing -> U.fatal pos ("literal not found: " ++ value)
    where
        kinda LBool   = "bool"
        kinda LInt    = "int"
        kinda LRegex  = "rgx"
        kinda LString = "str"
        kinda LDouble = "dbl"
        kinda LFloat  = "flt"
        kinda LChar   = "chr"
        kinda LBig    = "big"
        kinda LLong   = "long"


makeConstants = do
        allvs  <- T.allourvars
        cTree  <- foldSt (U.foldEx true literals) Nil [ x | SymV {expr = Just x} <- allvs ]
        cnList <- mapSt numberConst (each cTree)
        let cnTree = Tree.fromList cnList
        changeST Global.{gen <- GenSt.{consts = cnTree}}
        consts <- mapSt genConst (values cTree)
        let constclass = JInterface {
                                attr = attrs [JPublic, JStatic],
                                jtype = (Ref (JName "" "C") []),
                                implement = [],
                                defs = consts
                                }
        pp (anno constclass)
        stio ()
    where
        patliterals t (PCon {pats}) = fold patliterals t pats
        patliterals t p
            | p.{pat?} = patliterals t p.pat
        patliterals t (PMat {pos,value})
            = insert t (LRegex,value) (Lit pos LRegex value (Just TY.sigRegex))
        patliterals t (PLit {pos,kind,value}) | kind != LBool
            = insert t (kind,value) (Lit pos kind value (Just (TY.litSigma kind)))
        patliterals t p = t

        literals t (Lam {pat=p}) = stio (Left (patliterals t p))
        literals t (Case {alts}) = stio (Left (fold patliterals t (map CAlt.pat alts)))
        literals t (lit@Lit {kind, value})
            | kind != LBool = stio (Left (insert t (kind,value) lit))
            // otherwise = stio (Left t)
        literals t x = stio (Left t)

        numberConst (k, _) = do
            u <- U.uniqid
            stio (k;u)

        genConst (lit@Lit {kind,value}) = do
            jname <- findConst lit
            let lsigma = TY.litSigma kind
            bjt   <- sigmaJT lsigma
            let it = JMember { attr = attrs [JPublic, JStatic, JFinal],
                               jtype = bjt, name = jname.base, init = Just bb.jex }
                ex = case kind of
                    LBig -> JNew (Ref (JName "" "java.math.BigInteger") []) [JAtom (show value)]
                    LRegex -> JInvoke
                                (JStMem (JName "java.util.regex.Pattern" "compile") [])
                                [JAtom value]
                    otherwise -> JAtom value

                nb = Bind RNative lsigma (strict bjt) ex
                bb = toBoxed nb
            stio it

genMain = do
    g <- getST
    case (VName g.thisPack "main").findit g of
        Just sym | sym.name.pack == g.thisPack = do         // we have a main
            let tc n = TCon {pos=sym.pos, name = TName pPrelude n}
                tauSig tau = ForAll [] (RhoTau [] tau)
                sarrTau = tauSig (TApp (tc "StringArray") (tc "Immutable"))
            sarrJT <- sigmaJT sarrTau
            let args = [(attrFinal, sarrTau, strict sarrJT, "argv")]
            let st   = (tc "ST").name
                stpu = MName st "performUnsafe"
                sarr = (tc "StringArray").name
                toli = MName sarr "toList"
            vstpu <- U.findV stpu
            vtoli <- U.findV toli
            let avb = toBoxed (argBind (head args))
                slist = TApp (tc "[]") (tc "String")
                sig1 = ForAll [] (RhoFun [] (sarrTau) (RhoTau [] slist))
            btoli <- instSym sym.pos vtoli sig1
            let  apparg = JInvoke (JExMem btoli.jex "a") [avb.jex]
            bmain <- instSym sym.pos sym mainSigma
            let applist = JInvoke (JExMem bmain.jex "a") [apparg]
                iovoid = TApp (TApp (tc "ST") (tc "RealWorld")) (tc "()")
                sig2 = ForAll [] (RhoFun [] (tauSig iovoid) (RhoTau [] (tc "()")))
            bperf <- instSym sym.pos vstpu sig2
            let appio = JInvoke (JExMem bperf.jex "a") [applist]
                appe  = JInvoke (JExMem appio "_e") []
                gettime s = JMember {attr = attrFinal, jtype = Nativ "long" [], name=s,
                            init = Just (JInvoke
                                (JStMem (JName "java.lang.System" "nanoTime") [])
                                [])}
                stmts = [ JLocal (gettime "t1"), JEx appe, JLocal (gettime "t2"), times ]
                times = JEx (JInvoke (JStMem (JName "java.lang.System.err" "println") [])
                                [ex1])
                ex1 = JBin (JAtom "\"runtime \"") "+" ex2
                ex2 = JBin ex3 "+" (JAtom "\" wallclock seconds.\"")
                ex3 = JBin ex4 "/" (JAtom "1e3")
                ex4 = JBin ex5 "/" (JAtom "1000000")
                ex5 = JBin ex6 "+" (JAtom "500000")
                ex6 = JBin (JAtom "t2") "-" (JAtom "t1")
                mMeth = JMethod {attr = attrs [JPublic, JStatic], gargs = [],
                            jtype = Nativ "void" [],        // sure thing :)
                            name  = "main",
                            args, body = JBlock stmts }
            stio [mMeth]
        sonst -> stio []

/// the @_c@ method
/// >final public int _c() { return n; }
cMethod n = atomMethod "_c" (Nativ "int" []) (show n)
/**
 * [usage] @atomMethod name type atom@
 * [returns] a 'JMethod' of the form @final public /type/ /name/() { return /atom/; }@
 */
atomMethod s jt atom = JMethod {attr = attrs [JFinal, JPublic], gargs=[], jtype = jt,
                    name = s, args=[], body = JBlock [ JReturn (JAtom atom) ]}

/// returns @SuppressWarnings("unchecked") public final <x,y> T<x,y> coerce() { return (T<x,y>) this; }@
coerceMethod typ = JMethod { attr = attrs [JUnchecked, JPublic, JFinal],
                    gargs = JType.targs typ,
                    jtype = typ,
                    name = "coerce", args = [],
                    body = JBlock [JReturn (JCast typ (JAtom "this"))]}

/**
 * [usage] @conGetter qname@
 * [return] the name of the method that gets the variant
 * [example] @conGetter (MName tname "Con")@ evaluates to @"_Con"@
 */
conGetter (MName tname base) = "_" ++ mangled base

/**
 * [usage] @variantType g jtype symd@
 * [return] the type of the variant, i.e. @TMaybe.Just<a>@, if jtype is the jt of the type
 */
variantType :: Global -> JType -> Symbol -> JType
variantType g jtype symd = jtype.{jname = U.javaName g (Symbol.name symd)}


/**
 * Unify 2 Sigmas
 *
 * The first one is a quantified type from some symbol table item.
 * The second one is the actual type of some expression and must be an instance
 * of the first one.
 *
 * > unifySigma (forall a b. Maybe a -> [b]) (Maybe Int -> [Float]) ==> [(a,Int), (b, Float)]
 *
unifySigma g (ForAll [] _) _ = Nil
unifySigma g s1 (ForAll _ rho) = unifyRho g Nil s1.rho rho
unifyRho g t (RhoFun ctx1 (ForAll _ s1) r1) (RhoFun ctx2 (ForAll _ s2) r2) = result
    where
        // t1 = unifyCtx g t  ctx1 ctx2
        t2     = unifyRho g t  s1 s2
        result = unifyRho g t2 r1 r2
unifyRho g t (RhoTau ctx1 t1) (RhoTau ctx2 t2) = result
    where
        // ta     = unifyCtx g t ctx1 ctx2
        result = unifyTau g t  t1   t2
// unifyCtx g t ctx1 ctx2 = fold (uCtx g) t (zip ctx1 ctx2)
//    where uCtx g t (Ctx {tau=tau1}, Ctx {tau=tau2}) = unifyTau g t tau1 tau2

unifyTau g t (TVar {var}) b = insert t var b
unifyTau g t (TFun a b) (TFun c d) = unifyTau g (unifyTau g t a c) b d
unifyTau g t (TApp a b) (TApp c d) = unifyTau g (unifyTau g t a c) b d
unifyTau g t _ _ = t

// **
 * [usage] @sigmaInst sigma1 sigma2@
 * [returns] a list of 'Tau' types that are substituted for
 * the bounded variables of @sigma1@ in @sigma2@
 * which must be a valid substitution of the former (up to contexts).
 * /
sigmaInst g sigma1 sigma2 = map (unJust • lookup tree) (Sigma.bound sigma1)
    where tree =  unifySigma g sigma1 sigma2
    */
/**
 * Code for data constructors
 *
 * - For nullary constructors, a subclass of @Constant@ is derived that contains a singleton and
 * an appropriate @mk@ method.
 * - For constructors with arity > 0, a subclass of @Product@/n/
 *   with a static @mk@ method is derived.
 * - For constructors with arity > 0 a singleton @Fun@/n/ that calls the
 *   @mk@ method is created, also a static @n@ method to get the function.
 */
conCode symt cons (sym@SymD {flds, cid}) = do       // nullary
    g <- getST
    symtjt     <-  sigmaJT (Symbol.typ symt)


    let jtype       = variantType g symtjt sym
        (_, argtys) = U.returnType sym.typ.rho
    argjts <- mapSt subSigmaJT argtys
    funty  <- sigmaJT sym.typ

    let djtype = defining jtype
        nogen  = erased jtype
        arity  = length flds
        comment = JComment (nice sym g)
        result = sumCon
        sumCon = JClass {attr = attrs [JStatic, JPublic, JFinal],
                            jtype = djtype, extend = ext, implement = imp, defs}
        !ext | arity == 0 = Just (Ref {jname=JName "" "Constant", targs=[]})
            | otherwise  = Just (Ref {jname=JName "" ("Product" ++ show arity),
                                      targs=argjts})
        imp = [symtjt]

        defs = [comment, constr, cMethod cid,
                    atomMethod "_v" jtype "this",
                    atomMethod "_e" jtype "this",
                    single, make] ++ fun ++ getters
        !single | arity == 0 = JMember {attr = attrs [JPrivate, JStatic],
                                        jtype = nogen,
                                        name = "single",
                                        init = Just (JNew nogen [])}
                | otherwise = JMember {attr = attrs [JPrivate, JStatic],
                                        jtype = erased cclass.jtype,
                                        name = "single",
                                        init = Just (JNew (Ref (JName "" "Construct") []) [])}

        cclass = JClass {attr = attrs [JPublic, JStatic],
                                    jtype = Ref (JName "" "Construct") jtype.targs,
                                    extend = Just funty,
                                    implement = [],
                                    defs = [rMethod]}
        worker  = (workerMethod g sym).{targs = jtype.targs}
        rMethod = JMethod {attr = attrs [JPublic, JFinal], gargs = [], jtype, name = "r",
                            args = reverse constrargs,
                            body = JBlock [JReturn (JInvoke worker args)]}
        nMethod = JMethod {attr = attrs [JUnchecked, JPublic, JFinal, JStatic],
                            gargs = jtype.targs, jtype = cclass.jtype, name = "n",
                            args = [],
                            body = JBlock [JReturn (JCast cclass.jtype (JAtom "single"))]}
        !fun | arity == 0 = []
            | otherwise = [cclass, nMethod]

        !make | arity == 0 = JMethod {attr = attrs [JUnchecked, JPublic, JFinal, JStatic],
                                    gargs = jtype.targs, jtype, name = "mk",
                                    args = [],
                                    body = JBlock [JReturn (JCast jtype (JAtom "single"))]}
            | otherwise = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                    gargs = jtype.targs, jtype, name = "mk",
                                    args = constrargs,
                                    body = JBlock [JReturn (JNew jtype args)]}

        constrargs = [ (attrFinal, ty, lazy jt, n) |
                            (jt, (ty, n)) <- zip argjts (zip argtys argNames) ]
        args = take arity (map JAtom argNames)
        constr = JConstr {attr = attrs [JPrivate], jtype = jtype, args = constrargs,
                            body = JBlock super}
        !super | arity == 0 = []
               | otherwise = [JEx (JInvoke (JAtom "super") args)]
        getters = // if symt.product then [] else
                    atomMethod (conGetter sym.name) jtype "this" :
                    [ atomMethod (conGetter (Symbol.name con))
                                 (variantType g symtjt con) "null"
                         | con <- cons, Symbol.sid con != sym.sid ]  // other constructors
    stio [result]


/**
 * Code for data types
 *
 * - Native types create a class @TName@ that acts as namespace for
 *   member definitions.
 * - Enumerations create a class @Tname@ that contains final Boxed.Int Con = Boxed.Int.mk(cid)
 * - Algebraic types create an interface @Tname@ that extends @Value@ and @Lazy@ and contains
 *   an abstract method @_Con@ to get the variant associated with @Con@.
 */
symCode binds (sym@SymT {enum=true}) = do
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
        cons = [ con | con@SymD {sid} <- vals ]
        other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]

    subDefs <- mapSt (symCode binds) other

    let jtype = Ref {jname = U.javaName g sym.name, targs = []}     // TName
        result = JClass {attr = attrs [JFinal, JPublic, JStatic], jtype,
                        extend = Nothing,
                        implement = [],
                        defs = (constr : conDefs) ++ concat subDefs}
        constr = JConstr { attr = attrs [JPrivate], jtype, args=[], body = JBlock []}
        conDefs = [ JMember {attr = attrs [JPublic, JStatic, JFinal],
                        jtype = Ref (JName "" "Boxed.Int") [],
                        name = mangled name.base,
                        init = Just (JInvoke (JStMem (JName "Boxed.Int" "mk") [])
                                             [JAtom (show cid)])}
                      | SymD {name, cid} <- cons ]
    stio [JComment (nice sym g), result]
symCode binds (sym@SymT {product=true}) = do                    // product
    g <- getST

    let vals = sortBy (comparing Symbol.name) (values sym.env)
        other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]
    subDefs <- mapSt (symCode binds) other
    symjt   <- sigmaJT sym.typ

    let jtype  = symjt.{jname = U.javaName g sym.name}
        // tyapp  = fold mkTyApp (jtype) jtype.targs
        // mkTyApp t1 t2 = Ref (JName "" "TyApp") [t1, t2]
        symd   = head [ con | con@SymD {sid} <- vals ]            // constructor
        (_, argtys) = U.returnType symd.typ.rho
        coargs = (map targ • take (length sym.typ.bound) • filter (`notElem` sym.typ.bound))
                     U.allBinders
    funty      <- sigmaJT symd.typ
    ftypes     <- mapSt subSigmaJT (map snd symd.flds)
    argjts     <- mapSt subSigmaJT argtys
    let arity  = length symd.flds
        ext    = Just (Ref {jname=JName "" ("Product" ++ show arity), targs = ftypes})
        imp    = [jtValue, lazy jtype]
        defs = [comment, constr, cMethod symd.cid,
                    atomMethod "_v" jtype "this",
                    atomMethod "_e" jtype "this",
                    single, make, cclass, nMethod, coerce] ++ concat subDefs
        comment = JComment (nice symd g)
        constrargs = [ (attrFinal, ty, (lazy jt), n) |
                            ((ty, jt), n) <- zip (zip argtys argjts) argNames ]
        args   = take arity (map JAtom argNames)
        constr = JConstr {attr = attrs [JPrivate], jtype = jtype, args = constrargs,
                            body = JBlock super}
        super  = [JEx (JInvoke (JAtom "super") args)]
        single = JMember {attr = attrs [JPrivate, JStatic],
                                        jtype = erased cclass.jtype,
                                        name = "_single",
                                        init = Just (JNew (Ref (JName "" "Construct") []) [])}
        coerce = JMethod {attr = attrs [JUnchecked, JPublic, JFinal],
                                gargs = coargs, jtype = jtype.{targs=coargs},
                                name = "coerce", args = [],
                                body = JBlock [JReturn (JCast jtype.{targs=coargs} (JAtom "this"))]}
        make   = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                    gargs = jtype.targs, jtype, name = "mk",
                                    args = constrargs,
                                    body = JBlock [JReturn (JNew jtype args)]}
        cclass = JClass {attr = attrs [JPublic, JStatic],
                                    jtype = Ref (JName "" "Construct") jtype.targs,
                                    extend = Just funty,
                                    implement = [],
                                    defs = [rMethod]}
        worker  = (workerMethod g symd).{targs = jtype.targs}
        rMethod = JMethod {attr = attrs [JPublic, JFinal], gargs = [], jtype, name = "r",
                            args = reverse constrargs,
                            body = JBlock [JReturn (JInvoke worker args)]}
        nMethod = JMethod {attr = attrs [JUnchecked, JPublic, JFinal, JStatic],
                            gargs = jtype.targs, jtype = cclass.jtype, name = "n",
                            args = [],
                            body = JBlock [JReturn (JCast cclass.jtype (JAtom "_single"))]}
        result = JClass {attr = attrs [JFinal, JPublic, JStatic], jtype,
                         extend = ext, implement = imp, defs}
    stio [JComment (nice sym g), result]

symCode binds (sym@SymT {nativ=Nothing}) = do                   // sum type
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
        cons = [ con | con@SymD {sid} <- vals ]
        funs = [ sym | sym@SymV {sid} <- vals, not (Symbol.{flds?} sym), Symbol.depth sym > 0]
        cafs = [ sym | sym@SymV {sid} <- vals, not (Symbol.{flds?} sym), Symbol.depth sym == 0]
    funDefs <- mapSt (symCode binds) funs
    cafDefs <- mapSt (symCode binds) cafs
    conDefs <- mapSt (conCode sym cons) cons
    symjt   <- sigmaJT sym.typ
    let jtype = symjt.{jname = U.javaName g sym.name}
        getCons = [JMethod {attr = attrs [JPublic], gargs=[],
                            jtype = variantType g jtype con,
                            name = conGetter (Symbol.name con),
                            args = [], body = JEmpty}
            | con <- cons ]
        mClass | null cafDefs = []
               | otherwise    = [JClass {attr = attrs [JPublic, JStatic, JFinal],
                                    jtype = Ref (JName "" "M") [],
                                    extend = Nothing, implement = [],
                                    defs = concat cafDefs}]
        result = JInterface {attr = attrs [JPublic], jtype,
                            implement = [jtValue, lazy jtype],
                            defs = getCons ++ concat conDefs ++ concat funDefs ++ mClass}
    stio [JComment (nice sym g), result]

symCode binds (sym@SymT {sid, nativ = Just _}) = do                               // nativ
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
    subDefs <- mapSt (symCode binds) vals
    let jtype = Ref {jname = U.javaName g sym.name, targs=[]}
        result = JClass {attr = attrs [JStatic, JPublic, JFinal],
                            jtype, extend = Nothing, implement = [],
                            defs = concat subDefs}
    stio [JComment (nice sym g), result]

/**
 * Code for type classes
 *
 * - interface @Cname@</a/> where /a/ is the class variable
 * - for each class method, an abstract method that returns a function
 * - name space @I@ for default function implementations
 */
symCode binds (sym@SymC {sid}) = do           // type class
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
    abstrFuns <- mapSt (abstractFun sym) vals
    let ivals = filter (isJust • Symbol.expr) vals         // default implementations
    implFuns <- mapSt (symCode binds) ivals
    taujt     <- tauJT sym.tau
    let jtype = Ref (U.javaName g sym.name) [taujt]
        jinterface = if sym.vkind == 0 then JInterface else JTCInterface
        superclasses = [ Ref (U.javaName g nm) [taujt] | nm <- sym.supers ]
        implDef
            | null implFuns = []
            | otherwise = [JClass {attr = attrs [JPublic, JStatic],
                            jtype = Ref (JName "" "I") [],
                            extend = Nothing, implement = [], defs = concat implFuns}]
        result = jinterface (attrs [JPublic]) jtype superclasses (concat abstrFuns ++ implDef)
    stio [JComment (nice sym g), result]

/**
 * Code for instances
 *
 * - interface @Cname@</a/> where /a/ is the class variable
 * - for each class method, an abstract method that returns a function
 * - name space for default functions (?)
 */
symCode binds (sym@SymI {sid}) = do             // instance definition
    g <- getST
    csym <- U.findC sym.clas

    let bnds    = sym.typ.bound
        i       = head ((filter (`notElem` bnds)) U.allBinders)
        ijt     = targ i
        classes = sym.clas:csym.supers
        methods = case U.instTSym (Symbol.typ sym) g of
            Just (tsym@SymT {pos}) -> [ alias |
                              SymL {alias} <- values tsym.env, alias.{tynm?},
                              SymI {clas} <- (QName.findit alias.tynm g).toList,
                              clas `elem` classes]
            _ -> error "unexpexted result from instTSym"

    let vals = sortBy (comparing Symbol.name) (values sym.env)

    instFuns  <- mapSt (instFun csym sym) methods
    instImpls <- mapSt (symCode binds) vals
    symjt     <- sigmaJT sym.typ
    constraints <- mapSt  (curry makeConstraintDef) (zip sym.typ.rho.context ctxNames)
    constrargs  <- mapSt  (curry makeConstraintArg) (zip sym.typ.rho.context argNames)


    let instjt = if csym.vkind > 0 then ijt else symjt
        qms = take csym.vkind (repeat (TArg "?"))
        singleton = null constraints
        jtargs = if csym.vkind > 0 then (ijt:map targ bnds) else map targ bnds
        jtype = Ref (U.javaName g sym.name) jtargs
        etype = Ref (U.javaName g sym.clas) [instjt]
        constructor = JConstr {attr = attrs [if singleton then JPrivate else JPublic],
                                jtype = if csym.vkind > 0 then erased jtype else jtype,
                                args = constrargs,
                                body = JBlock (take (length constraints)
                                                (zipWith JAssign
                                                    (map JAtom ctxNames)
                                                    (map JAtom argNames)))}
        singles = if singleton then [finst, fnew] else []
        finst  = JMember {attr = attrs [JPrivate, JStatic, JFinal],
                          jtype = jtype.{targs=[]},
                          name = "ƒInstance",
                          init = Just (JNew jtype.{targs=[]} [])}

        fnew   = JMethod {attr = attrs [JUnchecked, JPublic, JStatic, JFinal],
                            gargs = jtype.targs,
                            jtype = jtype,
                            name = "ƒNew",
                            args = [],
                            body = JBlock [castedFinst]}
        castedFinst = JReturn (JCast jtype (JAtom "ƒInstance"))

        result = JClass {attr = attrs [JPublic, JFinal, JStatic], jtype,
                         extend = Nothing,
                         implement = [etype],
                         defs = (constructor : constraints)
                            ++ singles
                            ++ concat instFuns
                            ++ concat instImpls}
    stio [JComment (nice sym g ++ " :: " ++ nice sym.typ g), result]

symCode binds (sym@SymV {expr = Just x})
    | sym.depth > 0 = do trace; funClass sym binds
    | otherwise     = do trace; cafCode sym binds
    where
        trace = do
            g <- getST
            U.logmsg TRACEG sym.pos ("compiling " ++ sym.nice g)

symCode binds (sym@SymV {nativ = Just item}) = methClass sym

/// unimplemented items produce a comment
symCode binds sym = do
    g <- getST
    stio [JComment (nice sym g)]

latinF = "ƒ"


/// declare abstract class Member function

abstractFun symc (sym@SymV {sid}) = do
    g <- getST
    let bnds = sym.typ.bound
    let classCtx = Ctx {pos=0, cname = Symbol.name symc, tau = Symbol.tau symc, checked = false }
        tauvar = case Symbol.tau symc of
            TVar {var} -> var
            _ -> ""
        ctxs = [ ctx | ctx <- sym.typ.rho.context,
                    not (TC.sameCtx ctx classCtx)]      // filter out class context
        funtyp = ForAll bnds ((fst • U.returnTypeN 0) sym.typ.rho)

    constrformal <- mapSt (curry makeConstraintArg) (zip ctxs ctxNames)
    sjt          <- sigmaJT funtyp
    let    result = JMethod {attr = attrs [JPublic],
                            gargs = map targ (filter (!=tauvar) bnds),
                            jtype = if symc.vkind > 0 then erasedObj sjt else sjt,
                            name = mangled sym.name.base ++ latinF,
                            args = constrformal, body = JEmpty}
    stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]
abstractFun _ _ = undefined

/**
 * >  class @Eq eq@
 * >  instance `Eq_(,,,)` :: forall u v w x.(Eq v,Eq w,Eq x,Eq u) => (w,x,u,v)
 * >  class member function `Eq.!=` :: forall eq.Eq eq => eq -> eq -> Bool
 * >  instance member `Eq_(,,,).!=` :: forall a b c d.(Eq b,Eq c,Eq d,Eq a) => (c,d,a,b) -> (c,d,a,b) -> Bool
 * Extra type variables and constraints in instance member must be retained.
 * Therefore:
 * 1. rename all type variables in instance member type so that the type variables
 * in the instance type and the instance member type are distinct
 * 2. unify class member type and instance member type, note what is bound to the class variable
 * 3. unify instance type and the result from previous step
 * 4. substitute it in instace member type
 * 5. reconstruct forall bound in instance member type
 */
fakeInstSigma (symc@SymC{supers}) (symi@SymI{sid}) (sym@SymV{typ}) = do
    g <- getST
    let symjsb      = sym.typ.bound
        instjsb     = symi.typ.bound

    let newvars = [ TVar {pos=sym.pos, var, classes = []} |
                        var <- U.allBinders,
                        var `notElem` instjsb,
                        var `notElem` symjsb ]
        tree1 = Tree.fromList (zip symjsb newvars)
    rho1 <- U.substRho tree1 sym.typ.rho
    U.logmsg TRACEG sym.pos ("renamed  " ++ nicer sym.typ g ++ "  to  " ++ nicer rho1 g)

    let classes = symc.name:symc.supers
        memc = head [ sym | c <- classes, sym <- ((MName c sym.name.base).findit g).toList ]
    symc <- U.findC memc.name.tynm
    let clas = symc.tau
        tree2 = U.unifySigma g memc.typ (ForAll [] rho1.{context=[]})
        Just itau = tree2.lookup clas.var       // member type MUST mention it, see Classes.fr
        sigma2a = ForAll [] (RhoTau [] itau)
        validSigma rho = ForAll (U.freeTVars [] rho) rho
        sigma2 = validSigma sigma2a.rho
    U.logmsg TRACEG sym.pos ("class var  " ++ clas.var
            ++ "  in  " ++ nicer memc.typ g
            ++ " corresponds to  " ++ nicer sigma2 g)

    let tree3 = U.unifySigma g sigma2 symi.typ
    rho4   <- U.substRho tree3 rho1

    let sigma4 = validSigma rho4      // provide type variables
        bound  = filter (`elem` sigma4.bound) instjsb ++ filter (`notElem` instjsb) sigma4.bound
        sigma5 = ForAll bound rho4      // binds in correct order
    U.logmsg TRACEG sym.pos ("fake type is  " ++ nicer sigma5 g)
    stio sym.{typ=sigma5}

instFun symc symt mname = do
    g <- getST
    // establish a fake type for instance member that matches the one of the instance
    // cmem  <-  U.findV (MName (Symbol.name symc) (QName.base mname))
    sym   <-  U.findV mname
    let orig = sym                                          // save for later
    sym   <-  fakeInstSigma symc symt sym

    let bndsV = sym.typ.bound
        bndsI = (Symbol.typ symt).bound
    let name   = U.javaName g sym.name                       // X.foo
        fname  = /*U.fName*/ name                            // X.Ffoo
        higher = (Symbol.vkind symc) > 0                     // higher kinded tyvar?
        bnds   = filter (`notElem` bndsI) bndsV
        unmentioned = filter (`notElem` bndsV) bndsI
        ftargs = map targ bnds
        itargs = map targ bndsV
        implies = impliesG g
        funtyp = ForAll bnds ((fst • U.returnTypeN 0) sym.typ.rho)
        ctxs = [ ctx | ctx <- sym.typ.rho.context,
                    not (any (`implies` ctx) symt.typ.rho.context)]
        ourCtxNms = drop symt.typ.rho.context.length ctxNames   // ctx3, ctx4, ....
    unless (null unmentioned) do
        U.warn sym.pos ("type of " ++ sym.nice g ++ " :: " ++ nicer sym.typ g
            ++ " does not mention type variables "
            ++ joinStr ", " unmentioned ++ " from the instantiated type  "
            ++ nice symt.typ g)
    let cmeth = case sym.expr of
            Just (v@Vbl {name=MName cname bs})
                | cname `elem` (symc.name:symc.supers) = v.name.findit g    // just class method
            other -> Nothing
    let set = unJust (unJust sym.expr).typ

    instMe <- case cmeth of
        Just meth -> compiling sym (instSym0 false false sym.pos meth sym.typ)
        other     -> compiling sym (instSym sym.pos orig sym.typ)

    constrformal <- mapSt (curry makeConstraintArg) (zip ctxs ourCtxNms)
    sjt          <- sigmaJT funtyp
    let constrargs   = map JAtom (take sym.typ.rho.context.length ctxNames)
        eosjt = erasedObj sjt
        result = JMethod {attr = attrs [JPublic, JFinal],
                            gargs = ftargs,
                            jtype = if higher then eosjt else sjt,
                            name = mangled sym.name.base ++ latinF,
                            args = constrformal,
                            body = JBlock (coerceThis ++ [JReturn impl])}
        coerceThis = []
        implInst = (toBoxed instMe).jex
        impl
            | higher = JInvoke (JExMemG implInst "coerce" eosjt.targs) []
            | otherwise = implInst
    stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]



/**
 * return the method name of the worker function for the given symbol
 */
workerMethod g (sym@SymD {name}) = case U.javaName g name of
        jname -> JStMem (U.memberOf jname "mk") []
// workerMethod g (sym@SymV {name, nativ=Just item}) =
workerMethod g (sym@SymV {name})
    | sym.rkind `band` 6 == 0 = JAtom "r"
    | Local _ <- name = JAtom "w"
    | null sym.typ.rho.context = case U.javaName g name of
        jname -> JStMem (U.memberOf jname "w") []
    | otherwise = JAtom "w"
workerMethod g _ = error "workerMethod: no SymV"


/**
 * @makeConstraintDef (Ctx cname tau) "ctx3"@ = final Ccname<tau> ctx3
 */
makeConstraintDef (Ctx {cname,tau}) s = do
        g    <- getST
        itau <- tauJT tau
        stio (JMember {
            attr = attrFinal,
            jtype = Ref (U.javaName g cname) [itau],
            name = s,
            init = Nothing})

/**
 * @makeConstraintArg (Ctx cname tau) "arg3"@ = (final,  Ccname<tau>, "ctx3")
 */
makeConstraintArg ctx s = do
    def <- makeConstraintDef ctx s
    stio (def.attr, (ForAll [] (RhoTau [] (Context.tau ctx))), def.jtype, def.name)

/**
 * generate method signature from strictness info and argument types
 */
argDef attr stri sigmas argNms
    | S ss <- stri = mapSt argdef (zip ss      (zip sigmas argNms))
    | otherwise    = mapSt argdef (zip allLazy (zip sigmas argNms))
    where
        argdef (s, (sig, nm)) = do
            argjt <- subSigmaJT sig
            if Strictness.isStrict s then stio  (attr, sig, strict argjt, nm)
                else stio (attr, sig, lazy argjt, nm)

/**
 * convert an arg quadrupel to a 'Binding'
 */
argBind(_, sig, jt, s) = Bind (jtRmode jt) sig jt (JAtom s)

/**
 * the mode a certain argument is in, given strictness and sigma
 */
argMode s sig
    | Strictness.isStrict s = do
        sjt <- sigmaJT sig
        stio (jtRmode (strict sjt))
    | otherwise = stio RLazy

/**
 * code for non-functions
 * - if there is a 'ForAll' or constraints, we make a static function with constraint args.
 * - else, if the easy bit is off, we make an U<type> and write the code in the eval function.
 * - else we just initialize
 */
cafCode (sym@SymV {depth = 0, expr = Just x}) binds = do
    g    <- getST
    let bnds = sym.typ.bound
        argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava.argNames
        ctxNames = drop (length (envCtxs g)) GenJava.ctxNames

    let (rtyp, _) = U.returnTypeN 0 sym.typ.rho
        symtyp = ForAll bnds rtyp
        mode  = if rlazy then RLazy else RBoxed
        smode = if rlazy then U else S[]
        rlazy = not g.toplevel `and` not sym.strsig.isStrict `or` sym.rkind `band` 1 == 0
        rsimple = sym.rkind `band` 16 != 0
        ctxs  = if null bnds then [] else filter  (not • Context.checked) sym.typ.rho.context

    cargs       <- mapSt  (curry makeConstraintArg) (zip ctxs argNames)
    constraints <- mapSt  (curry makeConstraintDef) (zip ctxs ctxNames)
    jtype <- if not g.toplevel then subSigmaJT symtyp else sigmaJT symtyp
    x     <- if not g.toplevel then adaptHigherPolymorphic x symtyp else stio x
    ecode <- compiling sym (genExpr  false mode x binds)
    scode <- compiling sym (genStmts mode x binds)


    let name  = U.javaName g sym.name           // P.foo
        rtype = if rlazy then lazy jtype else boxed jtype
        comms = reverse [
                JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
                JComment (nicer sym.typ g), JComment (nicer x g)]
        jexpr = (toMode mode ecode).jex
        static = if g.toplevel then JStatic else JFinal
        publik = if g.toplevel then JPublic else JFinal
        cafV  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                          name = name.base,
                          init = Just jexpr}
        utype = Ref (JName "" "Unknown") [jtype]    // Unknown<R>
        ctype = Ref (JName "" cafV.name) (map targ bnds)
        newu  = JNewClass utype [] [vMeth]          // new Unknown<R>() { ... }
        theU
            | rlazy = newu
            | otherwise = JInvoke (JExMem newu "_e") []
        // fcode = if rlazy then [JReturn newu] else scode
        vMeth = JMethod { attr = attrs [JPublic, JFinal],
                          gargs = [], jtype = rtype,
                          name = "_v", args = [], body = JBlock scode }
        cafU  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                          name = cafV.name,
                          init = Just theU}
        cafF  = JClass  { attr = cafV.attr, jtype = defining ctype,
                          extend = Just utype,
                          implement=[], defs}
        defs = constraints ++ [constructor, vMeth]
        constructor = JConstr {attr = attrs [JPublic],
                                jtype = ctype,
                                args = cargs,
                                body = JBlock (take (length constraints)
                                                (zipWith JAssign
                                                    (map JAtom ctxNames)
                                                    (map JAtom argNames)))}
        !caf = case (g.toplevel, not (null bnds), not (null cargs), rsimple) of
            //top    binds  cargs  simple
            (_,     false, false, false) -> cafU
            (_,     false, false, true)  -> cafV
            (_,     _,     true,  _    ) -> cafF
            (_,     true,  _,     _    ) -> cafF
            // (true,  false, false, false) -> cafU
    stio (reverse (caf:comms))

/**
 * tell if a variable is implemented with a member or a class
 */
varIsClass (sym@SymV {name, depth, rkind})
    | depth > 0 = true
    // Local _ <- name = false
    // not (null (filter  (not • Context.checked) sym.typ.rho.context)) = true
    | not (null sym.typ.bound) = true
    | otherwise   = false
    where
        simple           = (rkind `band` 16) != 0
        global (Local _) = false
        global _         = true
varIsClass _ = error "varIsClass: no var"


/**
 * all the boilerplate code for a frege function
 */
funClass (sym@SymV {expr = Just x}) binds = do
    g <- getST
    if g.toplevel then topFun   sym binds
                  else if null sym.typ.bound
                    then innerFun sym binds
                    else innerQualifiedFun sym binds

/**
 * For some reason, when the function arguments have generic type arguments,
 * it does not work if the local class itself has no type arguments.
 * Therefore, we must introduce a fake generic type argument in this case.
 */
innerFun (sym@SymV {expr = Just x}) binds = do
    g <- getST
    let (rty, atys) = U.returnTypeN sym.depth sym.typ.rho
        argAttr     = if (sym.rkind `band` 8) == 0 then attrFinal else 0
        argNames    = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava.argNames
        plain       = false // null (U.freeTVars [] sym.typ.rho.{context = []})
    rjt  <- rhoJT rty
    ajts <- mapSt subSigmaJT atys
    workerArgs <- argDef argAttr sym.strsig atys argNames
    uArgs      <- argDef argAttr U atys argNames
    let extend = Ref (JName "" ("Fun" ++ show sym.depth)) (ajts ++ [rjt])
        name   = U.javaName g sym.name                        // X.foo
        cname  = JName "" name.base                           // foo
        fname  = cname.{base <- ("_"++)}                      // _foo
        ftargs = if plain then [] else [TArg "ﬁ"]             // <ﬁ1,ﬁ2,ﬁ3>
        ftype  = (Ref cname ftargs)                           // Ffoo<a,b,c>
        ttype  = if plain then ftype else ftype.{targs=[voidJT]}
        constructor = JConstr {attr = attrs [JPublic],
                                jtype = ftype,
                                args = [],
                                body = JBlock []}
        lazyr = sym.rkind `band` 1 == 0
        moder = if lazyr then RLazy else RBoxed
        hasworker = sym.rkind `band` 6 != 0
        rArgs      = reverse uArgs
        workerType = case rmode sym.rkind of
                                RLazy  -> lazy rjt
                                RBoxed -> rjt
                                RNative -> strict rjt
        workerName = "w"
        invokeWorker ftargs = JBlock [return]
            where
                return = JReturn (toMode moder worker).jex
                worker = Bind (rmode sym.rkind) (ForAll [] rty) workerType
                                                            (JInvoke workerex argexs)
                workerex = JAtom workerName
                argbinds = zipWith bind (take sym.depth argNames) (zip ajts atys)
                bind s (jt, sig) = Bind RLazy sig (lazy jt) (JAtom s)
                argexs = case sym.strsig of
                    S ss -> zipWith argexp ss argbinds
                    _    -> map Binding.jex argbinds
                argexp s bind
                    | Strictness.isStrict s = (strictBind bind).jex
                    | otherwise             = Binding.jex bind
        thisName = "this"  ++ show sym.sid
        thisBind = Bind RBoxed sym.typ ttype (JAtom thisName)
        innerbinds = insert binds sym thisBind

    stmts <- if hasworker
                then compiling sym (genFunction sym (rmode sym.rkind) workerArgs innerbinds)
                else compiling sym (genFunction sym moder        (reverse rArgs) innerbinds)

    let thisAssign = JLocal (JMember {attr = attrFinal,
                                        jtype=ttype, name = thisName,
                                        init = Just initThis})
        initThis = if plain then JAtom "this"
            else JInvoke (JExMemG (JAtom "this") "single" ttype.targs) []
        single  = if plain then [] else
                    [JMethod {attr = attrs [JUnchecked, JFinal],
                             gargs = ftype.targs,
                             jtype = ftype,
                             name = "single", args = [],
                             body = JBlock [
                                JReturn (JCast ftype (JAtom "this"))]}]
        rMethod = JMethod {attr = attrs [JPublic, JFinal],
                            gargs = [],
                            jtype = if lazyr then lazy rjt else rjt,
                            name = "r",
                            args = rArgs,
                            body = if hasworker then invokeWorker ftargs
                                    else JBlock (thisAssign:stmts)}

        worker = JMethod {attr = attrs [JPublic, JFinal],
                          gargs = [],
                          jtype = workerType,
                          name = workerName,
                          args = workerArgs,
                          body = JBlock (thisAssign:stmts)}
        // eWorker = if extworker then [worker] else []
        iWorker = if hasworker then [worker] else []
        fclass = JClass {attr = attrFinal,
                            jtype = ftype,
                            extend = Just extend,
                            implement=[], defs}
        defs = [constructor, rMethod] ++ iWorker ++ single
        fvar = JMember {attr = attrFinal, jtype=ttype, name = fname.base,
                      init = Just (JNew ttype [])}
    stio ([JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment (nicer x g),
        fclass, fvar
        ])


innerQualifiedFun (sym@SymV {expr = Just x}) binds = do
    g <- getST

    let argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava.argNames
        ctxNames = drop (length (envCtxs g)) GenJava.ctxNames
        bnds = sym.typ.bound                        // [a,b,c]
        (rty, atys) = U.returnTypeN sym.depth sym.typ.rho
        argAttr = if (sym.rkind `band` 8) == 0 then attrFinal else 0
        subfun = do
            rjt  <- rhoJT rty
            ajts <- mapSt subSigmaJT atys
            // extend      <- sigmaJT sym.typ
            constraints <- mapSt  (curry makeConstraintDef) (zip sym.typ.rho.context ctxNames)
            constrargs  <- mapSt  (curry makeConstraintArg) (zip sym.typ.rho.context argNames)
            workerArgs <- argDef argAttr sym.strsig atys argNames
            uArgs      <- argDef argAttr U atys argNames
            stio (rjt, ajts, constraints, constrargs, workerArgs, uArgs)

    (rjt, ajts, constraints, constrargs, workerArgs, uArgs)  <- subfun
    // when (null constraints `or` sym.anno) do
    //     // U.warn sym.pos ("inner " ++ nice sym g ++ " has constraints")
    //     // die unless they can be resolved right here
    //     foreach sym.typ.rho.context (resolveConstraint sym.pos)

    let extend = Ref (JName "" ("Fun" ++ show sym.depth))
                    (ajts ++ [rjt])
        name   = U.javaName g sym.name                        // X.foo
        fname  = JName "" name.base                           // foo
        ftargs = map targ bnds                                // <a,b,c>
        ftype  = (Ref (fname) ftargs)                         // Ffoo<a,b,c>
        inner  = true
        dftype = defining ftype

        constructor = JConstr {attr = attrs [JPublic],
                                jtype = ftype,
                                args = constrargs,
                                body = JBlock (take (length constraints)
                                                (zipWith JAssign
                                                    (map JAtom ctxNames)
                                                    (map JAtom argNames)))}

        lazyr = sym.rkind `band` 1 == 0
        moder = if lazyr then RLazy else RBoxed
        hasworker = sym.rkind `band` 6 != 0
        // extworker = false
        /*
        single
            | length constraints == 0 = [JMember {
                                attr = attrs [JFinal, JPrivate, JStatic],
                                jtype = erased ftype,
                                name = "single",
                                init = Just (JNew (erased ftype) [])}]
            | otherwise = []
        castedSingle = JReturn (JCast ftype (JAtom "single"))
        newInstance  = JReturn (JNew  ftype (take (length constraints) (map JAtom argNames)))
        */
        rArgs      = reverse uArgs
        workerType = case rmode sym.rkind of
                                RLazy  -> lazy rjt
                                RBoxed -> rjt
                                RNative -> strict rjt
        workerName = case workerMethod g sym of
                JAtom s -> s
                JStMem {jname = JName _ s} -> s
        invokeWorker ftargs = JBlock [return]
            where
                return = JReturn (toMode moder worker).jex
                worker = Bind (rmode sym.rkind) (ForAll [] rty) workerType
                                                            (JInvoke workerex argexs)
                workerex = case workerMethod g sym of
                    w@JStMem {jname} -> w.{targs=ftargs}
                    w@JAtom _ -> w
                argbinds = zipWith bind (take sym.depth argNames) (zip ajts atys)
                bind s (jt, sig) = Bind RLazy sig (lazy jt) (JAtom s)
                !argexs = case sym.strsig of
                    S ss -> zipWith argexp ss argbinds
                    _    -> map Binding.jex argbinds
                argexp s bind
                    | Strictness.isStrict s = (strictBind bind).jex
                    | otherwise             = Binding.jex bind
        thisName = "this"  ++ show sym.sid
        thisBind = Bind RBoxed sym.typ extend (JAtom thisName)
        innerbinds = insert binds sym thisBind

    stmts <- if hasworker
                then compiling sym (genFunction sym (rmode sym.rkind) workerArgs innerbinds)
                else compiling sym (genFunction sym moder        (reverse rArgs) innerbinds)

    let thisAssign = JLocal (JMember {attr = attrFinal, jtype=extend, name = thisName,
                                        init = Just (JAtom "this")})
        rMethod = JMethod {attr = attrs [JPublic, JFinal],
                            gargs = [],
                            jtype = if lazyr then lazy rjt else rjt,
                            name = "r",
                            args = rArgs,
                            body = if hasworker then invokeWorker ftargs
                                    else JBlock (thisAssign:stmts)}

        worker = JMethod {attr = attrs [JPublic, JFinal],
                          gargs = [],
                          jtype = workerType,
                          name = workerName,
                          args = workerArgs,
                          body = JBlock (thisAssign:stmts)}
        // eWorker = if extworker then [worker] else []
        iWorker = if hasworker then [worker] else []
        // fclass = JClass {attr = attrs [JPublic, JStatic, JFinal],
        //                    jtype = dftype, extend = Just extend, implement=[], defs}
        // defs = constraints ++ single ++ [constructor, rMethod, nMethod] ++ iWorker

        // flocal = JMember {attr = attrFinal, jtype = extend, name = name.base,
        //            init = Just mkInner}
        // mkInner = JNewClass extend [] (rMethod:iWorker)
        fclass = JClass {attr = attrFinal,
                            jtype = dftype,
                            extend = Just extend,
                            implement=[], defs}
        defs = constraints ++ [constructor, rMethod] ++ iWorker
    stio ([JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment (nicer x g),
        fclass,
        ])

topFun (sym@SymV {expr = Just x}) binds = do
    g <- getST

    let argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava.argNames
        argAttr = if (sym.rkind `band` 8) == 0 then attrFinal else 0
        bnds = sym.typ.bound                        // [a,b,c]
        (rty, atys) = U.returnTypeN sym.depth sym.typ.rho
        subfun = do
            rjt  <- rhoJT rty
            ajts <- mapSt subSigmaJT atys
            // extend      <- sigmaJT sym.typ
            constraints <- mapSt  (curry makeConstraintDef) (zip sym.typ.rho.context ctxNames)
            constrargs  <- mapSt  (curry makeConstraintArg) (zip sym.typ.rho.context argNames)
            workerArgs <- argDef argAttr sym.strsig atys argNames
            uArgs      <- argDef argAttr U atys argNames

            stio (rjt, ajts, constraints, constrargs, workerArgs, uArgs)

    (rjt, ajts, constraints, constrargs, workerArgs, uArgs)  <- subfun

    let extend = Ref (JName "" ("Fun" ++ show sym.depth))
                    (ajts ++ [rjt])
    let name   = U.javaName g sym.name                        // X.foo
        fname  = JName "" name.base                                 // foo
        ftargs = map targ bnds                                // <a,b,c>
        ftype  = (Ref (fname) ftargs)                         // Ffoo<a,b,c>
        dftype = defining ftype

        constructor = JConstr {attr = attrs [JPrivate],
                                jtype = ftype,
                                args = constrargs,
                                body = JBlock (take (length constraints)
                                                (zipWith JAssign
                                                    (map JAtom ctxNames)
                                                    (map JAtom argNames)))}

        lazyr = sym.rkind `band` 1 == 0
        moder = if lazyr then RLazy else RBoxed
        hasworker = sym.rkind `band` 6 != 0
        extworker = hasworker `and` length constraints == 0
        single
            | length constraints == 0 = [JMember {
                                attr = attrs [JFinal, JPrivate, JStatic],
                                jtype = erased ftype,
                                name = "single",
                                init = Just (JNew (erased ftype) [])}]
            | otherwise = []
        castedSingle = JReturn (JCast ftype (JAtom "single"))
        newInstance  = JReturn (JNew  ftype (take (length constraints) (map JAtom argNames)))

    let rArgs      = reverse uArgs
        workerType = case rmode sym.rkind of
                                RLazy  -> lazy rjt
                                RBoxed -> rjt
                                RNative -> strict rjt
        workerName = case workerMethod g sym of
                JAtom s -> s
                JStMem {jname = JName _ s} -> s
                _ -> error "workerName: bad expression"
        invokeWorker ftargs = JBlock [return]
            where
                return = JReturn (toMode moder worker).jex
                worker = Bind (rmode sym.rkind) (ForAll [] rty) workerType
                                                            (JInvoke workerex argexs)
                workerex = case workerMethod g sym of
                    w@JStMem {jname} -> w.{targs=ftargs}
                    w@JAtom _ -> w
                    _ -> error "workerex: bad expression"
                argbinds = zipWith bind (take sym.depth argNames) (zip ajts atys)
                bind s (jt, sig) = Bind RLazy sig (lazy jt) (JAtom s)
                !argexs = case sym.strsig of
                    S ss -> zipWith argexp ss argbinds
                    _    -> map Binding.jex argbinds
                argexp s bind
                    | Strictness.isStrict s = (strictBind bind).jex
                    | otherwise             = Binding.jex bind
        thisBind = Bind RBoxed sym.typ extend (JAtom "this")
        innerbinds = insert binds sym thisBind
    // when (inner `and` not (null constraints)) do
    //     U.warn sym.pos ("inner " ++ nice sym g ++ " has constraints")
    stmts <- if hasworker
                then compiling sym (genFunction sym (rmode sym.rkind) workerArgs binds)
                else compiling sym (genFunction sym moder        (reverse rArgs) binds)
    let rMethod = JMethod {attr = attrs [JPublic, JFinal],
                            gargs = [],
                            jtype = if lazyr then lazy rjt else rjt,
                            name = "r",
                            args = rArgs,
                            body = if hasworker then invokeWorker ftargs else JBlock stmts}
        nMethod = JMethod {attr = attrs [JPublic, JStatic,
                                            if null single then JStatic else JUnchecked],
                            gargs = ftargs,
                            jtype = ftype,
                            name = "n",
                            args = constructor.args,
                            body = JBlock [if length constraints == 0
                                            then castedSingle else newInstance]}
        worker = JMethod {attr = attrs [JPublic, JFinal,
                                    if extworker then JStatic else JFinal],
                          gargs = if extworker then ftargs else [],
                          jtype = workerType,
                          name = workerName,
                          args = workerArgs,
                          body = JBlock stmts}
        eWorker = if extworker then [worker] else []
        iWorker = if extworker then [] else if hasworker then [worker] else []
        fclass = JClass {attr = attrs [JPublic, JStatic, JFinal],
                            jtype = dftype, extend = Just extend, implement=[], defs}
        defs = constraints ++ single ++ [constructor, rMethod, nMethod]
                            ++ iWorker ++ eWorker

    stio ([JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment (nicer x g),
        fclass,
        ])
topFun _ _ = error "topFun: no function"


returnTau sigma = (fst • U.returnType) (Sigma.rho sigma)
sigmaTau f (ForAll [] (RhoTau [] ty)) = f ty
sigmaTau f _ = Nothing

/// enumeration constants for the native interface kind
data NIKind = NIOp | NINew | NIMethod | NICast | NINewArray | NIStatic
derive Eq NIKind

/**
 * determine kind of java expression to generate, based on the item information
 */
niKind "new"      = NINew
niKind #^\W+$#    = NIOp
niKind #^\w+$#    = NIMethod
niKind #^\(.+\)$# = NICast
niKind #.+\[\]$#  = NINewArray
niKind _          = NIStatic

niCast (m~#^\((.+)\)$#) = m.group 1
niArr s = strhead s (length s - 2)
niSpecial ty
    | Just _ <- U.isUnit ty      = true
    | Just _ <- U.isMaybe ty     = true
    | Just _ <- U.isException ty = true
    | Just _ <- U.isIO ty        = true
    | otherwise = false

/**
 * check native method
 */
methClass (sym@SymV {nativ = Just item, pur=true, typ})
    | Just (_, tau) <- U.isIO (returnTau typ) = do
        g <- getST
        U.error sym.pos ("contradictory declaration, " ++ nice sym.name g
            ++ " cannot be pure and have a return type of " ++ nicer (returnTau typ) g)
        stio []
    | Just _ <- U.isUnit (returnTau typ) = do
        U.error sym.pos ("void " ++ item ++ "(...) cannot be a pure function")
        stio []
    | (_, [sig]) <- U.returnType typ.rho,
      Just _ <- sigmaTau U.isUnit sig = do
        U.error sym.pos (item ++ "() cannot be a pure function")
        stio []
methClass (sym@SymV {nativ = Just item, pur=false, typ})
    | Nothing <- U.isIO (returnTau typ) = do
        g <- getST
        U.error sym.pos (nice sym.name g
            ++ " has an illegal return type for a method that is not pure,"
            ++ " perhaps  " ++ nicer (sttyp (returnTau typ)) g
            ++ "  would work")
        stio []
    where
        sttyp tau
            | [s] <- keys (U.freeTauTVars [] Nil tau) = TApp (TApp st (tv s)) tau
            | otherwise = TApp (TApp st (tv "s")) tau
            where
                st   = TCon {pos=sym.pos, name = TName pPrelude "ST"}
                tv s = TVar {pos=sym.pos, var = s, classes = []}

methClass (sym@SymV {nativ = Just item, pur, typ}) = do
        let
            nik = niKind item
        ok1 <- argsOk nik atys
        ok2 <- retOk  nik rty
        if ok1 `and` ok2 then methCode sym else stio []
    where
        (rty, atys) = U.returnType typ.rho
        isMBU tau | Just x <- U.isMaybe tau, Just _ <- U.isUnit x = true
                  | Just x <- U.isException tau = isMBU x
                  | Just (_, x) <- U.isIO tau = isMBU x
                  // Just _ <- U.isUnit tau = true
                  | otherwise             = false
        validIOtype tau | Just (_, x) <- U.isIO tau = case U.isUnit x of
                                                        Just _ -> true
                                                        _ -> validXtype x
                        | otherwise = validXtype tau
        validXtype tau  | Just x <- U.isException tau = case U.isUnit x of
                                                        Just _ -> true
                                                        _ -> validMBtype x
                        | otherwise = validMBtype tau
        validMBtype tau | Just x <- U.isMaybe tau = not (niSpecial x)
                        | otherwise = not (niSpecial tau)
        validCaftype tau | Just (_, x) <- U.isIO tau = validMBtype x
                         | otherwise = validMBtype tau
        validNIArg sigma | maybe true (const false) (sigmaTau Just sigma) = do
            g <- getST
            U.error sym.pos (nice sigma g ++ " is not valid for native method arguments")
            stio false
        validNIArg sigma = do
            g <- getST
            let tau = maybe undefined id (sigmaTau Just sigma)
                xio = isJust (U.isIO tau) `or` isJust (U.isException tau)
            if isMBU tau `or` isJust (U.isUnit tau)
                then do
                    U.error sym.pos ("type  " ++ nice tau g
                        ++ "  is illegal for a native function argument,"
                        ++ " () may only appear to indicate an empty argument list.")
                    stio false
                else if xio
                    then do
                        U.error sym.pos ("Exception, ST or IO values have a special meaning"
                            ++ " in the native interface and must not appear in"
                            ++ " argument position.")
                        stio false
                    else stio true
        retOk _ tau | isMBU tau = do
            U.error sym.pos ("The construct  Maybe ()  makes no sense in a native return type.")
            stio false
        retOk _ tau | not (validIOtype tau) = do
            U.error sym.pos ("Illegal nesting of IO, ST, Exception, Maybe and () in the return type.")
            stio false
        retOk NIStatic tau | null atys, not (validCaftype tau) = do
            U.error sym.pos ("A static member may not be void and it certainly throws no exceptions.")
            stio false
        retOk _ _ = stio true
        argsOk NIOp [x]   = validNIArg x
        argsOk NIOp [x,y] = liftM2 and (validNIArg x) (validNIArg y)
        argsOk NIOp _ = do
            g <- getST
            U.error sym.pos ("Java operator " ++ nice sym.name g ++ " demands 1 or 2 operands.")
            stio false
        argsOk kind [] | kind `elem` [NINew, NIMethod, NICast] = do
            g <- getST
            U.error sym.pos ("Illegal type for " ++ nice sym.name g ++ ", must be function type")
            stio false
        argsOk NICast [x]
            | Nothing <- sigmaTau U.isUnit x = stio true
        argsOk NICast _ = do
            U.error sym.pos ("A java type cast must have exactly one argument which is not ()")
            stio false
        argsOk kind [x] | kind != NIMethod, Just _ <- sigmaTau U.isUnit x  = stio true
        argsOk NIMethod (this:xs) = do
            g <- getST
            sjt <- sigmaJT this
            if maybe false (U.isJavaType g) (sigmaTau Just this)
                then if maybe true (const false) (isPrimitive sjt)
                    then do
                        oks <- mapSt validNIArg xs
                        stio (fold and true oks)
                    else do
                        U.error sym.pos ("Cannot invoke instance method " ++ item
                            ++ " on primitive type")
                        stio false
                else do
                    U.error sym.pos ("Cannot invoke instance method " ++ item
                            ++ " on non native type")
                    stio false
        argsOk NINewArray xs | length xs > 1 = do
            U.error sym.pos ("Array must have only one argument.")
            stio false
        argsOk _ xs = do
            oks <- mapSt validNIArg xs
            stio (fold and true oks)
methClass _  = undefined

wrapped (sym@SymV {nativ = Just item}) = niSpecial rty
    where
        (rty, sigmas) = U.returnType sym.typ.rho
wrapped _ = error "wrapped: no symv"

/**
 * Tell if a native function must be called through it's wrapper.
 *
 * Plain types and Maybe types can be called directly
 */
wrappedOnly (sym@SymV {nativ = Just item}) = niSpecial rty && isNothing (U.isMaybe rty)
    where
        (rty, sigmas) = U.returnType sym.typ.rho
wrappedOnly sym = error "wrappedOnly - no native function"


/// returns a binding for a direct call of a native method
nativeCall (sym@SymV {nativ = Just item}) abinds = do
        g <- getST
        let
            taus = [ tau | Just tau <- map (sigmaTau Just) sigmas ]
            brty = baserty rty
            bsig = ForAll [] (RhoTau [] brty)
            args | [tau] <- taus, Just _ <- U.isUnit tau = stio []   // no arguments
                 | otherwise = mapSt (curry argEx) (zip abinds taus)
        bjt <- tauJT brty
        let jrty = strict  bjt
            retmode = maxStrict jrty
        as <- args
        stio (Bind retmode bsig jrty (call jrty as))
    where
        (rty, sigmas) = U.returnType sym.typ.rho
        argEx bind tau
            | Just x <- U.isMaybe tau = do
                    jt <- tauJT x
                    stio (JQC checknothing (JAtom "null") (justm1 x jt).jex)
            | otherwise = stio sbind.jex
            where
                sbind = toMode RNative bind
                checknothing = JBin con "==" (JAtom "0")
                con = JInvoke (JExMem sbind.jex "_c") []
                justm1 x jt = toMode RNative (Bind RLazy (ForAll [] (RhoTau [] x)) jt m1ex)
                m1ex = JExMem just "m1"
                just = JInvoke (JExMem sbind.jex "_Just") []
        baserty r
            | Just (_, x) <- U.isIO r   = baserty x
            | Just x <- U.isException r = baserty x
            | Just x <- U.isMaybe r     = baserty x
            | Just _ <- U.isUnit r      = r
            | otherwise                 = r
        call jrty args = case niKind item of
            NIOp -> case args of
                [a,b] -> JBin a item b
                [a]   -> JUnop item a
                _     -> JAtom "null"           // error was flagged before
            NINew -> JNew jrty args
            NICast -> case args of
                [a] -> JInvoke (JAtom item) args    // was: JCast (Ref (JName "" item) []) a
                _   -> JAtom "null"
            NIMethod -> case args of
                (a:as) -> case item of
                    "clone" -> JCast jrty (JInvoke (JExMem a item) as) // due to java brain damage
                    _ -> JInvoke (JExMem a item) as
                _ -> JAtom "null"
            NINewArray -> JNewArray  (Ref (JName "" (niArr item)) []) (head args)
            NIStatic -> case sigmas of
                (_:_) -> JInvoke (JAtom item) args
                _ -> JAtom item

wrapCode jreturn rtau (sym@SymV {nativ = Just item}) abinds
    | Just (stau, atau) <- U.isIO rtau = do
        g <- getST

        sjt     <- tauJT stau          // type #1 for parameterization of ST s a
        ajt     <- tauJT atau          // type #2 for parameterization of ST s a
        let ssig    = ForAll [] (RhoTau [] stau)
            mktup x = JReturn (JInvoke (JStMem (JName "Prelude.TTuple2" "mk") [ajt, sjt])
                                        [x, JAtom "_state"])
        rbody <- wrapCode mktup atau sym abinds

        let tuple   = TApp (TApp (TCon {pos=sym.pos, name = TName pPrelude "(,)"}) atau) stau
            frho    = RhoFun [] ssig (RhoTau [] tuple)   // s -> (a,s)
        tjt     <- tauJT tuple
        fjt     <- rhoJT frho
        let ret     = jreturn mkST
            mkST    = JInvoke (JStMem (JName "Prelude.TST" "mk") [sjt, ajt]) [fun]
            fun     = JNewClass fjt [] [rMethod]

            rMethod = JMethod {attr = attrs [JFinal, JPublic], gargs=[],
                               jtype = tjt, name = "r",
                               args = [(attrFinal, ssig, lazy sjt, "_state")],
                               body = JBlock rbody}
        stio [ret]
    | Just mtau <- U.isException rtau = do
        g          <- getST

        mjt     <- tauJT mtau
        xjt     <- tauJT (TCon {pos = sym.pos, name = TName pPrelude "JException"})
        let right x = jreturn (JInvoke (JStMem (JName "Prelude.TEither.DRight" "mk")
                                               [xjt, mjt])
                                       [x])
            left    = jreturn (JInvoke (JStMem (JName "Prelude.TEither.DLeft"  "mk")
                                               [xjt, mjt])
                                       [JInvoke (JStMem (JName "Boxed" "mk")
                                                        [head xjt.targs])
                                                [JAtom "ex"]])

        code       <- wrapCode right mtau sym abinds
        let try     = JBlockX "try" code
            catch   = JBlockX "catch (Exception ex)" [left]
        stio [try, catch]
    | Just atau <- U.isMaybe rtau = do
        g          <- getST
        ajt        <- tauJT atau
        bind       <- nativeCall sym abinds
        let mkmb    = JInvoke (JStMem (JName "Prelude" "_toMaybe") [bind.jtype]) [bind.jex]
        stio [jreturn mkmb]
    | Just _ <- U.isUnit rtau = do
        g          <- getST
        bind       <- nativeCall sym abinds
        let unit    = JStMem (JName "Prelude.TUnit" "Unit") []
        stio [JEx bind.jex, jreturn unit]
    | otherwise = do
        g          <- getST
        bind       <- nativeCall sym abinds
        stio [jreturn (toBoxed bind).jex]
wrapCode jreturn rtau sym abinds = error "wrapCode: no SymV"


/**
 * code for native functions and/or members
 */
methCode (sym@SymV {nativ = Just item})
    | arity >= 0 = do
        g              <- getST
        rjt            <- tauJT rty
        ajts           <- mapSt sigmaJT atys
        extend         <- sigmaJT sym.typ
        rArgs          <- argDef attrFinal U atys argNames
        wArgs          <- argDef attrFinal (S allStrict) atys argNames
        let bnds        = sym.typ.bound
        let name        = U.javaName g sym.name                        // X.foo
            fname       = /*U.fName*/ name                                 // X.Ffoo
            ftargs      = map targ bnds                                // <a,b,c>
            ftype       = (Ref (fname) ftargs)                         // Ffoo<a,b,c>
            dftype      = defining ftype
            args        = if haswrapper then wArgs else rArgs
            haswrapper  = arity > 0 `and` wrapped sym `or` (not (null bnds))
            callWrapper = (toBoxed bndWrapper).jex
            bndWrapper  = bndWcode invWrapper
            invWrapper  = JInvoke (JStMem (U.memberOf name "w") ftargs)
                                (map (Binding.jex • strictBind • argBind) rArgs)
            jreturn     = if arity > 0 then JReturn else JEx
            bndWcode  x = Bind (if wrapped sym then RBoxed else maxStrict rjt)
                            (ForAll [] (RhoTau [] rty)) (strict rjt) x

        wcode          <- if wrapped sym
                                then wrapCode jreturn rty sym (map argBind args)
                                else do
                                    bind <- nativeCall sym (map argBind args)
                                    stio [jreturn bind.jex]


        let rMethod     = JMethod {attr = attrs [JPublic, JFinal],
                                   gargs = [], jtype = rjt, name = "r", args = reverse rArgs,
                                   body = JBlock rBody}
            rBody       = if haswrapper then [JReturn callWrapper]
                            else case wcode of
                                [JReturn x] = [JReturn (toBoxed (bndWcode x)).jex]
                                _ -> wcode
            wrappers    = if haswrapper then [wrapper] else []
            wrapper     = JMethod {attr = attrs [JPublic, JStatic, JFinal],
                                gargs = ftargs, jtype = strict rjt, name = "w",
                                args = wArgs, body = JBlock wcode}
            single      = JMember {attr = attrs [JFinal, JPrivate, JStatic],
                                jtype = erased dftype,
                                name = "single",
                                init = Just (JNew (erased dftype) [])}
            constructor = JConstr {attr = attrs [JPrivate],
                                jtype = dftype,
                                args = [],
                                body = JBlock []}
            castedSingl = JReturn (JCast ftype (JAtom "single"))
            nMethod     = JMethod {attr = attrs [JPublic, JStatic, JUnchecked],
                            gargs = ftargs, jtype = ftype,
                            name = "n", args = [],
                            body = JBlock [castedSingl]}
            fclass      = JClass {attr = attrs [JPublic, JStatic, JFinal],
                                  jtype = dftype, extend = Just extend, implement=[], defs}
            defs        = [single, constructor, rMethod, nMethod] ++ wrappers
            unex  [(JEx x)] = (toBoxed (bndWcode x)).jex
            member = JMember {attr = attrs [JPublic, JStatic, JFinal],
                                jtype = rjt,
                                name = (U.javaName g sym.name).base,
                                init = Just (unex wcode)}
            // boxit  = (toBoxed bind).jex
            // bind   = Bind RNative sym.typ (strict rjt) (unex wcode)

        stio ([JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
               JComment (nicer sym.typ g),
               JComment item,
               if arity > 0 then fclass else member])
    | ForAll [] (RhoTau [] (TCon {name})) <- sym.typ = do
        g <- getST
        symt <- U.findT name
        jtype <- sigmaJT sym.typ
        case symt.typ of
            ForAll [] (RhoTau [] (TCon {name})) | Just jtname <- symt.nativ = do
                let
                    member = JMember {attr = attrs [JPublic, JStatic, JFinal],
                                jtype,
                                name = (U.javaName g sym.name).base,
                                init = Just boxit}
                    boxit  = (toBoxed bind).jex
                    bind   = Bind RNative sym.typ (strict jtype) (JAtom item)
                stio [JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
                      JComment (nicer sym.typ g),
                      member]
            other -> do
                U.error sym.pos ("illegal type for a native item, it must be a plain immutable java type")
                stio []
    | otherwise = do
        g <- getST
        U.error sym.pos ("can not compile " ++ nice sym g)
        stio [JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
              JComment (nicer sym.typ g),
              JComment item]
    where
        (rty, atys) = U.returnType sym.typ.rho
        arity       = length atys


methCode _ = undefined

/**
 * runs action with symbol in the current compiling environment
 */
compiling sym action = do
    g <- getST
    changeST Global.{gen <- GenSt.{genEnv <- (sym:)}}
    r <- action
    changeST Global.{gen <- GenSt.{genEnv <- tail}}
    stio r

/**
 * - invokes 'genLambda' to generate code for a function
 * - wraps the code in a while statement for tail calling functions
 */
genFunction (sym@SymV {expr = Just ex}) rmode args binds = do
        g <- getST
        // let oldsym = g.genSym
        // changeST Global.{gen <- GenSt.{genSym = sym}}
        code <- if (sym.rkind `band` 8) == 0
            then genLambda rmode ex args binds
            else do
                let
                    fargs = [ (attrFinal, sig, jt, nm ++ "f") | (_,sig,jt,nm) <- args ]
                    decls = [ JMember { attr = attrFinal,
                                        jtype = jt,
                                        name = nm ++ "f",
                                        init = Just (JAtom nm)} | (_,sig,jt,nm) <- args ]
                    stmts = map JLocal decls
                code <- genLambda rmode ex fargs binds
                stio [JCond "tailrecursion: while" (JAtom "true") (stmts ++ code)]
        // changeST Global.{gen <- GenSt.{genSym = oldsym}}
        stio code

/**
 * This data structure describes mode, java type and java expression associated with
 * some frege item. The task of code generation is to create, combine and
 * manipulate such bindings. Many code generating functions will take
 * a ('Tree' 'Symbol' 'Binding') of current bindings as last parameter.
 */
data Binding = Bind {mode :: RMode, ftype :: Sigma, jtype :: JType, jex :: JExpr}
instance Nice Binding where
    nice (Bind {mode, ftype, jtype, jex}) g = "Bind {" ++ show mode ++ ", "
                                            ++ ftype.nice g ++ ", "
                                            ++ showJty jtype ++  ", "
                                            ++ showJex jex ++ "}"

/// tell how strict this java type can get
maxStrict jt = case strict jt of
    Nativ _ _  -> RNative
    _          -> RBoxed

/// bring a java expression to boxed mode
toBoxed (bind@Bind {mode=RNative, jex = JExMem jx "j"}) = bind.{mode = RBoxed, jtype <- boxed, jex = jx}
toBoxed (bind@Bind {mode=RNative, jtype}) = case boxed jtype of
    bt@Ref (JName "" bx) t -> bind.{mode=RBoxed, jtype = bt,
                                jex = JInvoke (JStMem (JName bx "mk") t) [bind.jex]}
    other -> bind.{mode=RBoxed, jtype = other}      // questionable whether this is right
toBoxed (bind@Bind {mode=RLazy}) = bind.{mode=RBoxed, jtype <- boxed,
                                    jex =JInvoke (JExMem bind.jex "_e") []}
toBoxed bind = bind

/// bring a java expression to desired strictness mode
toMode RLazy (bind@Bind {mode})
    | mode == RNative = toBoxed bind
    | otherwise = bind
toMode RBoxed bind = toBoxed bind
toMode RNative (bind@Bind {mode}) = case maxStrict bind.jtype of
    RBoxed -> toBoxed bind
    RNative
        | mode == RLazy  =  bind.{mode=RNative, jtype <- strict,
                                    jex = JExMem (toBoxed bind).jex "j"}
        | mode == RBoxed =  bind.{mode=RNative, jtype <- strict,
                                    jex = JExMem bind.jex "j"}
        | otherwise = bind
    _ -> error "toMode RNative: unexpected result from maxStrict"

/**
 *  make a binding strict
 */
strictBind bind = toMode RNative bind
boxedBind  bind = toBoxed bind
notStrict (bind@Bind {mode=RNative}) = toBoxed bind
notStrict bind = bind
notLazy   (bind@Bind {mode=RLazy}) = toBoxed bind
notLazy   bind = bind

/**
 * [usage] @realize bind@
 *
 * code to create a local variable and an updated bind
 */
realize name bind
    | cheap (Binding.jex bind) = stio (bind, [])
    | otherwise = do
        u <- U.uniqid
        g <- getST
        let vname = m name ++ underline ++ show u  // must correspond to U.javaName
            m "$" = "$"
            m s   = mangled s
            underline = if name == "$" then "" else "_"
            member = JMember {attr = attrFinal,
                                jtype = Binding.jtype bind,
                                name = vname,
                                init = Just (Binding.jex bind)}
            nbind = bind.{jex = JAtom vname}
        stio (nbind, [sComment ("realize " ++ name ++ " bound to " ++ nice bind g), JLocal member])

/// show a java expression
showJex jex | cheap jex = PP.pretty 1000 (anno jex)
            | otherwise = "complicated java expression"
showJty jty = PP.pretty 1000 (anno jty)

/// make a statement comment
sComment = (JLocal • JComment)

/**
 * [usage] @match pattern bind continuation bindings@
 * [returns] a list of java statements and an updated binding
 * generate code and/or extend current @bindings@ that performs and/or reflects
 * a match of @pattern@
 * against the java expression in @bind@ and generate the code for a successful match
 * by applying @continuation@ to the extended bindings.
 *
 * Generated code will look like this:
 * > comment
 * > auxiliary local definitions
 * > if (patternmatches) {
 * >           code generated by continuation
 * > }
 * There does not have to be an @if@ or any other code at all, for example when
 * the pattern is irrefutable. The code generated by the continuation *must* return,
 * if the control flow reaches the closing brace of the if this will be
 * an indication that the pattern match failed.
 */
match assert (PVar {var}) bind cont binds = do
        vsym <- U.findV (Local var)
        if vsym.strsig.isStrict then strictVar vsym else lazyVar vsym
    where
        strictVar vsym = do
            g <- getST
            (rbind, code) <- realize (Symbol.name vsym).base (notLazy bind)
            let stmt = if null code
                    then [sComment ("bind  " ++ nice (Symbol.name vsym) g
                                        ++ "  to  " ++ showJex rbind.jex)]
                    else code
                nbinds = insert binds vsym rbind
            rest <- cont nbinds
            stio (rbind, stmt++rest)
        lazyVar vsym = do
            g <- getST
            let nbinds = insert binds vsym bind
                comment = "bind  " ++ nice (Symbol.name vsym) g ++ "  to  " ++ nice bind g
            rest <- cont nbinds
            stio (bind, sComment comment:rest)

match assert (p@PAt {pat,var}) bind cont binds = do
        g <- getST
        prm <- patternRMode pat
        vsym <- U.findV (Local var)
        let vrm = if vsym.strsig.isStrict then RBoxed else RLazy
            rm = min prm vrm
            ourBind = toMode rm bind
            comment = sComment ("match " ++ nice p g ++ " with " ++ nice ourBind g)
        (rbind, code1) <- realize (Symbol.name vsym).base ourBind
        let nbinds = insert binds vsym rbind
        (xbind, code2) <- match assert pat rbind cont nbinds
        stio (xbind, comment : code1++code2)

match assert (pat@PLit {kind=LBool, value}) bind cont binds = do
    g <- getST
    // (bind,code) <- realize "$" (notLazy bind)
    body <- cont binds
    let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
        sbnd = strictBind bind
        jex = if value == "true" then sbnd.jex else JUnop "!" sbnd.jex
        ifc = if assert then JAssert jex : body else [JCond "if" jex body]
    stio (bind, comment:ifc)

match assert (pat@PCon {pos,qname,pats}) bind cont binds = do
        // g <- getST
        symd <- U.findD qname                   // forall a.a -> List a -> List a
        symt <- U.findT symd.name.tynm          // forall a.List a
        if symt.enum then matchEnum symd symt
            else if symt.product then matchProd    symd symt // pat bind cont binds
                else matchVariant symd symt // pat bind cont binds
    where
        comment g = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
        matchEnum :: Symbol -> Symbol -> StG (Binding, [JStmt])
        matchEnum symd symt = do
            g <- getST
            (bind, code1) <- realize "$" bind
            body  <- cont binds
            let sbnd = strictBind bind
                comp = (JBin sbnd.jex "==" (JAtom (show symd.cid)))
                ifc  = if assert then JAssert comp : body else [JCond "if" comp body]
            stio (bind, (comment g:code1) ++ ifc)

        matchVariant :: Symbol -> Symbol -> StG (Binding, [JStmt])
        matchVariant symd symt = do
            g <- getST

            let box1 = boxedBind bind                     // List b
                tree = U.unifySigma g symt.typ bind.ftype   // a -> b

            rho <- U.substRho tree symd.typ.rho       // b -> List b -> List b
            (boxd, code1) <- realize "$" box1
            pss <- mapSt patternStrictness pats
            datajt <- sigmaJT symt.typ

            let smode = any Strictness.isStrict pss
                cname = "_" ++ mangled qname.base
                vbind = Bind RBoxed boxd.ftype
                        (variantType g datajt symd).{targs = boxd.jtype.targs}
                        (JInvoke (JExMem boxd.jex cname) [])

            (varb, code2) <- realize "$" vbind

            let bcon = if smode then varb else vbind
                (_,sigs) = U.returnType rho               // [b, List b]
            sjts <- mapSt sigmaJT sigs
            let sigssjts = zip sigs sjts
                pbinds = [ Bind RLazy sig (lazy sjt) (JExMem (bcon.jex) m)
                                                    | ((sig, sjt), m) <- zip sigssjts memNames ]

            rest <- matches assert pats pbinds cont binds

            let comp = (JBin (JInvoke (JExMem boxd.jex "_c") [])
                                    "=="
                                    (JAtom (show symd.cid)))
                ifc = if assert then JAssert comp : body else [JCond "if" comp body]
                body = if smode then code2 ++ rest else rest
            stio (boxd, (comment g : code1) ++ ifc)

        matchProd :: Symbol -> Symbol -> StG (Binding, [JStmt])
        matchProd symd symt = do
            g <- getST
            let tree = U.unifySigma g symt.typ bind.ftype   // a -> b
            rho <- U.substRho tree symd.typ.rho       // b -> List b -> List b
            (boxd, code1) <- realize "$" (boxedBind bind)
            pss <- mapSt patternStrictness pats

            let smode = any Strictness.isStrict pss
                bcon = if smode then boxd else bind
                (rty,sigs) = U.returnType rho               // [b, List b]
            rjt <- tauJT rty
            sjts <- mapSt subSigmaJT sigs
            let sigjts = sjts ++ [rjt]
                sigssjts = zip sigs sjts
                field prod f sig = JInvoke applya [Binding.jex prod]
                    where
                        applya = JExMem mk "a"
                        mk = JInvoke mkfun []
                        prodnm = "Product" ++ show (length sigs) ++ ".Get" ++ show f
                        mkfun = JStMem (JName prodnm ("n")) sigjts

                pbinds
                    | smode = [ Bind RLazy sig (lazy sjt) (JExMem (bcon.jex) m)
                                    | ((sig, sjt), m) <- zip sigssjts memNames ]
                    | otherwise = [ Bind RLazy sig (lazy sjt) (field bcon f sig)
                                    | ((sig, sjt), f) <- zip sigssjts (1..length sigs) ]
                // make sure refutable patterns are matched first so that
                // realization of strict variables does not occur outside an if
                ppbs = (reverse • sortBy (comparing (T.patternRefutable g • fst))) (zip pats pbinds)
            rest <- matches assert (map fst ppbs) (map snd ppbs) cont binds
            let body = if smode then code1 ++ rest else rest
            stio (bcon, comment g: body)

match assert (pat@PLit {kind=LString, value}) bind cont binds = do
    g <- getST
    (bind,code) <- realize "$" (notLazy bind)
    body <- cont binds
    let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
        sbnd = strictBind bind
        jex = JInvoke (JExMem (JAtom value) "equals") [sbnd.jex]
        ifc = if assert then JAssert jex : body else [JCond "if" jex body]
    stio (bind, (comment:code) ++ ifc)

match assert (pat@PLit {kind, value}) bind cont binds
    | kind `elem` [LChar, LInt, LLong, LDouble, LFloat] = do
        g <- getST
        (bind,code) <- realize "$" (notLazy bind)
        body <- cont binds
        let comment = sComment ("match  " ++ nice pat g
                                    ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            jex = JBin (JAtom value) "==" sbnd.jex
            ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ ifc)
    | kind == LRegex = do
        g <- getST
        (bind,code) <- realize "$" (notLazy bind)
        body <- cont binds

        let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            lit = Lit {pos = pat.pos, kind = LRegex, value, typ = Just (TY.sigRegex)}
        xbnd <- genExpr false RNative lit binds

        let matcher = JInvoke (JExMem xbnd.jex "matcher") [sbnd.jex]
            jex = JInvoke (JExMem matcher "find") []
            ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ ifc)

match assert (pat@PMat {pos, var, value}) bind cont binds = do
        g <- getST
        vsym <- U.findV (Local var)
        (bind,code) <- realize "$" (notLazy bind)
        mjt <- sigmaJT (TY.sigMatcher)
        let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            lit = Lit {pos, kind = LRegex, value, typ = Just (TY.sigRegex)}

        xbnd <- genExpr false RNative lit binds
        let mbnd = Bind RNative (TY.sigMatcher) (strict mjt)
                    (JInvoke (JExMem xbnd.jex "matcher") [sbnd.jex])
        (mbnd,code2) <- realize var mbnd
        body <- cont (binds.insert vsym mbnd)

        let  jex = JInvoke (JExMem mbnd.jex "find") []
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ code2 ++ ifc)

match assert (PAnn {pat})    bind cont binds = match assert pat bind cont binds
match assert (PStrict {pat}) bind cont binds = match assert pat bind cont binds
match _ pat b c bs = do
    g <- getST
    stio (b, [JError ("match  " ++ nice pat g ++ "  with  " ++ showJex (Binding.jex b))])

/**
 * A variant of 'match' that matches the components of a product against a pattern
 *
 * @pat@ must be a constructor application whose constructor is the same
 * as given in @con@
 */
matchCon assert (PCon {pos,qname, pats}) con bexs cont binds = do
        g <- getST
        sym <- U.findD qname
        if sym.sid != Symbol.sid con
            then do
                U.fatal pos ("matchCon: " ++ nice qname g ++ " against " ++ nice con g)
            else do
                // make sure refutable patterns are matched first so that
                // realization of strict variables does not occur outside an if
                ppbs = (reverse • sortBy (comparing (T.patternRefutable g • fst))) (zip pats bexs)
                matches assert (map fst ppbs) (map snd ppbs) cont binds

matches assert []     []     cont binds = cont binds
matches assert (p:ps) (b:bs) cont binds = do
        (_, code) <- match assert p b (matches assert ps bs cont) binds
        stio code
matches assert _ _ _ _ = Prelude.error "matches: cannot happen when compiler is sane"

/**
 * Code for outer lambdas.
 *
 * Set's up a 'Binding' for the corresponding method argument and
 * 'match'es its pattern against it with the enclosed expression as continuation.
 */
genLambda rm (Lam {pat, env, ex}) ((_, sig, jt, s) : args) binds = with env do
    g <- getST
    let komplett = T.patsComplete g [pat]
        badguard = T.openCaseWhen g ex
        assert = isNothing komplett
        // mustthrow = not assert `and` isNothing badguard
        margs = map JAtom [show ((last g.genEnv).name.nice g),
                                                show (getpos pat)] ++ [JAtom s]
        jthrow = [JThrow (JNew (Ref (JName "RT" "NoMatch") []) margs)]

    (_, code) <- match assert pat (Bind (jtRmode jt) sig jt (JAtom s))
                           (genLambda rm ex args) binds
    case komplett of
        Just p -> do
            U.warn (getpos pat) ("function pattern is refutable, "
                            ++ "consider adding a case for  "
                            ++ nice p g)
            stio (code ++ jthrow)
        _ -> case badguard of
            Just (Left x) -> do
                U.warn (getpos x) ("guard (" ++ nice x g ++ ") may evaluate to false.")
                stio (code ++ jthrow)
            Just (Right p) -> do
                U.warn (getpos p) ("pattern guard (" ++ nice p g ++ ") may fail to match.")
                stio (code ++ jthrow)
            Nothing -> stio code


genLambda rm x [] binds
    | Lam {pat} <- x = do
        g <- getST
        U.fatal (getpos x) ("genLambda: argument for " ++ nice pat g ++ " missing")
    | otherwise = genStmts rm x binds

/**
 * tell in which 'RMode' the case expression should best be computed to match pattern
 */
patternRMode p = do
    g <- getST
    case p of
        PVar {var} -> do
            v <- U.findV (Local var)
            if v.strsig.isStrict
                then stio RBoxed
                else stio RLazy
        PAt {pos,var,pat} -> do
            rm <- patternRMode pat
            if rm == RLazy then patternRMode (PVar {pos,var}) else stio rm
        PStrict {pat} -> patternRMode pat
        PLit {pos} -> stio RNative
        PMat {pos} -> stio RNative
        PAnn {pat} -> patternRMode pat
        PCon {pos,qname,pats} = do
                g <- getST
                if not (T.productCon qname g) then stio RBoxed
                  else do
                    ps <- mapSt patternRMode pats
                    if all (RLazy==) ps then stio RLazy else stio RBoxed
        PConFS {pos} -> U.fatal pos ("patternRMode: found PConFS") // not allowed anymore at this time



/**
 * The code for case statements can and will be optimized in various ways.

 * First, if the case expression is of the form @Con x1 x2 ... xn@, we can avoid
 * actual construction of the value if all the patterns are of
 * the form @Con p1 p2 ... pn@ or @_@ or @v@ where v is not used on the right hand side.
 * Indeed, every definition of a function with multiple arguments and more than one
 * alternative
 * > fun p1a p1b p1c = alt1
 * > fun p2a p2b p2c = alt2
 * > ...
 * results in code like
 * > \_a\_b\_c -> case (_a, _b, _c) of
 * >    (p1a, p1b, p1c)  -> alt1
 * >    (p2a, p2b, p2c)  -> alt2
 * >    ...
 * so naive implementation would cause an extra tuple construction on every function
 * call - this tuple would be created just to get deconstructed right away.
 *
 * Second, if we know that the set of patterns covers all possibilities, we
 * can avoid if-statements on the last alternative. In addition, we do not need
 * to arrange for the case that the pattern is not matched.
 * Therefore, we have a sophisticated algorithm to find this out, see 'T.patsComplete'
 *
 * The generated java code looks like this:
 * >  compute case expression if needed
 * >  if (p1a matches) {
 * >    if (p1b matches) {
 * >        if (p1c matches) {
 * >            code for alternative1
 * >  }}} // fall through to next alternative
 * >  if (p2a matches) {
 * >        ... like above ...
 * >  }
 * >  ... yet more alternatives ....
 * >  throw new NoMatch("xy.fr", 345, case expression)
 */
genCaseStmt rm (x@Case {ckind,ex=cex,alts=calts}) binds = do
        g <- getST
    // case Con a b c  ... avoid actual creation of value unless a pattern is not
    // itself a constructor application or a variable that is not referenced in its scope
        capp <- constrApp cex                      // Just (Con, args) if this is Con a1 a2 ... an
        pats <- foldSt conUVarAlt true calts        // true if all patterns are Con _ or _
        stri <- with (head calts).env do patternStrictness (head calts).pat // strsig of 1st pattern
        rmex <- with (head calts).env do patternRMode (head calts).pat
        bcex <- genExpr false rmex cex binds              // code for ordinary expression
        let makeBexs                                // binds for cex or constr args
                | pats, Just (con, xs) <- capp = case stri of
                        S ss -> mapSt exStr (zip xs (ss ++ allLazy))
                        U    -> mapSt exStr (zip xs allLazy)
                | otherwise = stio [bcex]
        bexs <- makeBexs
        let con = if pats then maybe Nothing (Just • fst) capp else Nothing      // constructor in case ex, if any
            complete
                | T.caseOtherwise g x = Nothing         // case true of true -> ...
                | otherwise = T.patsComplete g (map CAlt.pat ralts)
            // ralts are the alternatives that have no guard that could fail
            // only the patterns of those alts are considered in deciding
            // whether to throw exceptions or not
            // walts are the alternatives that have an open case when
            (walts, ralts) = partition (isJust • T.openCaseWhen g • CAlt.ex) calts
            // We will give a hint as to which guard is most likely
            // causing trouble. If the patterns would be complete if there were
            // no guards, then it is most likely the guard on an otherwise irrefutable
            // pattern, if there is none, we assume it is the guard of the last alternative
            // that has a guard.
            badguard = case T.patsComplete g (map CAlt.pat calts) of // would it be complete
                Just _  -> Nothing       // case could not be made safe by adding guards
                Nothing -> case filter (not • T.patternRefutable g • CAlt.pat) walts of
                    walt:_ -> T.openCaseWhen g walt.ex
                    []     -> case reverse walts of
                        walt:_ -> T.openCaseWhen g walt.ex
                        []     -> Nothing

            comment = sComment ("case  " ++ nicer cex g ++ "  ... "
                        ++ (if ckind == CWhen then "(guard)" else ""))
            throw binds
                | ckind == CWhen  = stio []                     // guards always fall through
                | Nothing <- con,
                  [bex1] <- binds = throwEx (toBoxed bex1)
                | otherwise       = throwEx (toBoxed bcex)      // construct case ex for throw
            throwEx arg
                | isJust complete, Just (Left x) <- badguard = do
                    when (ckind != CNoWarn) do
                        U.warn (getpos x) ("guard (" ++ nice x g ++ ") may evaluate to false.")
                    stio (jthrow arg)
                | isJust complete, Just (Right p) <- badguard = do
                    when (ckind != CNoWarn) do
                        U.warn (getpos p) ("pattern guard (" ++ nice p g ++ ") may fail to match.")

                    stio (jthrow arg)
                | Just p <- complete = do
                    when (ckind != CNoWarn) do
                        U.warn (last calts).pos ("pattern match is not exhaustive, "
                                ++ "consider adding a case for  "
                                ++ nice p g)
                    stio (jthrow arg)
                | otherwise = stio []                   // no throw neeeded

            throwargs exb = map JAtom [show ((Prelude.last g.genEnv).name.nice g),
                                                show (getpos x)] ++ [Binding.jex exb]
            jthrow exb = [JThrow (JNew (Ref (JName "RT" "NoMatch") []) (throwargs exb))]

        (nbexs, code) <- genAlts complete binds [] con bexs calts    // make alternatives
        jthrow <- throw nbexs                               // make throw statement
        stio (comment : concat (reverse (jthrow:code)))




    where
        genAlts complete binds codes con bexs ((calt@CAlt {env, pat, ex}):alts) = do
            g <- getST
            let last = finalAlt g calt `or` null alts
            // when = T.openCaseWhen g ex
                noif = last `and` isNothing complete
                poss = map CAlt.pos  alts
                unreachable p = U.warn p "case alternative cannot be reached."
            (codes, nbexs) <- genAlt noif binds codes con bexs calt
            if last
                then do
                    when (ckind != CNoWarn) do
                        foreach poss unreachable
                    stio (nbexs, codes)
                else genAlts complete binds codes con nbexs alts

        genAlt noif binds codes mbcon bexs (alt@CAlt {pos, env,pat,ex})
            | Nothing  <- mbcon = with env do
                g <- getST
                (nbex, code) <- with env (match noif pat (head bexs) (genStmts rm ex) binds)
                stio ((altComm g:code):codes, [nbex])
            | Just con <- mbcon = with env do
                stri <- patternStrictness pat
                case pat of
                    PCon {qname} -> do
                        sym <- U.findD qname
                        if sym.sid == Symbol.sid con then do
                                let nbexs = case stri of
                                        S ss -> map bexStr (zip bexs (ss ++ allLazy))
                                        _    -> bexs
                                code <- matchCon noif pat con nbexs (genStmts rm ex) binds
                                g <- getST
                                stio ((altComm g:code):codes, nbexs)
                            else do
                                U.hint pos ("case alternative will never match")
                                stio ([]:codes, bexs)
                    _  -> do
                        g <- getST
                        // uvar <- conUVarAlt true alt
                        // if uvar then do
                        code <- genStmts rm ex binds
                        stio ((altComm g:code):codes, bexs)
                        //  else do
                        //    (nbex, code) <- match noif pat (head bexs) (genStmts rm ex) binds
                        //    stio ((altComm g:code):codes, [nbex])
            where
                altComm g = sComment ("... of  " ++ nice pat g ++ " -> " ++ nicer ex g)


        exStr  (ex, stri)
            | Strictness.isStrict stri = genExpr false RNative ex binds
            | otherwise                = genExpr false RLazy   ex binds
        bexStr (bind, stri)
            | Strictness.isStrict stri = notLazy bind
            | otherwise = bind
            // check if an expression is a constructor application
        constrApp (ex@App _ _ _) = case map fst (U.flatx ex) of
            Con {name}:xs -> do
                sym <- U.findD name
                if U.arity sym == length xs
                    then stio (Just (sym, xs))
                    else stio Nothing            // for example:  case (,) a of mktuple -> mktuple b
            _ -> stio Nothing
        constrApp _ = stio Nothing      // for example: let a = 1 in Just a
        // check if a pattern is a constructor application or an unused variable
        conUVarAlt false _ = stio false
        conUVarAlt true (CAlt {pat = PCon {pos}}) = stio true
        conUVarAlt true (CAlt {env, pat = PVar {var}, ex}) = with env do
            sym  <- U.findV (Local var)
            refs <- T.references sym.sid ex
            if refs == 0 then stio true else stio false
        conUVarAlt _ _ = stio false
        // check if there could match anything else after this alternative has matched
        finalAlt g (CAlt {pat,ex})
            | T.patternRefutable g pat = false
            | Just _ <- T.openCaseWhen g ex = false
            | otherwise = true

/**
 * [usage] @genStmt rkind expression bindings@
 * [returns] A list of statements where the last one is a @return@
 *           or a @continue@ for a tailcall or a @throw@ from an
 *           incomplete case statement
 * This is called for return expressions only.
 */
genStmts rm (x@Case {ckind,ex=cex,alts=calts}) binds = genCaseStmt rm x binds

genStmts rm (x@Let {env,ex}) binds = with env do
        g <- getST
        (nbinds, stmtss) <- foldSt localdef (binds, []) (values env)
        stmts <- genStmts rm ex nbinds
        stio (comment g : ((map JLocal • concat • reverse) stmtss ++ stmts))
    where
        comment g = sComment (nicer x g)
        localdef (binds, codes) sym = do
            g <- getST
            jt <- subSigmaJT (Symbol.typ sym)
            let isClass = sym.depth > 0 `and` not (null sym.typ.bound)
                mode = if sym.depth > 0 then RBoxed
                        else if Symbol.rkind sym `band` 1 == 0 then RLazy else RBoxed
                bjt  = if mode == RLazy then lazy jt else jt
                name = if sym.depth > 0
                    then "_" ++ (U.javaName g sym.name).base
                    else (U.javaName g sym.name).base
                bind = Bind mode sym.typ bjt (JAtom name)
                nbinds = if isClass then binds else insert binds sym bind
            code <- symCode nbinds sym
            stio (nbinds, code:codes)

genStmts rm (x@(Ifte c t e _)) binds /*| not (T.isSimple x) */ = do
        g <- getST
        cbnd <- genExpr false RNative c binds
        tstm <- genStmts rm t binds
        estm <- genStmts rm e binds
        stio [sComment (nicer x g), JCond "if" (strictBind cbnd).jex tstm, JBlockX "else" estm]


genStmts rm ex binds
    | T.isSimple ex = do                                // return or tailcall
        g   <- getST
        case ex of
            App _ _ _
                | Vbl {name}:args <- map fst (U.flatx ex),
                  Just (sym@SymV {sid}) <- name.findit g,
                  sid == (head (g.genEnv)).sid,
                  length args == sym.depth = do
                        let ss = case sym.strsig of
                                    S ss -> ss ++ allLazy
                                    _    -> allLazy
                            asigs = snd (U.returnTypeN sym.depth sym.typ.rho)
                            argNames = drop (fold (+) 0 (map Symbol.depth (tail g.genEnv))) GenJava.argNames
                        argmodes <- mapSt (curry argMode) (zip ss asigs)
                        abinds   <- mapSt (curry genEx)   (zip argmodes args)
                        let assigns = zipWith JAssign (map JAtom argNames) (map Binding.jex abinds)
                            comment = sComment ("tailcall  " ++ nicer ex g)
                        stio (comment:assigns ++ [JEx (JAtom "continue tailrecursion")])
                where
                    genEx arm aex = genExpr false arm aex binds
            _ = do
                bnd <- genExpr true rm ex binds
                stio [sComment ("return " ++ show rm ++ "  " ++ nicer ex g),
                        sComment (nice bnd g),
                        JReturn bnd.jex]

genStmts rm ex binds = do
        g <- getST
        stio [JError ("code for " ++ nicer ex g)]

impliesG g (Ctx _ d t1 _) (Ctx _ c t2 _) = U.isSuper c g d `and` sameTau t1 t2

envCtxs g = [ ctx | s <- reverse (Global.genEnv g),
                                    not (null (Symbol.typ s).bound),
                                    ctx <- (Symbol.typ s).rho.context ]

resolveConstraint pos (ctx@Ctx {cname, tau}) = do
        g <- getST
        // ctx <- TC.reducedCtx ctx
        U.logmsg TRACEG (U.tauPos tau) (U.nicerctx [ctx] g)
        if make then makeCtx else findCtx
    where
        tcon:targs = tau.flat
        make | TCon {name} <- tcon = true
             | otherwise = false

        findCtx | Meta tv <- tau, tv.isFlexi = stio (JAtom "null")
                | otherwise = do
            g <- getST
            let
                ctxsnms = zip (envCtxs g) ctxNames
                implies = impliesG g
            U.logmsg TRACEG pos ("findCtx: looking for  " ++ nice cname g ++ " " ++ nice tau g)
            U.logmsg TRACEG pos ("findCtx: we have  " ++ U.nicectx (envCtxs g) g)
            let ok = [ name | (ctx1, name) <- ctxsnms, ctx1 `implies` ctx]
            U.logmsg TRACEG pos ("findCtx: ok= " ++ show ok)
            if (null ok)
                then U.fatal pos ("Cant find context for " ++ nice cname g ++ " " ++ nice tau g)
                else stio ((JAtom • head) ok)
        makeCtx  = do
            csym <- U.findC cname
            case tcon of
                TCon {name} -> case filter ((name ==) • fst) csym.insts of
                    (_,iname):_ -> do
                        inst <- U.findI iname
                        g <- getST
                        let crho = RhoTau [] tau
                            csig = ForAll [] crho
                        U.logmsg TRACEG pos ("makeCtx: unify " ++ nice inst.typ g ++ "  with  "
                                ++ nice csig g)

                        let tree = U.unifySigma g inst.typ csig
                        rho  <-  U.substRho tree inst.typ.rho
                        // rhojt <- rhoJT rho
                        U.logmsg TRACEG pos ("makeCtx substituted: " ++ nice rho g)
                        subctx <- mapSt TC.reducedCtx  rho.context
                        args <- mapSt (resolveConstraint pos) subctx
                        let jiname = U.javaName g inst.name
                            // jrho   = rhoJT g rho
                            jitargs0 = [ RhoTau [] t
                                            | v <- inst.typ.bound, t <- (tree.lookup v).toList]
                            jitargs = if csym.vkind > 0 then rho : jitargs0 else jitargs0
                        jitjts     <- mapSt rhoJT jitargs
                        let jit    = Ref jiname jitjts
                            jex    = if null subctx
                                then JInvoke (JStMem (U.memberOf jiname "ƒNew") jitjts) []
                                else JNew jit args
                        U.logmsg TRACEG pos ("makeCtx: " ++ showJex jex)
                        stio jex
                    [] -> do
                        g <- getST
                        U.fatal pos ("makeCtx: instance " ++ nice cname g ++ " " ++ nice tau g ++ " not found.")
                other -> do
                    g <- getST
                    U.fatal pos ("makeCtx: head is " ++ nice other g)

instSymDirect = instSym0 true true

/// convenience method for normal instantiation
instSym = instSym0 false true
/**
 * instantiate a symbol at a given type
 */
instSym0 :: Bool -> Bool -> Line -> Symbol -> Sigma -> StG Binding
instSym0 direct cmembers pos sym sigma = do
    g <- getST
    U.logmsg TRACEG pos ("instSym: " ++ nice sym g ++ " at " ++ nice sigma g)
    // let taus = sigmaInst g sym.typ sigma    // (List a) (List Int) ==> (a,Int)
    //     jts  = map (tauJT g) taus
    //     sjt  = (sigmaJT g sym.typ)
    let inst = U.sigmaInst g sym.typ sigma
        jname = U.javaName g sym.name



    gargs    <- mapSt tauJT inst
    U.logmsg TRACEG pos ("instSym: gargs = " ++ show (map (flip nice g) inst))
    jt       <- sigmaJT sigma
    let str | Local _ <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
    strho    <- U.substRho (U.unifySigma g sym.typ sigma) str
    U.logmsg TRACEG pos ("instSym: strho = " ++ nice strho g)
    contexts <- mapSt  TC.reducedCtx  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts

    let (_, ss) = U.returnType sym.typ.rho
        hktvsSigma (ForAll _ rho) = hktvsRho rho
        hktvsRho (RhoFun ctxs sig rho) = any (hktvsTau • Context.tau) ctxs
                                            `or` hktvsSigma sig `or` hktvsRho rho
        hktvsRho (RhoTau ctxs tau) = any (hktvsTau • Context.tau) ctxs `or` hktvsTau tau
        hktvsTau (TApp (TVar {var}) _) = true
        hktvsTau (TApp a b) = hktvsTau a `or` hktvsTau b
        hktvsTau (TFun a b) = hktvsTau a `or` hktvsTau b
        hktvsTau _ = false
        needscoerce = not (null sym.typ.bound) `and` any hktvsSigma ss
        coerce obj = if needscoerce then JInvoke (JExMemG obj "coerce" jt.targs) [] else obj
    U.logmsg TRACEG pos ("instSym: coerce = " ++ show needscoerce)

    case sym of
        SymD {name=MName tynm _, flds} -> do
            let mkn = if length flds > 0 then "n" else "mk"
            symt <- U.findT tynm
            if symt.enum
                then stio (Bind RBoxed sigma (Ref (JName "" "Boxed.Int") [])
                            (JStMem jname []))
                else if direct
                    then stio (Bind RBoxed sigma jt (JStMem (U.memberOf jname "mk") gargs))
                    else stio (Bind RBoxed sigma jt
                            (JInvoke
                                (JStMem (U.memberOf jname mkn) gargs) []))
        SymV {name = MName clas m, depth, rkind} | cmembers, Just (SymC {vkind,tau}) <- clas.findit g = do
                g <- getST
                U.logmsg TRACEG pos ("instSym: " ++ m ++ " depth=" ++
                        show depth ++ ", vkind=" ++ show vkind)
                let tree   =  (U.unifySigma g sym.typ sigma)
                    tyargs = map (unJust • lookup tree) (filter (!=tau.var) sym.typ.bound)
                gargs      <- mapSt tauJT tyargs
                let inst   = JInvoke get (tail ctxs)
                    get
                        | null gargs  = JExMem  (head ctxs) (mangled m ++ latinF)
                        | otherwise   = JExMemG (head ctxs) (mangled m ++ latinF) gargs

                    cojt [x]    = x
                    cojt (x:xs) = Ref (JName "" "Fun") [x, cojt xs]
                    coargs = case jt.targs of
                        [] -> []
                        [x] -> [x]
                        h:ts ->  [h, cojt ts]
                    coerce | vkind == 0 = inst
                           | otherwise = JInvoke (JExMemG inst "coerce" coargs) []
                stio (Bind RBoxed sigma jt coerce)
        SymV {name, depth = 0, rkind, nativ = Nothing} -> do
                let m    = varIsClass sym
                    mode = if rkind `band` 1 == 0 `or` m then RLazy else RBoxed
                    inst = JNew   (Ref jname gargs) ctxs
                    func = JStMem jname [] // (if m then gargs else [])
                    bind = Bind mode sigma jt (if m then inst else func)
                stio bind
        SymV {name, nativ = Just _} | U.arity sym == 0 = do
                let inst = coerce (JStMem jname [])
                stio (Bind RBoxed sigma jt inst)
        SymV {name = Local _, expr = Just _, depth} | depth > 0 = do
                let inst = coerce (JNew it ctxs)
                    it = Ref jname gargs
                if direct
                    then if needscoerce then stio (Bind RBoxed sigma jt (JExMem inst "r"))
                        else case workerMethod g sym of
                            JAtom x -> stio (Bind RBoxed sigma jt (JExMem inst x))
                            wm      -> stio (Bind RBoxed sigma jt (wm.{targs=gargs}))
                    else stio (Bind RBoxed sigma jt inst)
        SymV {name, depth, rkind} -> do
                let inst = coerce (JInvoke n ctxs)
                    n    = JStMem (U.memberOf jname "n") gargs
                if direct
                    then if needscoerce then stio (Bind RBoxed sigma jt (JExMem inst "r"))
                        else case workerMethod g sym of
                            JAtom x -> stio (Bind RBoxed sigma jt (JExMem inst x))
                            wm      -> stio (Bind RBoxed sigma jt (wm.{targs=gargs}))
                    else stio (Bind RBoxed sigma jt inst)

adaptHigherPolymorphic a (ForAll bnd _)
    | null bnd = stio a
    | otherwise = do
            g  <- getST
            // replace all bound tyvars with Void in type of expression
            let replace = Tree.fromList [ (b, voidTau) | b <- bnd ]
            case Expr.typ a of
                Just sigma -> do
                    U.logmsg TRACEG (getpos a) ("adaptHP: substitute "
                        ++ joinStr "," bnd ++ " with " ++ nicer voidTau g
                        ++ " in " ++ nice a g ++ " :: " ++ nicer sigma g)
                    // sigma <- U.substSigma replace sigma
                    a <- U.mapEx true (adapt (U.substSigma replace)) a
                    U.logmsg TRACEG (getpos a) ("adaptHP: result "
                        ++ nicer (unJust a.typ) g)
                    stio a
                Nothing -> // cannot really happen, but keep case checker happy
                    stio a
    where
        adapt f ex = case Expr.typ ex of
            Just sigma -> do
                sigma <- f sigma
                stio (Left ex.{typ=Just sigma})
            Nothing -> stio (Left ex)


/**
 * [usage] @genExpr rflag rmode expression binds@
 * [return] a binding that computes the frege expression in the desired 'RMode'
 * If the @rflag@ is true, special handling occurs for lazy calls: The arguments
 * of that tailcall are computed according to the strictness information of the
 * called function instead of all lazy. This is an optimization appropriate for
 * tail calls.
 */
genExpr :: Bool -> RMode -> Expr -> Tree Symbol Binding -> StG Binding
genExpr _ rm (Vbl {pos, name, typ = Just sigma}) binds
    | Local nm <- name = do
        sym <- U.findV name
        case lookup binds sym of
            Just b
                  // is it lambda bound or let bound variable?
                | isNothing sym.expr `or` not (U.isFun sym.typ),
                  // with a forall-type?
                  not (null sym.typ.bound) = do
                    g        <- getST
                    sjt      <- sigmaJT sigma
                    U.logmsg TRACEG pos ("genExpr " ++ nm ++ " :: " ++ sym.typ.nice g
                        ++ " inst at " ++ sigma.nice g)
                    let boxf = toBoxed b
                        call = JInvoke coerce []
                        coerce = JExMemG boxf.jex "coerce" sjt.targs
                    stio (Bind RBoxed sigma sjt call)
                | otherwise = stio (toMode rm b)
            Nothing | Just _ <- sym.expr // , sym.anno, length sym.typ.rho.context > 0
                = instSym sym.pos sym sigma
            Nothing -> do
                g <- getST
                U.error pos ("genExpr: " ++ nice sym g ++ " not bound")
                sjt      <- sigmaJT sigma
                stio (Bind rm sym.typ sjt (JAtom ("UNBOUND." ++ name.base)))
    | otherwise = do
        sym <- U.findV name
        bind <- instSym pos sym sigma
        stio (toMode rm bind)

genExpr _ rm (Con {pos, name, typ = Just sigma}) binds = do
    sym <- U.findD name
    bind <- instSym pos sym sigma
    stio (toMode rm bind)

genExpr _ rm (Lit {kind = LBool, value, typ = Just sigma}) binds
    | rm != RNative, value == "true"   =  stio (Bind RBoxed  sigma bool t)
    | rm != RNative, value == "false"  =  stio (Bind RBoxed  sigma bool f)
    where
        bool = Ref (JName "" "Boxed.Bool") []
        t = JStMem (U.memberOf bool.jname "t") []
        f = JStMem (U.memberOf bool.jname "f") []


genExpr _ RNative (Lit {kind, value, typ = Just sigma}) binds
    | kind != LRegex `and` kind != LBig = do
        jt <- sigmaJT sigma
        stio (Bind RNative sigma jt (JAtom value))

genExpr _ rm (x@Lit {kind,value,typ=Just sigma}) binds = do
    jname <- findConst x
    jt    <- sigmaJT sigma
    let bind = Bind RBoxed sigma jt (JStMem jname [])   // genExpr RNative x binds
    stio (toMode rm bind)

genExpr rflg rm (app@App a b (Just sigma)) binds = do
        g <- getST
        let fun:args = map fst (U.flatx app)
            asigs = maybe [] (snd • U.returnType • Sigma.rho) fun.typ
        args   <-   adaptHigherPolymorphicS args asigs
        genApp rm binds fun args
    where
        genApp rm binds (con@Con {pos, name, typ = Just csigma}) args = do
            sym <- U.findD name
            let a = length sym.flds
            if length args < a
                then genAnon rm binds con args          // partial application
                else do
                    dbind <- instSymDirect pos sym csigma
                    sjt   <- sigmaJT sigma
                    let jx  = dbind.jex
                        // sjt = dbind.jtype
                        aargs = take a args
                        rargs = drop a args
                    abinds <- mapSt (flip (genExpr false RLazy) binds) aargs
                    rbinds <- mapSt (flip (genExpr false RLazy) binds) rargs
                    let call = Bind RBoxed sigma sjt (JInvoke jx (map Binding.jex abinds))
                        result
                            | null rargs = stio call
                            | otherwise  = do
                                    // sjt <- sigmaJT sigma
                                    let r = fold apply call rbinds
                                        b = Bind RLazy sigma (lazy sjt) r.jex
                                    stio (toMode rm b)
                    result
        genApp rm binds (vbl@Vbl {pos, name, typ = Just vsigma}) args = do
                g     <- getST
                sym   <- U.findV name
                let d = ari sym
                if d < 1 `or` d > length args
                    then genAnon rm binds vbl args
                    else case sym.name of
                        MName cname _
                            | Just (SymC {sid}) <- cname.findit g = genAnon rm binds vbl args
                        noclassmember -> case sym.nativ of
                            Just _    -> genNative sym //genAnon rm binds vbl args
                            nonnative -> genDirect sym
            where
                ari (sym@SymV {nativ=Just _}) = U.arity sym
                ari sym                       = sym.depth
                tailcall = rflg `and` rm == RLazy
                genEx arm aex = genExpr false arm aex binds

                funBind sym   = case lookup binds sym of
                        Just b -> do        // must be let bound because of depth > 0
                            vbind <- genExpr false RBoxed vbl binds
                            let hasworker = sym.rkind `band` 6 != 0
                                w = if rm == RLazy then "a"
                                    else if hasworker then "w"
                                    else "r"
                                njx = JExMem vbind.jex w
                            stio (vbind.{jex = njx})
                        Nothing -> if rm == RLazy
                            then do
                                vbind <- instSym pos sym vsigma
                                stio vbind.{jex <- flip JExMem "a"}
                            else instSymDirect pos sym vsigma

                genNative sym = do
                    // vbind <- funBind sym
                    let acall = rm == RLazy `and` not tailcall
                        wcall = not acall `and` (wrappedOnly sym `or` not (null sym.typ.bound))
                        (atau, asigs) = U.returnType (Symbol.typ sym).rho
                        depth         = ari sym
                        aargs         = take depth args
                        rargs         = drop depth args
                        sss           = case sym.strsig of
                                S ss -> ss ++ allLazy
                                U    -> allLazy
                    if acall `or` wcall then genDirect sym
                        else do
                            sjt   <- sigmaJT sigma
                            ajt   <- tauJT atau
                            let rjt   = strict  ajt
                                cmode = maxStrict rjt
                            amodes   <- mapSt (curry argMode) (zip sss asigs)
                            abinds   <- mapSt (curry genEx)   (zip amodes aargs)
                            rbinds   <- mapSt (flip (genExpr false RLazy) binds) rargs
                            call     <- if wrapped sym
                                then do
                                    code <- wrapCode JEx atau sym abinds
                                    let JEx ex = head code
                                    stio (Bind cmode sigma rjt ex)
                                else nativeCall sym abinds

                            let result
                                    | null rargs = stio (toMode rm call)
                                    | otherwise  = do
                                            let r = fold apply call rbinds
                                                b = Bind RLazy sigma (lazy sjt) r.jex
                                            stio (toMode rm b)
                            result
                genDirect sym = do
                    vbind <- funBind sym
                    sjt   <- sigmaJT sigma
                    let jx = vbind.jex
                        depth = ari sym
                        rev | JExMem _ "r" <- jx = true
                            | otherwise          = false
                        r xs = if rev then reverse xs else xs
                        aargs = take depth args
                        rargs = drop depth args
                        sss = if rm == RLazy `and` not tailcall then allLazy
                            else case sym.strsig of
                                S ss -> ss ++ allLazy
                                U    -> allLazy
                        (arho, asigs) = U.returnTypeN depth sym.typ.rho
                        cmode = if rm == RLazy then RLazy
                            else if rev then RLazy // rmode (sym.rkind `band` 1)
                            else rmode sym.rkind
                        rjt | cmode == RLazy   = lazy sjt
                            | cmode == RNative = strict sjt
                            | otherwise        = sjt
                    amodes   <- mapSt (curry argMode) (zip sss asigs)
                    let argmodes = if tailcall `or` rev then map tcmode amodes else amodes
                        tcmode RNative = RBoxed
                        tcmode r       = r
                    abinds   <- mapSt (curry genEx)   (r (zip argmodes aargs))
                    rbinds   <- mapSt (flip (genExpr false RLazy) binds) rargs
                    let call = Bind cmode sigma rjt (JInvoke jx (map Binding.jex abinds))
                        result
                            | null rargs = stio (toMode rm call)
                            | otherwise  = do
                                    let r = fold apply call rbinds
                                        b = Bind RLazy sigma (lazy sjt) r.jex
                                    stio (toMode rm b)
                    result


        genApp rm binds fun args = genAnon rm binds fun args

        genAnon rm binds fun args = do
            fbind  <-   genExpr false RBoxed fun binds
            abinds <-   mapSt (flip (genExpr false RLazy) binds) args
            sjt    <-   sigmaJT sigma
            let appl = fold apply fbind abinds
            result = Bind RLazy sigma (lazy sjt) appl.jex
            stio (toMode rm result)


        apply x b  = x.{mode=RLazy, jex=JInvoke (JExMem xe.jex "a") [ns.jex]}
            where ns = notStrict b
                  xe = toBoxed x

        adaptHigherPolymorphicS []     _                 = stio []
        adaptHigherPolymorphicS args   []                = stio args
        adaptHigherPolymorphicS (a:as) (t:ts) = do
            a <- adaptHigherPolymorphic a t
            as <- adaptHigherPolymorphicS as ts
            stio (a:as)

genExpr rflg RLazy (ifte@Ifte c t e (Just sigma)) binds = do
    g     <- getST
    jt    <- sigmaJT sigma
    cbind <- genExpr false RLazy c binds
    tbind <- genExpr false RLazy t binds
    ebind <- genExpr false RLazy e binds
    let lif = VName pPrelude "lazyif"
        jif = U.javaName g lif
        ifn = JStMem (U.memberOf jif "n") [jt]
        ifna = JExMem (JInvoke ifn []) "a"
        jex = JInvoke ifna [cbind.jex, tbind.jex, ebind.jex]
    stio (Bind RLazy sigma (lazy jt) jex)

genExpr _ rm (ifte@Ifte c t e (Just sigma)) binds = do
    // g <- getST
    cbind <- genExpr false RNative c binds
    tbind <- genExpr false rm      t binds
    ebind <- genExpr false rm      e binds
    stio (Bind rm sigma (Binding.jtype tbind) (JQC cbind.jex tbind.jex ebind.jex))


genExpr _ rm ex binds = do
    g <- getST
    let ft = unJust (Expr.typ ex)
    jt <- sigmaJT ft
    stio (Bind rm ft jt ((JAtom • show) (nicer ex g ++ " :: " ++ nicer (unJust ex.typ) g)))
    