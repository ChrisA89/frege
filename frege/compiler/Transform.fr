// enable UTF-8 ««««««««««««««•••••••••••••»»»»»»»»»»»»¦¦¦¦¦¦¦¦
/**
 * This package deals with various transformations.
 * In compiler pass 7, we unroll let definitions like so:
 * > let a = ex1; b = ex2 in ex3  ==> let a = ex1 in let b = ex2 in ex3
 * provided /ex2/ does not reference /a/.
 */
/*
 * $Author$
 * $Revision$
 * $Date$
 * $Id$
 *
 */

package frege.compiler.Transform where

/// This is $Revision$
public version = v "$Revision$" where
    v (m ~ #(\d+)#) | Just g <- m.group 1 = g.atoi
    v _ = 0


import frege.List (joinStr Tree lookup insert update keys values each
                    fromKeys including contains union isEmpty)
import frege.compiler.Data except(version)
import frege.compiler.Utilities()       U

post = stio true

/// find all our 'SymV' symbols
allourvars = do
    g <- getST
    let collectedenvs = g.thisTab : [ Symbol.env sy | sy <- values g.thisTab, Symbol.{env?} sy ]
        collectedvars = [ v | env <- collectedenvs, v@SymV {name} <- values env, name.our g]
    stio collectedvars

pass7 = do
    g <- getST
    collectedvars <- allourvars
    // unroll let expressions
    foreach collectedvars unrollSym
    stio ("expressions", length collectedvars)


pass8 = do
    g <- getST
    collectedvars <- allourvars
    // find closed lambdas and make them private global
    foreach collectedvars closedLambdaSym
    stio ("expressions", length collectedvars)


/**
 * Strictness analysis
 *
 * - native functions are strict in all arguments
 * - constructors are lazy in all arguments (but we can adapt this later if the need arises)
 * - every symbol will get a strictness signature and status StrictChecked
 */
pass10 = do

        ourvars <- allourvars
        names <- mapSt U.fundep ourvars

        let groups = U.tsort names

        g <- getST
        U.logmsg TRACES 0 ("names: " ++ joinStr " " (map (flip QName.nice g • fst) names))
        U.logmsg TRACES 0 ("groups: " ++ display (map (map (flip QName.nice g)) groups))

        foreach groups checkgroup

        stio ("functions", length names)
    where
        checkgroup nms = do
            foreach nms (strictName [])         // compute strictness
            foreach nms (returnName nms)        // compute return type of java methods

/**
 * In this pass, we make sure that all expressions are in
 * a form we need for code generation. We say that an expression is, or is not /easy/.
 *
 * - Every simple expression is also easy.
 * - A literal is simple.
 * - A variable is simple.
 * - A constructor name is simple.
 * - @(x::t)@ has the same properties as @x@
 * - @if a then b else c@ is easy if @b@ and @c@ are easy and @a@ is simple.
 *   If @b@ and @c@ are also simple, then the whole expression is simple.
 * - @a b@ is simple if @a@ and @b@ are both simple. Otherwise the application is
 *   not easy.
 * - @let v = x in e@ is easy, if @x@ and @e@ are both easy.
 * - @\p -> x@ is easy, if @x@ is easy
 * - @case x of { p1 -> a1; ...; pn -> an }@ is easy if @x@ is simple and
 *   all alternatives @a1@ ... @an@ are easy.
 *
 * An example for an expression that is not easy would be @(\p -> e) x@.
 * This is because
 * for an application to be easy, all subexpressions must be simple, and a lambda
 * abstraction can only be easy, but never simple.

 * It can be made easy in 2 ways, provided @e@ is easy and @x@ is simple:
 * 1. transform to @case x of p -> e@
 * 2. @let v = \p -> e in v x@
 *
 * This pass should run before strictness analysis so that local definitions
 * we need to introduce get strictness info.
 */
pass9 = do
    g <- getST
    collectedvars <- allourvars
    // make all expressions easy
    foreach collectedvars easySym
    // set lambdadepth for each symbol
    collectedvars <- allourvars
    foreach collectedvars depthSym
    stio ("expressions", length collectedvars)

easySym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- easyExpr x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
easySym sym = do
    g <- getST
    U.fatal sym.pos ("easySym no SymV : " ++ sym.nice g)


depthSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- depthExpr x
        // U.changeSym vsym.{expr = Just nx}
        let (_, sigmas) = U.returnType vsym.typ.rho
        let lambdaDepth (Lam {ex}) = 1 + lambdaDepth ex
            lambdaDepth ex = 0
            depth = lambdaDepth nx
        when (depth > length sigmas) do
                g <- getST
                U.error vsym.pos (nice vsym.name g
                    ++ ": lambdaDepth for expression " ++ nice nx g
                    ++ " (" ++ show depth ++ ") is greater than arity (" ++ show (length sigmas)
                    ++ ") for type " ++ nicer vsym.typ g)
        U.changeSym vsym.{expr = Just nx, depth}
    | otherwise = stio ()
    where
        depthExpr = U.mapEx false depthX
        depthX  x
            | Let {env} <- x = do
                env <- nested env (foreach (values env) depthSym)
                stio (Left x.{env})
            | otherwise = stio (Left x)

depthSym sym = do
    g <- getST
    U.fatal sym.pos ("depthSym no SymV : " ++ sym.nice g)

/**
 * [usage] @returnKind group symbol@
 * [computes] the return type (lazy=0, boxed=1) of the r-Method, and, if a w-Method is needed,
 * the return kind of the w-Method (none, lazy=2, boxed=4, strict=6)
 *
 * - non nullary Constructors have implicitely 1101 (boxed mk-Method, boxed r-Method)
 *   and are safe tail calls (as they return immediately with the new object)
 * - Native methods have 5 or 7 (the native method *is* the w method, and if the return type
 *   is a java type, then it is 7, otherwise 5 (Maybe, Either or ST s/IO). They make also
 *   safe tail calls.
 * - if functions with constraints have a w-Method, this will be an instance method,
 *   otherwise a static one.
 * - a function with a strict argument gets a w-Method
 * - a CAF (lambdadepth = 0) will have no w-Method. The rkind will show if the CAF is
 *   declared with a lazy type or not. The bit 16 is on if the expression is simple
 *   and no self references or possibly forward references exist.
 *   Forward references can appear in global symbols which reference any global
 *   value from this package.
 */
returnKind names (sym@SymV {nativ = Just _}) = do
        g <- getST
        let rkind = if (U.isJavaType g • fst) (U.returnType sym.typ.rho) then 7 else 5
        U.changeSym sym.{rkind}

returnKind names (sym@SymV {expr = Just x, depth = 0}) = do
        (w, x) <- returnExprKind sym x
        self   <- references sym.sid x        // is it self-referential?
        (_, deps) <- U.fundep sym
        let fwrefs
                | Local _ <- sym.name = false
                | otherwise = not (null deps)        // possible forward references?
            b16 = if isSimple x `and` not fwrefs `and` self == 0 then 16 else 0
            rkind = if fwrefs then 0 + b16
                else if self > 0 then 0 + b16
                    else b16 + ord sym.strsig.isStrict
        U.changeSym sym.{rkind, expr = Just x}

returnKind names (sym@SymV {expr = Just x}) = do
        (w, x) <- returnExprKind sym x
        let r = if w `band` 6 <= 2 then 0 else 1
            b16 = if isSimple x then 16 else 0
            rkind = case sym.strsig of
                    S ss | any Strictness.isStrict ss = b16+r+w
                    otherwise = r+b16
        U.changeSym sym.{rkind, expr = Just x}

returnKind _ _ = stio ()     // abstract methods

/**
 * how often the symbol with 'Symbol.sid' is referenced in 'Expr' @x@
 */
references sid x = U.foldEx true refs 0 x
    where
        refs n (Vbl {name}) = do
            sym <- U.findV name
            if sym.sid == sid then stio (Right (n+1)) else stio (Left n)
        refs n (Ifte c t e _) = do
            crefs <- references sid c
            trefs <- references sid t
            erefs <- references sid e
            stio (Right (crefs + max trefs erefs))
        refs n (Case {ex,alts}) = do
            xrefs <- references sid ex
            arefs <- mapSt altRefs alts
            stio (Right (xrefs + fold max 0 arefs))
        refs n _ = stio (Left n)
        altRefs (CAlt {env,ex}) = with env (references sid ex)

/**
 * [usage] @returnExprKind symbol x@
 *
 * Look for the return expressions in @x@ and compute the minimum return kind.
 *
 * A return expression is an application, literal, variable or constructor.
 *
 * - When it is a literal, unboxed return (6) is possible.
 * - When it is a local lambda or case bound variable,
 *   return will be according to the variable's strictness boxed or lazy.
 *   Otherwise, it's the return kind of the variable.
 * - Constructor is either a function or a nullary constructor - both are boxed.
 * - A tail recursive application is either 6 or 4, depending on return type
 * - A tail call to a native function or a constructor is 4 or 6 depending on their w-value
 * - Otherwise, if the application is saturated or a lambda/case-bound variable is applied,
 *   it's lazy.
 * - Unsaturated applications are boxed (function types)
 */
returnExprKind sym (x@Lit {pos}) = stio (6,x)
returnExprKind sym (x@Con {pos}) = stio (4,x)
returnExprKind sym (x@Ann {ex})  = do
        (n,ex) <- returnExprKind sym ex
        stio (n, x.{ex})

returnExprKind sym (x@Vbl {name}) = do
    symv <- U.findV name
    g    <- getST
    case symv.expr of
        Nothing -> case symv.name of
            Local _ -> if symv.strsig.isStrict
                        then case U.returnType symv.typ.rho of
                            (tau, []) | U.isJavaType g tau = stio (6,x)
                            _ -> stio (4,x)     // function type or non java type
                        else stio (2,x)               // lambda/case bound
            _ -> case U.returnType symv.typ.rho of
                (_,[]) -> stio ((symv.rkind `band` 1)*2 + 2, x)
                _      -> stio (4,x)        // global function
        Just (Lam {env}) -> stio (4,x)      // return a local function
        Just _ -> if symv.strsig.isStrict then
                        if (U.isJavaType g • fst) (U.returnType symv.typ.rho)
                            then stio (6,x) else stio (4,x)
                    else stio (2,x)
returnExprKind sym (ex@App a b typ) = do
    (_, a) <- returnExprKind sym a
    (_, b) <- returnExprKind sym b
    let (f,_) = head flatx
        args  = tail flatx
        flatx = U.flatx ex
        app = App a b typ
    case f of
        Vbl {name} -> do
            symf <- U.findV name
            if isJust symf.nativ then stio ((symf.rkind `band` 6), app)
              else if (length args < symf.depth) then stio (4, app) // unsaturated
              else if (length args > symf.depth) then stio (2, app) // over saturated
              else case symf.expr of
                    Nothing -> stio (2, app)      // application of lambda/case bound
                    Just _ -> do
                        g <- getST
                        if symf.sid == Symbol.sid sym
                            then if (U.isJavaType g • fst) (U.returnType symf.typ.rho)
                                    then stio (8+6, app) else stio (8+4, app)
                            else stio (2, app) // lazy application
        Con {name} -> stio (4, app)
        _ -> do
            g <- getST
            U.fatal (getpos ex) ("returnExprKind: funny application " ++ nice ex g)

returnExprKind sym (Ifte c t e typ) = do
    (_, c)  <- returnExprKind sym c
    (w1, t) <- returnExprKind sym t
    (w2, e) <- returnExprKind sym e
    stio (minRkind w1 w2, Ifte c t e typ)

returnExprKind sym (x@Lam {ex,env}) = with env do
        (n, ex) <- returnExprKind sym ex
        stio (n, x.{ex})
returnExprKind sym (x@Let {ex,env}) = with env do
        let nms = map Symbol.name (values env)
        foreach nms (returnName nms)
        (n, ex) <- returnExprKind sym ex
        env <- getTop
        stio (n, x.{ex,env})
returnExprKind sym (x@Case {ex, alts}) = do
    (_, ex) <- returnExprKind sym ex
    wsalts <- mapSt (altExprKind sym) alts
    stio (foldl1 minRkind (map fst wsalts), x.{ex, alts = map snd wsalts})
returnExprKind sym _ = error "returnExprKindbad epr."

altExprKind sym (alt@CAlt {env,ex}) = with env do
     (n, ex) <- returnExprKind sym ex
     env <- getTop
     stio (n, alt.{env,ex})

/**
 * combine two rkinds by taking the minimum of the lower 3 bits and the maximum of
 * the 2³ bit, which signifies tail recursion.
 */
minRkind a b = tailbit `bor` wrbits where
    tailbit = (a `bor` b) `band` 8
    wrbits  = min (a `band` 7) (b `band` 7)

/**
 * [usage] returnName names name
 *
 * gets the symbol and stores the information computed by 'returnKind' in the 'Symbol.rkind'
 * field.
 *
 * The @names@ list gives the names that are mutually dependend on this one.
 */
returnName nms name = do
    sym   <- U.findV name
    returnKind nms sym
    // U.changeSym sym.{rkind}

unrollSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- unrollExpr x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       // do nothing
unrollSym sym = do
    g <- getST
    U.fatal sym.pos ("unrollSym no SymV : " ++ sym.nice g)

/*
singleLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- singleLetExpr x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       // do nothing
singleLetSym sym = do
    g <- getST
    U.fatal sym.pos ("unrollSym no SymV : " ++ sym.nice g)
    */

closedLambdaSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- U.mapExBody true closedLambda x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
closedLambdaSym sym = do
    g <- getST
    U.fatal sym.pos ("closedLambdaSym no SymV : " ++ sym.nice g)


unrollExpr    = U.mapEx true unrollLet
// singleLetExpr = U.mapEx true singleLet
easyExpr      = U.mapEx true easyX

unrollLet (x@Let {env,ex}) = do
        g <- getST
        U.logmsg TRACE7 (getpos x) ("unrollLet: " ++ x.nice g)
        // first do the subexpressions
        let mapsub (sy@SymV {expr=Just x}) = do
                    x <- unrollExpr x
                    U.changeSym sy.{expr=Just x}
            mapsub sy = error "mapsub: no var"
        ex  <- with env (unrollExpr ex)
        env <- with env do
                let xs = [ sy | sy@SymV {expr=Just _} <- values env ]
                foreach xs mapsub
                env <- getTop
                stio env
        let kvs = each env
            ldep (k@#^let\$\d+$#, SymV {expr=Just (Lam {ex})}) = do
                    deps <- with env (letlocals ex)
                    stio (k, deps)
            ldep (k, SymV {expr=Nothing}) = stio (k, [])
            ldep (k, SymV {expr=Just ex}) = do
                    deps <- with env (letlocals ex)
                    stio (k, deps)
            ldep (_,_) = error "ldep: no var"
        kdeps  <- mapSt ldep kvs
        env    <- foldSt pbind env kdeps
        let result = fold (sublet env) ex ((reverse • U.tsort) kdeps)
        U.logmsg TRACE7 (getpos x) ("unrollLet: " ++ result.nice g)
        stio (Right result)
    where
        sublet env inx [k@#^let\$\d+$#]
                | Just (vsym@SymV {expr=Just (Lam {env=ev,ex,pat})}) <- lookup env k
                = Case CNormal ex [CAlt {env=ev, pos=vsym.pos, pat, ex=inx}] Nothing
        sublet env xin locals = if isEmpty e then xin else Let e [] xin Nothing where
            lookups = [ (s, env.lookup s) | s <- locals ]
            e = fold put Tree.Nil [ (s, sym) | (s, Just sym) <- lookups ]
            put t (k,v) = Tree.insert t k v
        letlocals ex = do
            env <- getTop
            let thisSids = fromKeys [ sid | SymV {sid} <- values env ]
            usedvars <- U.foldEx true (localvar thisSids) Nil ex
            stio (keys usedvars)
        localvar sidset acc (Vbl {name=nm@Local _}) = do
                sym <- U.findV nm
                if sidset `contains` sym.sid
                    then stio (Left (acc `including` nm.base))
                    else stio (Left acc)
        localvar sidset acc _ = stio (Left acc)
        // here we decide whether to translate the pattern binding
        // conservatively (let$1 = x; a = case let$1 of (a,b) -> a; b = ...
        // or to a case (which is actually done in sublet later)
        pbind :: Symtab -> (String, [String]) -> StG Symtab
        pbind env (k, deps)
            | k ~ #^let\$\d+$#,
              Just (SymV {pos,expr = Just (Lam {pat,ex})}) <- lookup env k = do
                let patnms = keys (U.patNames pat)
                // for n patnames we need n² unique names
                uniqs <- mapSt (mapSt (const U.uniqid)) [ patnms | a <- patnms ]
                U.logmsg TRACE7 pos (display patnms ++ " = " ++ show uniqs)
                if any (`elem` patnms) deps  // if any dependency is contained in pat names
                    then stio (conservative ex pat patnms uniqs)
                    else stio (fold Tree.delete env patnms)
            | otherwise = stio env
            where
                conservative ex pat patnms uss = result where
                    symv = unJust (env.lookup k)
                    env1 = env.update k symv.{expr = Just ex}
                    patsyms = zip uss [ (n, unJust (env.lookup n)) | n <- patnms ]
                    result = fold (mkCase pat patnms) env1 patsyms
                mkCase pat patnms env (us,(k,sym@(SymV {expr=Just v}))) =
                    env.update k sym.{expr=Just cas} where
                        pos = sym.pos
                        ex  = Vbl {pos, name=Local k, typ=Nothing}
                        ev  = fold mkPatvar Nil (zip us patnms)
                        cas = Case CNormal v [CAlt {pos,pat,ex,env=ev}] Nothing
                        mkPatvar t (u,v) = insert t v (U.patLocal pos v).{sid=u}
                mkCase _ _ _ _ = error "mkCase: no var"
unrollLet x = stio (Left x)

easyX x = do
        g <- getST
        (y, evts) <- makeEasy x
        unless (null evts) do
            U.logmsg TRACE9 (getpos x) ("uneasy expr: " ++ nice x g)
        let nx = fold mkLet y evts
        unless (null evts) do
            U.logmsg TRACE9 (getpos x) ("eased  expr: " ++ nice nx g)
        stio (Left nx)
    where
        mkLet ex env = Let {defs=[], ex, env, typ=ex.typ}
        isEasy (App a b _)       = isSimple a `and` isSimple b
        isEasy (Let {env,ex})    = isEasy ex `and`
                                   all isEasy [ x | SymV {expr = Just x} <- values env ]
        isEasy (Lam {ex})        = isEasy ex
        isEasy (Case {ex,alts})  = isSimple ex `and` all (isEasy • CAlt.ex) alts
        isEasy (Ifte a b c _)    = isSimple a `and` isEasy b `and` isEasy c
        isEasy (Ann {ex})        = isEasy ex
        isEasy x                 = isSimple x

        makeEasy x | isEasy x    = stio (x, [])
        makeEasy (x@Lam {ex, env}) = with env do        // so as to avoid bad symbols
            (ex, envs) <- makeEasy ex
            stio (x.{ex = fold mkLet ex envs}, [])
        makeEasy (x@App (Lam {env,pat,ex}) b t) = do
            g <- getST
            let cas = Case CNormal b [CAlt {pat, ex, env, pos = getpos x}] t
            U.logmsg TRACE9 (getpos x) ("beta reduction:  " ++ nice x g ++ "  ==>  "
                                        ++ nice cas g)
            makeEasy cas
        makeEasy (x@App _ _ _)     = makeSimple x
        makeEasy (x@Let {defs})    = stio (x, [])       // will be made easy recursively
        makeEasy (x@Case {ex})     = do
            (ex, envs) <- makeSimple ex
            stio (x.{ex}, envs)                         // alts will be made easy recursively
        makeEasy (x@Ifte a b c t)  = do                 // branches will be made easy recursively
            (a, envs) <- makeSimple a
            stio (Ifte a b c t, envs)
        makeEasy x = do
            g <- getST
            U.error (getpos x) ("don't know how to make easy:  " ++ nice x g)
            stio (x, [])

        makeSimple x | isSimple x = stio (x, [])
        makeSimple (x@App a b t) = do
            (a, ea) <- makeSimple a
            (b, eb) <- makeSimple b
            stio (App a b t, ea++eb)
        makeSimple (x@Lam {typ = Just s, ex}) = do
            g <- getST
            // (ex, envs) <- makeEasy ex
            u <- U.uniqid
            let pos = getpos x
                nm = U.unusedName (Local ("ƒ" ++ show u ++ "_" ++ show pos)) g
                sym = (U.patLocal pos nm.base).{typ = s, expr = Just x, state = Typechecked }
                vbl = Vbl {pos, name=nm, typ = x.typ}
            env <- nested Nil (U.enter sym)
            stio (vbl, env:[])
        makeSimple (x@Let {env,ex}) = do        // foo x = f (let x = ... in x) x
                g <- getST                      // float let higher: let xa = ... in f xa x
                x <- foldSt (replace g) x (values env)
                let newsyms = map (rename g) (values x.env)
                env <- nested Nil (foreach newsyms U.enter)
                (ex, envs) <- with env (makeSimple x.ex)
                stio (ex, envs ++ [env])
            where
                replace g x sym                 // replace references to sym with new name
                    | Just _ <- (Symbol.name sym).find g = do
                        let nm = U.unusedName (Symbol.name sym) g
                        replName (Symbol.sid sym) nm x
                    | otherwise = stio x
                rename g sym = Symbol.{name = nm} sym where
                        nm = U.unusedName (Symbol.name sym) g
        makeSimple (x@Case {typ = Just sig}) = do
                g <- getST
                let pos = getpos x
                    nm = U.unusedName (Local ("case" ++ show pos)) g
                    sym = (U.patLocal pos nm.base).{typ = sig, expr = Just x, state = Typechecked }
                    vbl = Vbl {pos, name=nm, typ = x.typ}
                env <- nested Nil (U.enter sym)
                stio (vbl, env:[])
        makeSimple (Ifte a b c t) = do
                (a, envsa) <- makeSimple a
                (b, envsb) <- withEnvs envsa (makeSimple b)
                (c, envsc) <- withEnvs (envsa++envsb) (makeSimple c)
                stio (Ifte a b c t, envsc ++ envsb ++ envsa)
            where
                withEnvs [] action = action
                withEnvs (e:es) action = with e (withEnvs es action)
        makeSimple x = do
            g <- getST
            U.error (getpos x) ("don't know how to make simple:  " ++ nice x g)
            stio (x, [])

/**
 * [returns} *@true@* if expression is simple. See 'pass9' for more information.
 *
 * A simple exression can be translated to a java expression and will not need
 * blocks, if-then-else constructs, auxiliary declarations etc.
 */
isSimple (App a b _)     = isSimple a `and` isSimple b
isSimple (Ifte a b c _)  = isSimple a `and` isSimple b `and` isSimple c
isSimple (Ann {ex})      = isSimple ex
isSimple (Vbl {pos})     = true
isSimple (Lit {pos})     = true
isSimple (Con {pos})     = true
isSimple _               = false

/// return the symbol ids of all local variables introduced in this expression and its subexpression
innerSids ex = U.foldEx true collect Nil ex
    where
        envSids env = map Symbol.sid (values env)
        collect t (Lam {env}) = stio (Left (fold including t (envSids env)))
        collect t (Let {env}) = stio (Left (fold including t (envSids env)))
        collect t (Case {alts}) = stio (Left (fold union t (map altSids alts)))
        collect t x = stio (Left t)
        altSids (CAlt {env}) = fromKeys (envSids env)

/// @replSid sid r ex@ - replace variables referncing sid with r in ex
replSid sid r ex = U.mapEx true action ex
    where
        action (v@Vbl {name=Local _}) = do
            sym <- U.findV v.name
            if sym.sid == sid then stio (Right r) else stio (Right v)
        action x = stio (Left x)

//// @replName sid nm ex@ - rename variables that references sid in ex
replName sid nm ex = U.mapEx true action ex
    where
        action (v@Vbl {name}) = do
            sym <- U.findV name
            if sym.sid == sid then stio (Right v.{name=nm}) else stio (Right v)
        action x = stio (Left x)


closedLambda (x@Let {env,ex}) | length vals > 1 = do
        g <- getST
        freevbls <- toPass
        case freevbls of
            [] -> with env do
                gsyms  <- mapSt globalize vals
                foreach gsyms U.enter
                let vgs = zip vals gsyms
                syms   <- mapSt (mkGlobal vgs) vgs
                newlet <- foldSt replsym ex vgs
                U.logmsg TRACE8 pos ("changed  " ++ nice newlet g)
                foreach syms U.changeSym
                foreach (map Symbol.name syms) closedLambdaName
                stio (Left newlet)
            xs -> do
                U.error (getpos x) ("implementation restriction: mutual recursive local functions"
                    ++ " that use variables bound in enclosing lexical scopes"
                    ++ " are currently not supported.")
                U.hint ">" ("functions: " ++ joinStr ", " (map (flip nice g • Symbol.name) vals))
                U.hint ">" ("variables: " ++ joinStr ", " (map (flip nice g • Symbol.name) freevbls))
                U.hint ">" ("There are two possible workarounds:")
                U.hint ">" ("1. If possible, make " ++ show (length vals - 1) ++ " functions local to the remaining one.")
                U.hint ">" ("2. Pass the variables as arguments.")
                stio (Left x)
    where
        pos = getpos x

        vals :: [Symbol]
        vals = values env

        exprs :: [Expr]
        exprs = map (unJust • Symbol.expr) vals

        freeSym :: Expr -> StG [Symbol]             // free variables in expression
        freeSym x = do
                used  <- with env (U.localSyms x)
                inner <- with env (innerSids   x)
                stio (filter (not • (inner `contains`) • Symbol.sid) (keys used))

        toPass :: StG [Symbol]           // symbols we must pass to each global val
        toPass = do
            exsyms <- mapSt freeSym exprs
            stio ((uniq • sort) [ s | ss <- exsyms, s <- ss, s `notElem` vals ])

        globalize :: Symbol -> StG Symbol
        globalize sym = do
            g <- getST
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            stio sym.{name, sid=0, expr = Nothing}

        replsym :: Expr -> (Symbol, Symbol) -> StG Expr
        replsym x (sym,gsym) = replName sym.sid gsym.name x


        mkGlobal :: [(Symbol, Symbol)] -> (Symbol,Symbol) -> StG Symbol
        mkGlobal vgs (sym,gsym) = do
            let ex = unJust sym.expr
            ex <- foldSt replsym ex vgs
            // sym <- globalize sym
            g <- getST
            U.logmsg TRACE8 pos ("global: " ++ gsym.name.nice g ++ " = " ++ nice ex g)
            let typ = ForAll (U.freeTVars [] sym.typ.rho) sym.typ.rho
            stio gsym.{expr = Just ex, typ}

        closedLambdaName nm = do
            symv <- U.findV nm
            closedLambdaSym symv

closedLambda (Let {env=letenv,ex=letex,typ=lettyp})
        | [(x,sym)] <- each letenv,          // let x = ... in ex
          Just lam <- sym.expr,           // let x = y   in ex
          Lam {pat,env,ex,typ} <- lam = with letenv do           // let x = \_ -> ... in ex
    ex    <- with env (U.mapEx true closedLambda ex)
    used  <- with env (U.localSyms ex)
    inner <- with env (innerSids ex)
    let thisSids = fold including inner (sym.sid:[ sid | SymV {sid} <- values env ])  // including x
    if all (thisSids `contains`) ((map Symbol.sid • keys) used)         // ex uses only x and
        then do
            g <- getST
            let name = U.unusedName (VName g.thisPack x)  g
            ex <- with env (replName sym.sid name ex)  // no reference to x anymore
            letex <- replName sym.sid name letex  // in the inner of the lambda or the let ex
            let lamx = Lam {pat,env,ex,typ}
            let typ  = ForAll (U.freeTVars [] sym.typ.rho) sym.typ.rho
            U.enter sym.{sid = 0, name, expr = Just lamx, vis = Private, typ}
            U.logmsg TRACE8 sym.pos ("let " ++ x ++ " = " ++ nice lamx.untyped g ++ " in ... replaced with " ++ nice letex.untyped g)
            U.logmsg TRACE8 sym.pos ("new function is " ++ name.nice g)
            closedLambda letex       // other opportunities possible here
        else do
            U.changeSym sym.{expr = Just (Lam {pat,env,ex,typ})}
            letex <- U.mapEx true closedLambda letex
            env <- getTop
            stio (Right (Let {env,ex=letex,typ=lettyp,defs=[]}))



closedLambda (Lam {pat,env,ex,typ = Just sigma}) = do
        ex    <- with env (U.mapEx true closedLambda ex)     // recurse
        used  <- with env (U.localSyms ex)                 // find local vars used
        inner <- with env (innerSids ex)
        let thisSids = fold including inner  [ sid | SymV {sid} <- values env ]
        if all (thisSids `contains`) ((map Symbol.sid • keys) used)
            then do
                g <- getST
                // u <- U.uniqid
                let name = U.unusedName (VName g.thisPack ("anon" ++ show (getpos ex))) g
                    lamx = Lam {pat,env,ex,typ = Just sigma}
                    sym0  = U.patLocal (getpos ex) "anonymous"
                    typ   = ForAll (U.freeTVars [] sigma.rho) sigma.rho
                    sym   = sym0.{name, expr=Just lamx, vis=Private, typ}
                    var   = Vbl {pos=sym.pos, name, typ = Just sigma}
                U.enter sym
                U.logmsg TRACE8 sym.pos ("anonymous lambda  " ++ lamx.untyped.nice g ++ " replaced with " ++ var.nice g)
                stio (Right var)
            else stio (Right (Lam {pat,env,ex,typ = Just sigma}))

closedLambda x = stio (Left x)

/* ############################### strictness analysis ########################## */
/**
 * [usage] @lambdaStrictess x@
 * [returns] a list of 'Strictness' items derived from patterns of the lambda in @x@
 *           or the empty list if @x@ is not a lambda
 * [see]     'patternStrictness'
 */
lambdaStrictness (x@Lam {env,pat,ex}) = with env do
        sx <- lambdaStrictness ex
        sp <- patternStrictness pat
        stio (sp:sx)
lambdaStrictness x = stio []        // not a lambda

/**
 * [usage] @patternStrictness pat@
 * [returns] the 'Strictness' value for the 'Pattern' @pat@
 * [requires] The environment where the pattern bound variables are held must be active.
 * [see] 'productCon'
 *
 * A pattern is /strict/, if it is /refutable/ or if it contains strict variables.
 * A pattern is /refutable/ if the match can possibly fail. Variables and product constructor
 * applications that contain only irrefutable patterns are irrefutable.
 */
patternStrictness p = case p of
        PVar {var} -> do
            v <- U.findV (Local var)
            stio v.strsig
        PAt {pos,var,pat} -> do
            ps <- patternStrictness pat
            if ps == U then patternStrictness (PVar {pos,var}) else stio ps
        PStrict {pat} -> do
            ps <- patternStrictness pat
            if ps == U then stio (S[]) else stio ps
        PLit {pos} -> stio (S[])
        PMat {pos} -> stio (S[])
        PAnn {pat} -> patternStrictness pat
        PCon {pos,qname,pats} = do
                g <- getST
                if not (productCon qname g) then stio (S[])
                  else do
                    ps <- mapSt patternStrictness pats
                    if all (U==) ps then stio U else stio (S ps)
        PConFS {pos} -> U.fatal pos ("patternStrictness: found PConFS") // not allowed anymore at this time

/**
 * [usage] @patternRefutable g pat@
 * [returns] *true* if the pattern is refutable, *false* otherwise
 */
patternRefutable g p = case p of
    PVar {var}      -> false
    PLit {pos}      -> true
    PMat {pos}      -> true
    PCon {pos,pats} -> not (productCon p.qname g) `or` any (patternRefutable g) pats
    _ | p.{pat?}    -> patternRefutable g p.pat
      | otherwise   -> false

/**
 * [usage] @productCon name g@
 * [returns] *@true@* if @name@ names a constructor of a product type in @g@,
 *           *@false@* if it is the name of a sum type
 * [requires] @name@ must name a member of a data type in @g@
 */
productCon (MName tname _) g = case tname.findit g of
        Just (SymT {product}) -> product
        other -> error ("productCon " ++ tname.nice g ++ " is not a type")
productCon _ _ = false

/**
 * check a name for strictness, sids are already being checked
 */
strictName sids nm = do
    g <- getST
    v <- U.findV nm
    when (v.state != StrictChecked) do
        U.logmsg TRACES v.pos ("strictness analysis for " ++ v.nice g)
    let ari = U.arity v
    case v of
        SymV {state = StrictChecked} = stio []          // do nothing
        SymV {nativ = Just _} -> do
            let strsig = S (take ari allStrict)
            U.logmsg TRACES v.pos ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig)
            U.changeSym v.{strsig, state = StrictChecked}
            stio []
        SymV {expr = Just (x@Lam {env,ex})} -> do
            (x, syms) <- strictness (v.sid:sids) x
            s <- lambdaStrictness x     // collect strictness from patterns
            U.logmsg TRACES v.pos ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show (S s)
                                    ++ " ignoring "
                                    ++ joinStr ", " (map (flip nice g • Symbol.name) syms))
            U.changeSym v.{expr = Just x, strsig = S s, state = StrictChecked}
            stio syms
        SymV {expr = Just x} | ari >= 0 = do
                y <- eta ari x
                (y, syms) <- strictness (v.sid:sids) y
                s <- lambdaStrictness y
                let x = uneta ari y
                U.logmsg TRACES v.pos ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show (if null s then U else S s))
                U.changeSym v.{expr = Just x, strsig = if null s then U else S s, state = StrictChecked}
                stio syms
            where
                eta 0 x = stio x
                eta n x = do
                    uniqs <- mapSt (const U.uniqid) (take n (repeat 0))
                    let vars = [ "$" ++ show n | n <- uniqs ]
                        pos  = getpos x
                        mkapp ex n = nApp ex (Vbl {pos, name=Local n, typ = Nothing})
                        // mklam :: Expr -> Int -> Expr
                        mklam ex n = Lam {env,pat,ex,typ=Nothing}
                            where pat = PVar {pos,var="$" ++ show n}
                                  env = insert Nil pat.var (U.patLocal pos pat.var).{sid=n}
                        // \a\b -> x a b
                        body = fold mkapp    x vars
                        lam  = fold mklam body (reverse uniqs)
                    stio lam
                uneta n x = unapp n • unlam n $ x
                    where unlam 0 x = x
                          unlam n (Lam {ex}) = unlam (n-1) ex
                          unlam _ _ = error "unlam: no Lam"
                          unapp 0 x = x
                          unapp n (App a b _) = unapp (n-1) a
                          unapp _ _ = error "unapp: no App"

        SymV {state} -> do              // pointless style or just var
            let strsig = if ari == 0 then U else S (take ari allLazy)
            U.logmsg TRACES v.pos ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig)
            U.changeSym v.{strsig, state = StrictChecked}
            stio []
        other -> U.fatal other.pos ("strictness: strange symbol  " ++ other.nice g)


/**
 * [_usage_] @strictness sids x@
 * [_returns_] a possibly modified expression and a list of local symbols that appear strict
 *           under the assumption that @x@ itself is strict
 * [_requires_] environment must be set up correctly and the list @sids@ contains the
 *            symbol numbers of all named functions that are recursively checked to
 *            avoid infinite recursion
 *
 * Strictness rules for various expressions:
 * 1. if @\p -> x@ is strict then @x@ is strict
 * 2. if @case x of alt1;...@ is strict, then @x@ is strict if the pattern in the first
 *    case alternative is strict. Non immediate local
 *    names from subexpressions are strict only when they appear strict in all alternatives.
 * 3. if local variable @v@ is strict, then @v@ is strict
 * 4. if application @f a b c@ is strict, and @f@ is a variable, @f@ is strict
 * 5. if application @g x y@ is strict, and g has a strictness signature, then
 *      the arguments are strict if the signatur at the corresponding position is.
 *      Otherwise, if @g@ is checked recursively, assume all arguments as strict.
 *      If @g@ is encountered the first time, look at @g@'s lambda and use
 *      the lambda strictness for the arguments
 * 6. if g is checked recursively, all argmnets are strict
 * 7.
 */
strictness :: [Int] -> Expr -> StG (Expr, [Symbol])
strictness sids x = do
        g <- getST
        U.logmsg TRACES (getpos x) ("strictness for: " ++ nice x g)
        let mine = if x.{env?} then map Symbol.sid (values x.env) else []
            my   = filter ((`elem`    mine) • Symbol.sid)
            them = filter ((`notElem` mine) • Symbol.sid)
        case x of
            Vbl {name=Local _} -> do
                    v <- U.findV x.name
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g [v])
                    stio (x, [v])
            Vbl {name} -> do
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g [])
                    stio (x, [])
            Con {name} ->  do
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g [])
                    stio (x, [])
            Ifte c a b t -> do
                    (c, sc) <- strictness sids c
                    (a, sa) <- strictness sids a
                    (b, sb) <- strictness sids b
                    let syms = sc `uni` (sa `inter` sb)
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g syms)
                    stio (Ifte c a b t, syms)
            Let {env,ex} -> with env do
                    let ve = values env
                    results <- mapSt (strictName sids) // (map Symbol.sid (my syms)))
                                (map Symbol.name
                                    (filter ((`notElem` sids) • Symbol.sid)
                                        ve))
                    (ex, syms) <- strictness sids ex
                    let strictSyms = my syms
                        sSsids = map Symbol.sid strictSyms
                        upper = [ sres  | (sym, sres) <- zip ve results,
                                        Symbol.sid sym `elem` sSsids ]
                        result = fold uni (them syms) upper
                    foreach strictSyms mark
                    env <- getTop
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g result)
                    stio (x.{env,ex}, result)
            Lit {pos} ->  do
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g [])
                    stio (x, [])
            App _ _ _ -> do
                    (fx, syms) <- appstr (U.flatx x)
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g syms)
                    stio (U.unflatx fx, syms)
            Lam {env,ex} -> with env do
                    (ex, syms) <- strictness sids ex
                    foreach (my syms) mark
                    env <- getTop
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g (them syms))
                    stio (x.{env,ex}, them syms)
            Case {ex,alts} -> do
                    altsyms <- mapSt strictAlt alts
                    let alts = map fst altsyms
                        syms = foldl1 inter (map snd altsyms)
                    // extract S[...] of patterns
                    s1 <- with (head alts).env do patternStrictness (head alts).pat
                    ss <- foldSt unisa s1 (tail alts)
                    (ex, xsyms) <- apply ex ss         // take advantage of S[.....] if possible
                    U.logmsg TRACES (getpos x) ("strictness  " ++ nice x g ++ " :: " ++ names g (uni syms xsyms))
                    stio (x.{ex, alts}, uni syms xsyms)
            Ann {ex} -> do
                    (ex,syms) <- strictness sids ex
                    stio (x.{ex}, syms)
            _ -> do
                U.error (getpos x) ("no strictness rule, turn on -xs -xr " ++ show (getpos x))
                stio (x, [])
    where
        names g = show • map (flip QName.nice g • Symbol.name)
        inter as = filter (\b -> elemBy (using Symbol.sid) b as)
        uni as bs = as ++ [ b | b <- bs, not (elemBy (using Symbol.sid) b as)]
        unisa :: Strictness -> CAlt -> StG Strictness
        unisa sleft alt = do
            sright <- with alt.env do patternStrictness alt.pat
            stio (uniss sleft sright)
          where
            uniss (S s1) (S s2) = S (zipWith uniss s1 s2)
            uniss U _ = U
            uniss x U = x


        // mark a symbol as strict
        mark sym = do
            g <- getST
            U.logmsg TRACES (Symbol.pos sym) (nice sym.name g ++ " marked as strict")
            when (sym.strsig == U) do U.changeSym sym.{strsig = S[]}
        // strictness for case alternative, same as in lambda
        strictAlt (alt@CAlt {env,pat,ex}) = do
                (lam, syms) <- strictness sids (Lam {env,pat,ex,typ=Nothing})
                stio (alt.{env=lam.env, ex=lam.ex}, syms)
        subapp (a,b)   = apply a b
        apply ex U     = do
                            (x,_) <- strictness sids ex
                            stio (x, [])      // lazy
        apply ex (S[]) = strictness sids ex // strict
        apply ex (S ss) = do
            g <- getST
            case U.flatx ex of
                fex@((Con {name},_):xs) | productCon name g, length ss == length xs = do
                        U.logmsg TRACES (getpos ex) ("apply " ++ show (S ss)
                                                        ++ " to " ++ nice ex g)

                        exsyms <- mapSt (\(a,b) -> apply a b) (zip (map fst xs) ss)
                        let exs = map fst exsyms
                            syms = foldl1 uni (map snd exsyms)
                            flat = head fex : zip exs (map snd xs)
                        U.logmsg TRACES (getpos ex) ("apply found: " ++ names g syms)
                        stio (U.unflatx flat, syms)
                _ -> strictness sids ex
        convar (Con {name}) = true
        convar (Vbl {name}) = true
        convar _ = false
        appstr (app@((f,mbt):as)) | not (convar f) = do
            (f,syms) <- strictness sids f
            fas <- mapSt (strictness sids) (map fst as)
            let nas = zip (map fst fas) (map snd as)
            stio ((f,mbt):nas, syms)
        appstr (app@((f,mbt):as)) = do
            g <- getST
            v <- case f of
                    Con {name} -> U.findD name
                    Vbl {name} -> U.findV name
                    _ -> U.fatal (getpos f) ("Can't handle " ++ nice f g ++ "  applications")
            let fsym | Local _ <- v.name = [v]
                     | otherwise = []
                mkAll = do
                    fapp <- mapSt (strictness sids) (map fst app)
                    let napp = zip (map fst fapp) (map snd app)
                    stio (napp, fsym)
            case v of
                SymV {state = Typechecked, expr = Nothing} = mkAll
                SymV {state = Typechecked, expr = Just (Lam {env})} = if v.sid `elem` sids
                        then do
                            // assume all are strict
                            asx <- mapSt (strictness sids) (map fst as)
                            stio ((f,mbt):zip (map fst asx) (map snd as), fold uni fsym (map snd asx))
                        else do
                            strictName sids v.name
                            appstr app              // repeat
                SymV {state = Typechecked, expr = Just x}
                    | v.sid `notElem` sids = do
                            // inline pointless
                            let fx = U.flatx x
                            (fxas, syms) <- appstr (fx ++ as)
                            let as = drop (length fx) fxas
                            stio ((f,mbt):as, fsym ++ syms)
                    | otherwise = mkAll
                SymD {strsig = U} -> mkAll
                SymD {strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     // make sure enough
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {state = StrictChecked, strsig = U} -> mkAll
                SymV {state = StrictChecked, strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     // make sure enough
                        U.logmsg TRACES (getpos f) ("appstr: xss=" ++ show xss ++ " for " ++ v.name.nice g)
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {sid} -> do
                    U.fatal (v.pos) ("appstr: unexpected symbol " ++ nice v g
                        ++ ", state=" ++ show v.state
                        ++ ", expr="  ++ show (isJust v.expr))
                _ -> error "appstr: no appropriate sym"
        appstr _ = error "appstr: []"

/**
 * [usage] @patsComplete g [pat, ...]@
 * [return] @Just p@ where @p@ is a pattern that is missing in the set or @Nothing@
 *      if the set of patterns is /complete/.
 * [required] the list of patterns must not be empty
 *
 *
 * A set of patterns is complete if it contains at least one irrefutable pattern
 * or if all possible literals / constructors are listed and for every constructor
 * the set of the subpatterns is complete.
 */
patsComplete g [] = Just (PVar {pos=0, var = "unguarded"})  // if all case alts carry open case when
patsComplete g ps
    // Prelude.traceLn ("patsComplete [" ++ joinStr "," (map (flip nice g) ps) ++ "]") = undefined
    // Prelude.traceLn ("patsComplete [" ++ joinStr "," (map (show • not • patternRefutable g) ps) ++ "]") = undefined
    | any (not • patternRefutable g) ps = Nothing
    | otherwise                         = missing canonicPats
    where
        // refutables  = filter (patternRefutable g) canonicPats
        canonicPats = map canonic ps
        // only PCon, PLit and PVar are considered
        canonic (PMat {value}) = PLit {pos=0, kind = LRegex, value}
        canonic (p@PCon {pos}) = p.{pats <- map canonic}
        canonic p | p.{pat?}   = canonic p.pat
        canonic p              = p
        pany                   = PVar {pos=0, var = "_"}
        // compute the missing element from a list of refutable patterns
        missingLiteral [] = Just pany
        missingLiteral ls | any regex ls = Just (PLit {pos=0, kind=LString,
                                            value="\"any string not matched by regular expression\""})
            where regex (PLit {kind = LRegex}) = true
                  regex _                      = false
        missingLiteral (ps@PLit {kind}:_) = Just (PLit {pos=0, kind, value})
            where value = (head • filter (`notElem` (map Pattern.value ps))) (lany kind)
                  lany LBool = ["true", "false", "blödsinn"]
                  lany LString = U.allBinders
                  lany LChar   = map show (iterate Char.succ '!')
                  lany LInt    = map show (iterate Int.succ 42)
                  lany LLong   = map show (iterate Long.succ 42L)
                  lany LBig    = map show (iterate Integer.succ 42n)
                  lany LDouble = map show (iterate (0.42*)  3.14159)
                  lany LFloat  = map show (iterate (0.42f*) 3.14159f)
                  lany LRegex  = U.allBinders
        missingLiteral _ = Just pany
        // compute the missing element from a list of refutable patterns
        missing [] = Just pany                              // _
        missing (ps@(PLit {kind=LBool}:_)) = case map Pattern.value ps of
            tfs -> if all (`elem` tfs) ["true", "false"]
                then Nothing
                else missingLiteral ps
        missing (ps@(PLit {pos}:_))   = missingLiteral ps
        missing (ps@(PCon {qname}:_))
            | s:_ <- filter (not • (`elem` pnames) • Symbol.name) (cons qname) = Just (mkCon s)
            | otherwise = case (filter isJust • map groupcheck) (group ps) of
                some:_ -> some
                []  -> Nothing
            where
                pnames = map Pattern.qname ps
                cons (MName tname _) = case QName.findit tname g of
                    Just (SymT {env}) -> U.envConstructors env
                    _ -> []
                cons _ = []
                mkCon (SymD {name,flds}) = PCon {pos=0, qname=name,
                                                    pats = map (const pany) flds}
                mkCon _ = error "mkCon: no constructor"
                group [] = []
                group (PCon {qname,pats}:ps) = (qname, pats:map Pattern.pats same):group other
                    where
                        same  = filter ((`==` qname) • Pattern.qname) ps
                        other = filter ((`!=` qname) • Pattern.qname) ps
                group _ = error "group: no PCon"
        missing _ = error "missing: bad patterns"
        // check a group of patterns (QName, [[p11, p12, p13], [p21, p22, p23], ...])
        groupcheck (qname, [])    = Just pany                   // cannot happen
        groupcheck (qname, []:_)  = Nothing                     // nullary constructor
        groupcheck (qname, patss) = anongroup (PCon 0 qname) patss
        // [true, 2, c1]
        // [false, b2, 3]
        // [_, 1, _]            // irefs
        anongroup recon grp
            | length (head grp) == 1 = result (patsComplete g col1)     // base case
            | all (not • patternRefutable g) col1 = // the first column has only irrefutables
                anongroup (\ps -> recon (pany:ps)) cols
            | all (patternRefutable g) col1 = anonRgrp recon grp
            | Nothing <- anongroup recon irefs = Nothing
            | Nothing <- anonRgrp recon refs = Nothing
            // there are some patterns with refutable heads and some with irrefutable ones
            | otherwise = anonRgrp  recon (refs ++ nrefs)
            where
                col1 = map head grp
                cols = map tail grp
                result Nothing = Nothing
                result (Just p) = Just (recon (p : map (const pany) (head cols)))
                (refs, irefs) = partition (patternRefutable g <~ head) grp
                nrefs = [ p:rest | _:rest <- irefs, p <- cons ]
                cons = constructors (head (head refs))
                // constructors :: Pattern -> ([Pattern] ->
                constructors (lit@PLit {kind=LBool}) = [ lit.{value=s} | s <- ["true", "false"] ]
                constructors (con@PCon {qname=MName tname _}) = case QName.findit tname g of
                    Just (SymT {env}) ->
                        [ PCon con.pos sym.name (take (length sym.flds) dummies) |
                            (sym::Symbol) <- U.envConstructors env ] where
                                dummies = repeat (PVar con.pos "_")
                    _ -> []
                constructors _ = []
                // [[Just 1, a1, a2]         // refs
                //  [Just x, b1, b2]]
                // [[Nothing, c1, c2]]            // irefs
                // transform this to  [[1, a1, a2], [x, b1, b2]]  and [[c1,c2]]
                // then check each as anon group
                anonRgrp recon grp
                    | Just x <- patsComplete g col1 = Just (recon (x : map (const pany) (head cols)))
                    | otherwise = loop groups
                    where
                        constructor (PCon {qname}) = qname
                        constructor (PLit {value}) = Local value
                        constructor _ = error "constructor: ?"
                        subpats (PCon {pats}) = pats
                        subpats _             = []
                        recreate (PCon {pos, qname}) = PCon pos qname
                        recreate x                   = const x
                        groups = group grp
                        group [] = []
                        group ps = pss1 : group xs where
                          p1c = constructor (head (head ps))
                          (pss1, xs) = partition samecon ps
                          samecon p = constructor (head p) == p1c
                        col1 = map head grp
                        cols = map tail grp
                        loop [] = Nothing           // complete!
                        loop (grp:grps) = case anongroup (f rest.length) ung of
                                Nothing -> loop grps
                                other   -> other
                            where
                                rec  = recreate (head (head grp))
                                rest = subpats  (head (head grp))
                                ung  = map uncon grp
                                uncon (p:ps) = subpats p ++ ps
                                uncon [] = undefined
                                f n xs = recon (rec (take n xs) : drop n xs)

/**
 * checks whether an expression is a case expression made from a guard (CWhen)
 * that has no trailing otherwise or irrefutable pattern match
 * If so, returns the expression or pattern that could cause the CaseWhen to fall through
 */
openCaseWhen :: Global -> Expr -> Maybe (Either Expr Pattern)
openCaseWhen g (Case CWhen _ [alt1, alt2] _) = openCaseWhen g alt2.ex
openCaseWhen g (e@Case CWhen x [alt1] _)
    |  caseOtherwise g e              = Nothing           // can't fall through
    |  isPTrue alt1.pat, !(isXTrue x) = Just (Left x)
    |  patternRefutable g alt1.pat    = Just (Right alt1.pat)
    |  otherwise = openCaseWhen g alt1.ex
openCaseWhen g (Let {ex}) = openCaseWhen g ex
openCaseWhen _ _ = Nothing

/**
 * tells if this is the pattern "true"
 */
isPTrue (PLit {kind=LBool, value="true"}) = true
isPTrue p | p.{pat?} = isPTrue p.pat
isPTrue _ = false

/**
 * tells if this is the constant "true"
 */
isXTrue (Lit {kind=LBool, value="true"}) = true
isXTrue (Vbl {name = VName p "otherwise"}) | p == pPrelude = true
isXTrue _ = false

/**
 * tells us if this is the "otherwise" case
 *  case true of true -> notopencase
 */
caseOtherwise g (Case CWhen x [alt] _)
    | isCaseWhen alt.ex = false
    | isXTrue x && isPTrue alt.pat = true
    | otherwise = !(patternRefutable g alt.pat)
    where
        isCaseWhen (Case CWhen _ _ _) = true
        isCaseWhen _ = false
caseOtherwise _ _ = false                        