--- Type renaming for package names.
module frege.compiler.types.Packs where 

import  frege.compiler.types.NSNames

{--
 * A package name can not be read without resort to the global state,
 * because it includes the prefix given on the command line.
 * However, one can compare them, i.e. @p == P "frege.Prelude"@
 -}
abstract data Pack = P String where
    new s = P s
    un (P s) = s
    --- Make a namespace name from a package name by taking the trailing word characters
    --- For always-to-import Prelude packages, the namespace name is derived from 'preludePacks'
    nsName p | [n] <- [ NSX s | (p', Just s) <- preludePacks, p' == p ] = n
    nsName (P (m~#(\w+)$#)) = NSX (unJust (m.group 1))
    nsName (P s) = Prelude.error ("nsName: illegal package name " ++ s.show)

    (P a) ==  (P b) = a String.==  b
    (P a) <=> (P b) = a String.<=> b
    hashCode (P a) = String.hashCode a


instance Eq   Pack


instance Ord  Pack


derive   Show Pack


--- a prominent package
pPrelude = (Pack.new • fromMaybe "frege.Prelude" • System.getProperty) "frege.prelude"


pPreludeBase    = Pack.new "frege.prelude.PreludeBase"


pUtilRegex      = Pack.new "frege.java.util.Regex"


pPreludeText    = Pack.new "frege.prelude.PreludeText"


pPreludeList    = Pack.new "frege.prelude.PreludeList"


pPreludeMonad   = Pack.new "frege.prelude.PreludeMonad"


pPreludeMath    = Pack.new "frege.prelude.Math"


pControlSemi    = Pack.new "frege.control.Semigroupoid"


pPreludeArrays  = Pack.new "frege.prelude.PreludeArrays"


{-- List of Prelude packages and the namespace that needs to be assigned on import time

    These are automatically recognized as Prelude-Packages.

    For each of them, a java import will be generated and
    names from them appear in Class.name form in java code.

    If the package's namespace must be present at compile time,
    the second component of the tuple must be given as 'Just' @name@
-}
preludePacks = (pPreludeBase,  Just "PreludeBase") : map fppack [
                    -- ("Native", Just "PreludeNative"),     -- because of various literals
                    ("List",   Just "PreludeList"),       -- because of list comprehension
                    ("Text",   Just "PreludeText"),       -- because of derive Show
                    ("Monad",  Just "PreludeMonad"),      -- because of derive Show
                    ("IO",     Just "PreludeIO"),         -- because of derive Exceptional
                    ("Arrays", Just "PreludeArrays"),     -- because of derive ArrayElement 
               ] ++ [
                    (pUtilRegex, Just "Regexp"),          -- because of regex litreals & patterns 
               ]
       where
            fppack (s,mb) = (Pack.new ("frege.prelude.Prelude" ++ s), mb)


