{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
    Java code generation for the frege compiler

    This package deals with pattern matching and @case@ statements.
 -}


package frege.compiler.gen.Match where


import frege.Prelude hiding(apply)
import frege.List (Tree, values, keys, each, insert, lookup, insertkv, updatekv)
import Data.List as DL(sortBy, partitioned)


import frege.compiler.Data          as D
import frege.compiler.Utilities     as U() 
import frege.lib.PP()  -- (`<>`, `<+>`, `</>`, `<+/>`, `<~/>`, text, bracket)
import frege.compiler.Transform     as T(patternStrictness)
import frege.compiler.Typecheck     as TY()

import frege.compiler.gen.Util       as GU except(group, break)
import frege.compiler.gen.Const      as GC

infixr 6 `<>`

{--
  * [usage] @match assert pattern bind continuation bindings@
  * [returns] a list of java statements and an updated binding
  * generate code and/or extend current @bindings@ that performs and/or reflects
  * a match of @pattern@
  * against the java expression in @bind@ and generate the code for a successful match
  * by applying @continuation@ to the extended bindings.
  *
  * Generated code will look like this:
  * > comment
  * > auxiliary local definitions
  * > if (patternmatches) {
  * >           code generated by continuation
  * > }
  * If the @assert@ switch is on, this is the last possible match and
  * an assert statement is generated instead of the if. This is useful in 
  * code like:
  * > case foo of 
  * >   Just bar -> ...
  * >   Nothing -> ...
  * The @Nothing@ does not need matching if @bar@ was irrefutable.
  *
  * There does not have to be an @if@ or any other code at all, for example when
  * the pattern is irrefutable. The code generated by the continuation *must* return,
  * if the control flow reaches the closing brace of the if this will be
  * an indication that the pattern match failed.
  -}
match :: Bool 
            -> Pattern 
            -> Binding 
            -> (Tree Symbol Binding -> StG [JStmt]) 
            -> Tree Symbol Binding 
            -> StG (Binding, [JStmt])
match assert (PVar {uid,var}) bind cont binds = do
         vsym <- U.findV local
         if vsym.strsig.isStrict then strictVar vsym else lazyVar vsym
     where
         local = Local uid var
         jname g = (U.javaName g local).base
         strictVar vsym = do
             g <- getST
             (rbind, code) <- realize (jname g) (strictBind g bind)
             let stmt = if null code
                     then [sComment ("bind strict var " ++ nice (Symbol.name vsym) g
                                         ++ "  to  " ++ nice rbind g)]
                     else code
                 nbinds = insert binds vsym rbind
             rest <- cont nbinds
             stio (rbind, stmt++rest)
         lazyVar vsym = do
             g <- getST
             let nbinds = insert binds vsym bind
                 comment = "bind lazy var " ++ nice (Symbol.name vsym) g ++ "  to  " ++ nice bind g
             rest <- cont nbinds
             stio (bind, sComment comment:rest)
 
match assert (p@PAt {pat,uid,var}) bind cont binds = do
         g <- getST
         prm <- patternRMode pat
         let local = Local uid var
             jname = (U.javaName g local).base
         vsym <- U.findV local
         let vrm = if vsym.strsig.isStrict then RStrict else RLazy
             rm = min prm vrm
             ourBind = toMode g rm bind
             comment = sComment ("match " ++ nice p g ++ " with " ++ nice ourBind g)
         (rbind, code1) <- realize jname ourBind
         let nbinds = insert binds vsym rbind
         (xbind, code2) <- match assert pat rbind cont nbinds
         stio (xbind, comment : code1++code2)
 
match assert (pat@PLit {kind=LBool, value}) bind cont binds = do
     g <- getST
     -- (bind,code) <- realize "$" (notLazy bind)
     body <- cont binds
     let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ showJex (Binding.jex bind))
         sbnd = strictBind g bind
         jex = if value == "true" then sbnd.jex else JUnop "!" sbnd.jex
         ifc = if assert then JAssert jex : body else [JCond "if" jex body]
     stio (bind, comment:ifc)
 
match assert (pat@PCon {pos,qname,pats}) bind cont binds = do
         -- g <- getST
         symd <- U.findD qname                   -- forall a.a -> List a -> List a
         symt <- U.findT symd.name.tynm          -- forall a.List a
         if symt.enum then matchEnum symd symt
             else if symt.product
                 then if symt.newt
                     then match assert (head pats) bind cont binds
                     else matchProd    symd symt -- pat bind cont binds
                 else matchVariant symd symt -- pat bind cont binds
     where
         comment g = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ showJex (Binding.jex bind))
         -- matchNewt :: Symbol -> Symbol -> StG (Binding, [JStmt])
         -- matchNewt symd symt = match (head pats) bind cont binds
         matchEnum :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchEnum symd symt = do
             g <- getST
             let sbnd = strictBind g bind
             -- (bind, code1) <- realize "$" sbnd
             body  <- cont binds
             let comp = (JBin sbnd.jex "==" (JAtom (show symd.cid)))
                 ifc  = if assert then JAssert comp : body else [JCond "if" comp body]
             stio (sbnd, comment g : ifc)
 
         matchVariant :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchVariant symd symt = do
            g <- getST
 
            let box1 = strictBind g bind                        -- List Int
                tree = U.unifySigma g symt.typ bind.ftype     -- a -> Int
 
            rho <- U.substRho tree symd.typ.rho               -- Int -> List Int -> List Int
            (boxd, code1) <- realize "$" box1                 -- TList $1 = .....
            -- pss <- mapSt patternStrictness pats
            let datajt = sigmaJT g symt.typ                   -- TList
 
            let  -- smode = any Strictness.isStrict pss
                 cname = if symt.product then "" else conGetter qname   -- _DCons
                 vbind = if symt.product then boxd else
                            Bind RStrict boxd.ftype
                                (variantType g datajt symd).{targs = boxd.jtype.targs}
                                (JInvoke (JX.jexmem boxd.jex cname) [])
 
            (varb, code2) <- if symt.product then return (boxd, [])
                             else realize "$" vbind             -- TList.DCons $2 = $1._DCons()
 
            let bcon = varb -- if smode then varb else vbind
                scon = true -- symd.strsig.isStrict            
                (_,sigs)  = U.returnType rho               -- [b, List b]
                -- set up the expressions that are to be matched by sub patterns
                pbinds = zipWith (fldBind g varb) symd.flds sigs

            
            -- make sure refutable patterns are matched first so that
            -- evaluation of lazy values that are bound to variables does
            -- not occur before it is sure that the overall match succeeds
            let (zpats, zbinds) = (unzip • reverse • sortBy (comparing (T.patternRefutable g • fst))) 
                            (zip pats pbinds)
            rest <- matches assert zpats zbinds cont binds     
 
            let notnull = JBin varb.jex "!=" (JAtom "null")
                ifn = if symt.product
                        then rest
                        else if assert  then JAssert notnull : rest 
                                        else [JCond "if" notnull rest]
                
            stio (boxd, (comment g : code1) ++ code2 ++ ifn)
 
         matchProd :: Symbol -> Symbol -> StG (Binding, [JStmt])
         matchProd symd symt = matchVariant symd symt   -- for the time being
         
 
match assert (pat@PLit {kind=LString, value}) bind cont binds = do
     g <- getST
     (bind,code) <- realize "$" (strictBind g bind)
     body <- cont binds
     let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ showJex (Binding.jex bind))
         sbnd = strictBind g bind
         jex = JInvoke (JX.jexmem (JAtom value) "equals") [sbnd.jex]
         ifc = if assert then JAssert jex : body else [JCond "if" jex body]
     stio (bind, (comment:code) ++ ifc)
 
match assert (pat@PLit {kind, value}) bind cont binds
     | kind `elem` [LChar, LInt, LLong, LDouble, LFloat] = do
         g <- getST
         (bind,code) <- realize "$" (strictBind g bind)
         body <- cont binds
         let comment = sComment ("match  " ++ nice pat g
                                     ++ "  with  " ++ showJex (Binding.jex bind))
             sbnd = strictBind g bind
             jex = JBin (JAtom value) "==" sbnd.jex
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (bind, (comment:code) ++ ifc)
     | kind == LBig = do
         g <- getST
         (bind, code) <- realize "$" (strictBind g bind)
         body <- cont binds
         let comment = sComment ("match  " ++ nice pat g
                                     ++ "  with  " ++ showJex (Binding.jex bind))
             sbnd = strictBind g bind
             lit = Lit {pos = pat.pos, kind = LBig, value, typ = Just TY.sigInteger}
         jname <- findConst lit
         let xbnd =  Bind{mode=RStrict, 
                        ftype = TY.sigInteger, 
                        jtype = sigmaJT g TY.sigInteger, 
                        jex = JStMem{jname, targs = []}}
         let jex = JInvoke (JX.jexmem xbnd.jex "equals") [sbnd.jex]
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (bind, (comment:code) ++ ifc)
     | kind == LRegex = do
         g <- getST
         (bind,code) <- realize "$" (strictBind g bind)
         body <- cont binds
 
         let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ showJex (Binding.jex bind))
             sbnd = strictBind g bind
             lit = Lit {pos = pat.pos, kind = LRegex, value, typ = Just (TY.sigRegex)}
         jname <- findConst lit
         let xbnd = Bind{mode=RStrict, 
                        ftype = TY.sigRegex, 
                        jtype = sigmaJT g TY.sigRegex, 
                        jex = JStMem{jname, targs = []}}
 
         let matcher = JInvoke (JX.jexmem xbnd.jex "matcher") [sbnd.jex]
             jex = JInvoke (JX.jexmem matcher "find") []
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (bind, (comment:code) ++ ifc)
 
match assert (pat@PMat {pos, uid, var, value}) bind cont binds = do
         g <- getST
         vsym <- U.findV (Local uid var)
         (bind,code) <- realize "$" (strictBind g bind)
         let mjt = sigmaJT g TY.sigMatcher
         let comment = sComment ("match  " ++ nice pat g
                                 ++ "  with  " ++ showJex (Binding.jex bind))
             sbnd = strictBind g bind
             lit = Lit {pos, kind = LRegex, value, typ = Just (TY.sigRegex)}
 
         jname <- findConst lit
         let xbnd = Bind{mode=RStrict, ftype = TY.sigMatcher, jtype = mjt, 
                        jex = JStMem{jname, targs = []}}
         let mbnd = Bind RStrict (TY.sigMatcher) (strict mjt)
                     (JInvoke (JX.jexmem xbnd.jex "matcher") [sbnd.jex])
         (mbnd,code2) <- realize (U.javaName g (Local uid var)).base mbnd
         body <- cont (binds.insert vsym mbnd)
 
         let  jex = JInvoke (JX.jexmem mbnd.jex "find") []
              ifc = if assert then JAssert jex : body else [JCond "if" jex body]
         stio (bind, (comment:code) ++ code2 ++ ifc)
 
match assert (PAnn {pat})    bind cont binds = match assert pat bind cont binds
match assert (PUser {pat})   bind cont binds = match assert pat bind cont binds
match _ pat b c bs = do
     g <- getST
     stio (b, [JError ("match  " ++ nice pat g ++ "  with  " ++ showJex (Binding.jex b))])
 
-- {--
--  * A variant of 'match' that matches the components of a product against a pattern
--  *
--  * @pat@ must be a constructor application whose constructor is the same
--  * as given in @con@
--  -}
-- matchCon assert (PCon {pos,qname, pats}) con bexs cont binds = do
--         g <- getST
--         sym <- U.findD qname
--         if sym.sid != Symbol.sid con
--             then do
--                 U.fatal pos (text ("matchCon: " ++ nice qname g ++ " against " ++ nice con g))
--             else do
--                 -- make sure refutable patterns are matched first so that
--                 -- realization of strict variables does not occur outside an if
--                 ppbs = (reverse • sortBy (comparing (T.patternRefutable g • fst))) (zip pats bexs)
--                 matches assert (map fst ppbs) (map snd ppbs) cont binds
-- matchCon assert pcon con bexs cont binds = error "matchCon: no constructor"

--- Match a list of subpatterns against a list of subexpresssions 
matches assert []     []     cont binds = cont binds
matches assert (p:ps) (b:bs) cont binds = do
         (_, code) <- match assert p b (matches assert ps bs cont) binds
         stio code
matches assert _ _ _ _ = Prelude.error "matches: cannot happen when compiler is sane"
 

{--
    tell in which 'RMode' the case expression should best be computed to match pattern
-}
patternRMode p = do
    g <- getST
    case p of
        PVar {uid,var} -> do
            v <- U.findV (Local uid var)
            if v.strsig.isStrict
                 then stio RStrict
                 else stio RLazy
        PAt {pos,uid,var,pat} -> do
             rm <- patternRMode pat
             if rm == RLazy then patternRMode (PVar {pos,uid,var}) else stio rm
        PUser {pat, lazy} -> stio (if lazy then RLazy else RStrict)
        PLit {pos} -> stio RStrict
        PMat {pos} -> stio RStrict
        PAnn {pat} -> patternRMode pat
        PCon {pos,qname,pats} = do
                 g <- getST
                 if not (T.productCon qname g) then stio RStrict
                   else do
                     ps <- mapSt patternRMode pats
                     if all (RLazy==) ps then stio RLazy else stio RStrict
        PConFS {pos} -> U.fatal pos (text ("patternRMode: found PConFS")) -- not allowed anymore at this time
 
{--
  * [usage] @conGetter qname@
  * [return] the name of the method that gets the variant
  * [example] @conGetter (MName tname "Con")@ evaluates to @"_Con"@
  -}
conGetter (MName tname base) = "_" ++ mangled base
conGetter _ = error "conGetter: no member"
 
 
{--
  * [usage] @variantType g jtype symd@
  * [return] the type of the variant, i.e. @tMaybe.dJust<a>@, if jtype is the jt of the type
  -}
variantType :: Global -> JType -> Symbol -> JType
variantType g jtype symd    -- | traceLn("variantType for " ++ show jtype) || true 
    = jtype.{jname = U.javaName g (Symbol.name symd)}

    
{--
    generate method signature from strictness info and argument types
-}
argDefs g attr stri sigmas argNms
     | S ss <- stri = zipWith3 (argdef g attr) ss sigmas argNms -- (zip ss      (zip sigmas argNms))
     | otherwise    = zipWith3 (argdef g attr) allLazy sigmas argNms

argdef g attr s sig nm = (attr, sig, argType g (Strictness.isStrict s) sig, nm)


{--
    Compute the java type of a function/constructor argument.
    - strict type: a concrete type like @int@, @java.lang.String@, @TList@ or @Func@
    - lazy frege type: Lazy
    - otherwise: Object
    -}
argType :: Global -> Bool -> Sigma -> JType
argType g s t
    | s         = strict argjt
    | otherwise = lazy argjt
    where argjt = sigmaJT g t


{--
    Compute formal argument list for a eval method.
    By definition, all arguments must be Objects. (see @frege.runtime.Func@_N_)
    -}
evalArgDef attr sigmas argNms = zipWith (argdef attr) sigmas argNms
    where
        argdef attr sigma name = (attr, sigma, Lazy Something, name)     
{--
    convert an arg quadrupel to a 'Binding'
    -}
argBind = quadBind JAtom

quadBind f (_, sig, jt, s) = Bind (jtRmode jt) sig jt (f s)

{--
    Instantiate a field of an algebraic value at a given type.
    
     [value] the (strict) 'Binding' that holds the java expression for the value
     [field] the field in question
     [at] the type this is to be instantiated at
     
    Returns a new binding with the java expression that accesses the field.  
    -}
fldBind :: Global -> Binding -> ConField QName -> Sigma -> Binding
fldBind g value field at  = Bind{
        mode = jtRmode jty, 
        ftype = at, 
        jtype = jty , 
        jex = JExMem{jex=(strictBind g value).jex, name=unJust field.name, targs=[]}}
    where jty = argType g field.strict field.typ
