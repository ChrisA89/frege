--- Code that is (hopefully) common among several code generators

module frege.compiler.gen.Common where

import Data.TreeMap(values)

import Compiler.types.Global(StIO, Global, javaLangNames, primitiveTypes)
import Compiler.types.Symbols(SymD, SymT)
import Compiler.types.JNames(JName)
import Compiler.types.QNames(TName)
import Compiler.types.Packs(pPreludeIO, pPreludeArrays)
import Compiler.types.ConstructorField(ConField)
import Compiler.types.Tokens(Token)
import Compiler.enums.TokenID(QUALIFIER)
import Compiler.types.Types(Sigma, Rho, Tau,
                                ForAll, RhoFun, RhoTau, TApp, TCon, TVar,
                                Meta, TSig)
import Compiler.types.Kinds(KGen)
import Compiler.classes.Nice(nice)
import Compiler.gen.java.Abstract

import Compiler.Utilities as U(unifySigma, substSigma, javaName, returnType)

--- the 'JName' of the class generated for this package
mainClass :: Global -> JName
mainClass g = if jn.base  `elem` javaLangNames then jn else jn.{qual=""}
    where jn = g.packClass g.thisPack

--- latin ƒ can be used to obscure plain function names in a predictable way 
latinF    = "ƒ" 

--- construct a 'BitSet' that holds the given attributes
attrs ∷ [JAttr] → Attributes
attrs = fold Attributes.unionE Attributes.empty

--- The type for enum constants.
--- Using @short@ for this, java methods get a signature that is different.
jtEnum    = Nativ "short" []


--- create the boxed form of a java type
boxed (Lazy x) = x
boxed (Nativ "boolean" []) = Nativ {typ = "java.lang.Boolean", typeargs = []}
boxed (Nativ "byte" [])    = Nativ {typ = "java.lang.Byte", typeargs = []}
boxed (Nativ "short" [])   = Nativ {typ = "java.lang.Short", typeargs = []}
boxed (Nativ "char" [])    = Nativ {typ = "java.lang.Character", typeargs = []}
boxed (Nativ "int" [])     = Nativ {typ = "java.lang.Integer", typeargs = []}
boxed (Nativ "long" [])    = Nativ {typ = "java.lang.Long", typeargs = []}
boxed (Nativ "double" [])  = Nativ {typ = "java.lang.Double", typeargs = []}
boxed (Nativ "float" [])   = Nativ {typ = "java.lang.Float", typeargs = []}
boxed x = x

{--
    Check if argument is 'Mutable' @a b@, and if so, return @b@
-}
isMutable (TApp (TApp con _) b) 
    | TCon{name = TName pack "Mutable"} <- con,
      pack == pPreludeIO = Just b
    | otherwise          = Nothing
isMutable _ = Nothing


{--
    Check if a type is a 'JArray' where @t@ is not a type variable.
    If so, return a 'JType' that encodes the true java array type.
    
    Example:
    
    > arrayTau (JArray s Int) = Just (Nativ "int[]")
-}
arrayTau :: Global -> Tau -> Maybe JType
arrayTau g tau
    | Just t <- isMutable tau = arrayTau g t
    | TApp con b <- tau,
      TCon{name = TName pack "JArray"} <- con,
      pack == pPreludeArrays = case arrayTau g b of
        Just (sub@Nativ{typ, typeargs}) -> Just Nativ{typ="[]", typeargs=[sub]}
        _ -> case tauJT g b of
            Something -> Just Something     -- will cause casting to correct type if needed
            jt -> Just Nativ{typ="[]", typeargs=[jt]}
    | otherwise = Nothing




--- Compute the 'JType' for a given 'Sigma' type 
sigmaJT g (ForAll _ rho)        = rhoJT g rho


--- Compute the 'JType' for a given 'Rho' type
rhoJT   g (fun@RhoFun _ _ _)    = Func a (tauJT g r)
    where
        (r, args) = returnType fun
        a = length args    
rhoJT   g (RhoTau {tau})        = tauJT g tau


--- Compute the 'JType' for a given 'Tau' type
tauJT   g (app@TApp a b)
     | Just (a,b) ← app.getFun     
        = case tauJT g b of
                func@Func{} → func.{args <- succ}
                other       → Func 1 other 
     | Just array <- arrayTau g app = array 
     | otherwise = case app.flat of
         (TCon {pos,name}):rest -> taujtApp g name rest app
         other                  -> Something     -- we know nothing about it
 
tauJT   g (ty@TCon {pos, name})    = taujtApp g name [] ty
 
tauJT   g (TVar {var,kind})
     | kind == KGen             = targ var 
     | otherwise                = Something
tauJT   g (Meta meta)
     | meta.kind == KGen        = TArg ("GT" ++ show meta.uid)
     | otherwise                = Something
tauJT   g (TSig sig)            = sigmaJT g sig


taujtApp g qname rest app
    | Just (sym@SymT{}) <- g.findit qname = case sym of
        SymT {product=true, newt=true} ->
             let sigmas = [ ConField.typ f | sym@SymD {flds} <- values sym.env, f <- flds ]
             in case sigmas of
                 []     -> Prelude.error (nice sym g ++ " has no fields")                     
                 (s:_)  -> (sigmaJT g . flip substSigma s . unifySigma g sym.typ) rsig
                    where
                        rsig = ForAll [] (RhoTau [] app) 
        SymT {product,nativ,enum,pur}
              -- U.pri
              | Just s <- nativ = if s `elem` primitiveTypes
                                    then Nativ {typ=s, typeargs=[]}
                                    else Nativ {typ=s, 
                                              typeargs = map (boxed . tauJT g) args}
              | enum            = jtEnum
              | otherwise       = Ref {jname = javaName g qname, typeargs = []}
              where args = [ jt | (KGen, jt) <- zip sym.typ.kinds rest ]     
        other -> undefined   -- can not happen because catched in U.findT
    | otherwise = Prelude.error (nice qname g ++ " not a type")

--- make a type argument from a name
targ s = TArg {var = if s ~ ´^any(\d+)?$´ then "?" else "Τ" ++ s}
                                                      -- ^ this is a greek uppercase Tau
--- reconstruct & print Java code tokens
reconstruct ∷ [Token] → StIO ()
reconstruct xs = work xs
    where
        work ∷ [Token] → StIO ()
        work [] = return ()
        work (x:xs)
            | not (null x.qual) = work (x.qual ++ (x.{qual=[]} : xs))
        work [x] = U.println (tval x) >> U.println ""
        work (a:b:xs) = do
            U.print (tval a)
            unless (a.vor b) do
                if (a.line != b.line) then U.println "" else U.print " "
            work (b:xs)

        tval ∷ Token → String
        tval Token{tokid, value}  = case tokid  of
            QUALIFIER → value ++ "."
            _ → value