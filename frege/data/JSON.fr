--- This module provides 'http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf JSON support' for Frege.
{--
    JSON support comprises 3 levels:

    1. On the lexical level, we analyze a 'String' and produce a list of JSON 'Token's.
    2. On the grammar level, we parse a list of 'Token's and produce a JSON 'Value'.
       It is also possible to write parsers that produce certain data objects directly.
    3. On the value level, we convert JSON 'Value's to and from values of algebraic data types.
       This is accomplished by type classes 'ToJSON' and 'FromJSON'. Instances for basic types,
       in particular for all tuple types, are provided.

    ## Converting Strings to JSON 'Values's
    Function 'lexer' translates a 'String' to a list of JSON 'Token's, which is
    given to some 'Parser'. The standard parser 'parseObject' should be used 
    to parse top level 'String' with JSON data, which must reresent either
    an array or a record according to the JSON standard.

    ## Converting JSON 'Values' to values
    Once we have a 'Value' we can use 'fromJSON' to convert (or decode) it 
    to a value of any type that is an instance of type class 'FromJSON'.

    All the basic types, lists, arrays and tuples are instances of 'FromJSON'
    already. Thus, writing a custom instance for your own type is easy. We
    will use the following types for a running example:
    
    >  data Motor = Electric Double --- just performance in kW
    >               | Combustion { fuel :: [Fuel], displacement :: Double, cyls :: Int }
    >  data Fuel = DIESEL | GASOLINE | NATURALGAS | LPG
    >  data Vehicle = Vehicle { wheels :: Int, engine :: Maybe Motor }
    >  bicycle = Vehicle { wheels = 2, engine = Nothing }
    >  ebike   = Vehicle { wheels = 2, engine = Just (Electric 0.9) }
    >  car     = Vehicle { wheels = 4, engine = Just (Combustion {
    >                                   fuel = [LPG, GASOLINE], 
    >                                   displacement = 2.0,
    >                                   cyls = 4 })}
    > vehicles = [car, bicycle, ebike]
    
    ### Write a 'FromJSON' instance
    
    The key for doing this is to have some conventions as to how the type is 
    represented in JSON. We shall use the following encodings for our types.
    [Motor] for example @{"Electric" : 0.9}@ or @{"Combustion" : [["DIESEL"], 2.5, 4]}@.  
    [Fuel] just the name, i.e. "NATURALGAS"
    [Vehicle] a JSON struct like @{"wheels" : 2, "engine" = {"Electric" : 0.9}}@.
    Note that the 'Maybe' will be encoded implicitly by the presence 
    or absence of the "engine" component.

    We can now write the following instances:
    
    > instance FromJSON Fuel where
    >     fromJSON (String "DIESEL") = return DIESEL
    >     fromJSON (String "GASOLINE") = return GASOLINE
    >     fromJSON (String "NATURALGAS") = return NATURALGAS
    >     fromJSON (String "LPG") = return LPG
    >     fromJSON s = fail ("cannot decode fuel from " ++ show s)
    
    Note the use of 'fail' and 'return' which is needed because we produce
    our value in a failure monad like 'Maybe' or 'Either String'.
    
    > instance FromJSON Motor where
    >    fromJSON (Struct m)
    >       | Just n <- m.lookup "Electric" = fromJSON n >>= return . Electric
    >       | Just fdc <- m.lookup "Combustion" = do
    >               (fuel, displacement, cyls) <- fromJSON fdc
    >               return Combustion{fuel, displacement,cyls}
    >    fromJSON x = fail ("invalid engine: " ++ show x)
    
    We need to look up the keys to find out which variant we have. We then
    just decode the associated values and recreate our value. Note that failures
    for sub-components are propagated upwards automatically, thanks to the 
    monadic approach. For example, when we decode a Motor from
    
    > { "Combustion" : [ ["Water"], 2.7, 3]}
    
    we will get the error 
    
    > cannot decode fuel from "Water"
    
    Because the fuel cannot get decoded, the decoding of the 3-tuple fails, and
    our combustion engine will not be constructed.  
    
    Note how the existence of generic 'FromJSON' instances for tuples and lists
    makes the decoding easy.
    
    Finally we can decode vehicles:
     
    > instance FromJSON Vehicle where
    >     fromJSON (Struct m) = 
    >         | Just jw <- m.lookup "wheels" = case m.lookup "engine" of
    >             Just je -> do
    >                  w <- fromJSON jw
    >                  e <- fromJSON je
    >                  return Vehicle{wheels=w, engine=Just e}
    >             Nothing -> do
    >                 w <- fromJSON jw
    >                 return Vehicle{wheels=w, engine=Nothing}
    >    fromJSON garbage = fail "not a vehicle"
    
    The 3 instances provide for all we need. To read a vehicle from a 'String',
    we just need to run the automatically supplied 'parseJSON' function:
    
    >  case parseJSON "{\"wheels\" : 3 }"  of
    >       Just Vehicle{wheels=w} -> -- we have w wheels ...
    
    The 'parseJSON' function needs to know the type of the item to decode as
    well as the failure monad to work with. Most often, this can be inferred
    by the compiler, like in the example above where it is clear that we want
    a @Maybe Vehicle@.
      
    Showing a JSON 'Value' or JSON 'Object' produces valid JSON for exchange with the outside world.  
-}
module frege.data.JSON where

import frege.Prelude hiding(Object, null)
import Data.Bits (shiftL, .|.)
import Data.TreeMap(Tree, each, insert)
import Data.MicroParsec as MP(cond, failure, eos, expect, satisfy, <?>, sepBy1)
import Lib.PP(bracket, text, sep, pretty, stack)
import Data.List (sortBy)

--- lexical entities that can appear in a JSON String
protected data Token = 
      protected BRACEL                  --- left brace @{@
    | protected BRACER                  --- right brace @}@
    | protected BRACKL                  --- left bracket @[@
    | protected BRACKR                  --- right bracket @]@
    | protected COLON                   --- colon @:@
    | protected COMMA                   --- comma @,@
    | protected S {!sval ∷ String}      --- a JSON string, escapes already decoded
    | protected N {!nval ∷ String}      --- a JSON number, 'atod' will work
    | protected TRUE                    --- @true@
    | protected FALSE                   --- @false@
    | protected NULL                    --- @null@ (o noes!!!)
    | protected ERROR  {!offset ∷ Int, 
                        !text   ∷ String}   --- lexical error indicator

instance Show Token where
    show Token.BRACEL = "{"
    show Token.BRACER = "}"
    show Token.BRACKL = "["
    show Token.BRACKR = "]"
    show Token.COLON  = ":"
    show Token.COMMA  = ","
    show Token.TRUE   = " true "
    show Token.FALSE  = " false "
    show Token.NULL   = " null "
    show (Token.S s)  = show s
    show (Token.N n)  = n
    show Token.ERROR{offset, text} = "`%s` at offset %d".format text offset
    
derive Eq Token

{--
    Translate a 'String' into a lazy list of 'Token's.

    There will be at most one 'Token.ERROR' token in the result, 
    and it will be the last in the list. This is, the 'lexer' will stop
    on the first lexical error.
    
    Absence of lexical errors does not mean valid JSON, for example
    > "null, true,"
    is lexed as
    > [NULL, COMMA, TRUE, COMMA]
    but is, of course invalid.
-} 
lexer :: String -> [Token]
lexer s = lex s 0

{--
    Scan a 'String' and take care of offsets
-}
private lex :: String → Int → [Token]
private lex !cs !start
    | endOfSeq        = []
    | ch.isWhitespace = lex cs (start+1)    -- handles tabs, carriage return and newlines as well
    | ch.isDigit      = case positive 0 of
                            !after | after > 0 
                                      → Token.N{nval = seq (start+after)} !: lex cs (start+after)
                            otherwise → Token.ERROR{offset=start, text=seq (start+1)} !: []
    | otherwise = case ch of
        '"' →   string 1 []
        '-' →   case positive 1 of
                    !after | after > 0 
                              → Token.N{nval = seq (start+after)} !: lex cs (start+after)
                    otherwise → Token.ERROR{offset=start, text=seq (start+1)} !: []
        ',' →   Token.COMMA  : lex cs (start+1) 
        ':' →   Token.COLON  : lex cs (start+1)
        '{' →   Token.BRACEL : lex cs (start+1) 
        '}' →   Token.BRACER : lex cs (start+1)
        '[' →   Token.BRACKL : lex cs (start+1) 
        ']' →   Token.BRACKR : lex cs (start+1)
        -- the following lexes "truenull" as TRUE:NULL:...
        -- and "true0" as TRUE:N "0":...
        -- but this will yield syntax error later
        't' | at 1 == 'r', at 2 == 'u', at 3 == 'e'
            →   Token.TRUE : lex cs (start+4)
        'f' | at 1 == 'a', at 2 == 'l', at 3 == 's', at 4 == 'e'
            →   Token.FALSE : lex cs (start+5)
        'n' | at 1 == 'u', at 2 == 'l', at 3 == 'l'
            →   Token.NULL : lex cs (start+4)
        _   →   Token.ERROR{offset=start, text=seq (start+1)} !: []        -- abort scanning
    where
        !endOfSeq   = start >= cs.length      -- assume that length is a cheap operation on Strings
        !ch         = at 0
        seq end     = (cs.substr start end)
        at i        = if start+i >= cs.length then '\0' else cs.charAt (start+i)
        positive off
            | at off == '0'     → fractional (off+1)
            | (at off).isDigit  → fractional (digits (off+1))
            | otherwise         → -1 
        digits off  -- skip 0 or more digits
            | (at off).isDigit  → digits (off+1)
            | otherwise         → off
        fractional off
            | at off == '.'     → if (at (off+1)).isDigit 
                                    then expo (digits (off+2))
                                    else -1
            | otherwise         → expo off
        expo off = case at off of
                'e'     → expo1 (off+1)
                'E'     → expo1 (off+1)
                _       → off   -- no exponent
        expo1 off = case at off of
            '+' → expo2 (off+1)
            '-' → expo2 (off+1)
            _   → expo2 off
        -- at least 1 digit 
        expo2 off = if (at off).isDigit then digits (off+1) else -1     
        string off !acc
            | ch == '"'     → Token.S{sval=packed (reverse acc)} !: lex cs (start+off+1)
            | ch == '\\'    → case at (off+1) of
                                '"' → string (off+2) ('"'  : acc)
                                '\\'→ string (off+2) ('\\' : acc)
                                '/' → string (off+2) ('/'  : acc)
                                'b' → string (off+2) ('\b' : acc)
                                'f' → string (off+2) ('\f' : acc)
                                'n' → string (off+2) ('\n' : acc)
                                'r' → string (off+2) ('\r' : acc)
                                't' → string (off+2) ('\t' : acc)
                                'u' | Just h1 ← hexval (at (off+2)),
                                      Just h2 ← hexval (at (off+3)),
                                      Just h3 ← hexval (at (off+4)),
                                      Just h4 ← hexval (at (off+5)),
                                      !hex <- h1 `shiftL` 12 
                                                .|. h2 `shiftL` 8
                                                .|. h3 `shiftL` 4
                                                .|. h4
                                    → string (off+6) (chr hex !: acc)
                                other ->  Token.ERROR{offset=start+off+1, text=seq (start+off+2)} !: []
            | ch >= ' '     → string (off+1) (ch : acc)
            | start+off >= cs.length
                            → Token.ERROR{offset=start+off, text=seq (cs.length)}   !: []
            | otherwise     → Token.ERROR{offset=start+off, text=seq (start+off+1)} !: []  
            where
                !ch = at off
                j :: Int -> Maybe Int
                j !x = Just x
                hexval c
                    | c >= '0' && c <= '9' = j (ord c - ord '0')
                    | c >= 'a' && c <= 'f' = j (10 + (ord c - ord 'a'))
                    | c >= 'A' && c <= 'F' = j (10 + (ord c - ord 'A'))
                    | otherwise = Nothing

--- JSON types
data Value = 
      String {sval ∷ String }                 --- a string
    | Number {nval ∷ String }                 --- a number
    | Bool   {bval ∷ Bool }                   --- @true@ or @false@   
    | Null                                    --- just @null@
    | Array [Value]                           --- > [ value, ... ]
    | Struct (Tree String Value)              --- > { "name":value, ... }

type Parser = MP.Parser [] Token

--- run a 'Parser' and extract the result 
runParser :: Parser a -> [Token] -> (String | a)
runParser p ts = case MP.runid p ts of
    (Left msg, ts) →  Left (MP.reporterror ts msg)
    (right, _)     →  right  

-- parse a 'String' into a JSON 'Object'
-- parseJSON = parse object . lexer

-- parse a 'String' into a JSON 'Value'
-- parseValue = runParser value . lexer

--- Parses an 'Object.Array' or an 'Object.Map'
--- This is the parser that will be used in type class 'FromJSON' by default.
parseObject :: Parser Value
parseObject =
    cond  (parseLbrack <|> parseLbrace)
        (parseArray <|> parseMap) 
        (failure "JSON object or JSON array expected")
    <* eos  

--- parse a value
parseValue  ∷ Parser Value
parseValue = (
            Value.String <$> parseString
        <|> parseNumber
        <|> parseNull
        <|> parseBoolean
        <|> parseArray
        <|> parseMap)
    <?> "JSON value expected" 

--- parse a left bracket
parseLbrack  ∷ Parser Token
parseLbrack = expect Token.BRACKL <?> "'[' expected"

--- parse a left brace
parseLbrace  ∷ Parser Token
parseLbrace = expect Token.BRACEL <?> "'{' expected"

--- parse a right bracket
parseRbrack  ∷ Parser Token
parseRbrack = expect Token.BRACKR <?> "']' missing"

--- parse a right brace
parseRbrace  ∷ Parser Token
parseRbrace = expect Token.BRACER <?> "'}' missing"

--- parse a comma
parseComma  ∷ Parser Token
parseComma = expect Token.COMMA <?> "',' expected"

--- parse a colon
parseColon ∷ Parser Token
parseColon = expect Token.COLON <?> "':' expected"

--- parse a string
parseString :: Parser String
parseString = _.sval <$> satisfy _.{sval?}

--- parse a number
parseNumber :: Parser Value
parseNumber = Value.Number . _.nval <$> satisfy _.{nval?}

--- parse a raw 'Int'
parseInt :: Parser Int
parseInt = satisfy _.{nval?} >>= either (const pzero) return . String.int . Token.nval 

--- parse a raw 'Long'
parseLong :: Parser Long
parseLong = satisfy _.{nval?} >>= either (const pzero) return . String.long . Token.nval 

--- parse a raw 'Integer'
parseInteger :: Parser Integer
parseInteger = satisfy _.{nval?} >>= either (const pzero) return . String.integer . Token.nval 

--- parse a raw 'Double'
parseDouble :: Parser Double
parseDouble = satisfy _.{nval?} >>= either (const pzero) return . String.double . Token.nval 

--- parse a raw 'Float'
parseFloat :: Parser Float
parseFloat = satisfy _.{nval?} >>= either (const pzero) return . String.float . Token.nval 


--- parse a boolean
parseBoolean ∷ Parser Value
parseBoolean = 
            const Value.Bool{bval=true}  <$> expect Token.TRUE 
        <|> const Value.Bool{bval=false} <$> expect Token.FALSE  

--- parse a raw boolean
parseBool = const true  <$> expect Token.TRUE
        <|> const false <$> expect Token.FALSE

--- parse null
parseNull :: Parser Value
parseNull = const Value.Null <$> expect Token.NULL

--- parse a pair
parsePair :: Parser (String, Value)
parsePair = do
    k <- parseString <?> "string expected"
    parseColon
    v <- parseValue
    return (k,v)

--- parse a list
--- For example, 
--- > parseList parseFloat
--- produces a [Float] directly
parseList :: Parser a -> Parser [a]
parseList pElem = do
    parseLbrack
    cond parseRbrack 
        (parseRbrack >> return []) 
        do 
            vs <- pElem `sepBy1` parseComma
            parseRbrack
            return  vs

--- parse a raw tuple
--- Use like
--- > parseTuple (parseFloat, parseString)
--- This would produce @(Float, String)@
parseTuple ∷ (Parser 𝖆,Parser 𝖇) → Parser (𝖆,𝖇)
parseTuple (pA, pB) = do
    parseLbrack
    a <- pA
    parseComma
    b <- pB
    parseRbrack
    return (a,b)
    
--- parse a JSON array
parseArray ∷ Parser Value
parseArray = do
    parseLbrack
    cond parseRbrack 
        (parseRbrack >> return (Array [])) 
        do 
            vs <- parseValue `sepBy1` parseComma
            parseRbrack
            return (Array vs)

--- Parse a JSON record
--- If one and the same key appears multiple times, only the last one will be taken into account.
parseMap ∷ Parser Value
parseMap = do
    parseLbrace
    cond parseRbrace 
        (parseRbrace >> return (Struct empty)) 
        do
            ps ← parsePair `sepBy1` parseComma
            parseRbrace
            (return . Struct . Tree.fromList) ps

--- pretty print a 'Value'
valDoc :: Value -> PP.DOCUMENT 
valDoc v = case v  of
    String{sval} → text (show sval)
    Number{nval} → text nval
    Bool{bval}   → text (display bval)
    Null         → text "null"
    Array a      → bracket "[" (sep "," (map valDoc a)) "]" 
    Struct s     → bracket "{" (sep "," pairs) "}"
                where 
                    pairs = map pairDoc (each s)
                    pairDoc (s,v) = PP.group $ text (show s) PP.<+> text ":" PP.<+> valDoc v

instance Show Value where
    show = pretty 72 . valDoc

instance Eq Value where
    hashCode _ = -1
    Array  a == Array  b = a  == b 
    Struct m == Struct p = em == ep
        where
            em = sortBy (comparing fst) (each m)
            ep = sortBy (comparing fst) (each p)
    _ == _ = false

{--
    Class of types whose values can be reconstructed from JSON.
    
    There are two ways to accomplish this:
    
    1. take a JSON 'Value' and try to reconstruct a value of the desired type,
       that is, implement function 'fromJSON'
    2. write a 'Parser' that produces the desired value directly and use
       this to implement 'parseJSON'

    The usual way is to implement 'fromJSON' and keep the default for 'parseJSON', 
    which parses a 'String' to a 'Object', 
    wraps this in a 'Value' and passes that value to 'fromJSON'.

    Minimal complete definition: 'fromJSON'

    The instances of all standard types that are not encoded as objects will
    have an implementation of 'parseJSON' that fails immediately. This behaviour 
    is in line with the JSON standard which allows only objects
    (that is, maps or arrays) to appear on the top level.

    There is currently no support for automatically derived instances yet,
    but when it gets implemented it shall use the following encodings:

    - primitives, 'String', 'Regex': @true@, @false@, _number_, "_string_" 
    - lists, arrays and the like: @[ value, ... ]@
    - the trivial type @()@: @[]@
    - tuples and other product types: @[ value1, value2, ... ]@
    - enumerations: the constructor name as string
    - new types: same as the wrapped type
    - algebraic types: @{ "Just":v }@ or @{"Nothing":null}@,
      when there is more than one value bound under the constructor, treat
      the values as tuple: @{ "Data": [v1,v2,...]}@. If we have a record under
      the constructor: @{ "case":"Person", "name":"Smith", "age":42}}@
    - inside @[]@ or @{}@ brackets, 'Maybe' values can be abbreviated 
      in such a way that @null@ stands for 'Nothing' and @v@ for 'Just' v, but
      observe that values of type @(Maybe (Maybe x))@ cannot be encoded like this, 
      because there would be no encoding for the value 'Just' 'Nothing'.   
-}
class FromJSON a where
    {-- 
        Interpret a JSON value as a value of the instance type, or 'fail'.

        This function must be implemented by all instances.

        If one has a non-standard implementation of 'parseJSON' that does
        not use 'fromJSON', a conforming, but inefficient implementation would be

        > fromJSON = parseJSON . show 
    -}
    fromJSON  ∷ MonadFail 𝖒 ⇒ Value → 𝖒 a

    parseJSON ∷ MonadFail 𝖒 ⇒ String → 𝖒 a
    parseJSON = either fail fromJSON . runParser parseObject . lexer  

{--
    The class of types that support their serialization to JSON.

    Note that the JSON value for primitive types and 'String's yields no
    valid JSON document when printed.
-}
class ToJSON a where
    toJSON :: a -> Value

instance ToJSON Value where
    toJSON = id

instance FromJSON Value where
    fromJSON = return



instance ToJSON () where
    toJSON () = Array []

instance FromJSON () where
    fromJSON (Array  xs)
        | xs.null   = return ()
        | otherwise = fail ("cannot decode () from non empty array")
    fromJSON other  = fail ("cannot decode () from " ++ show other)


instance ToJSON Bool where
    toJSON b = Value.Bool b

instance FromJSON Bool where
    fromJSON Value.Bool{bval} = return bval
    fromJSON other            = fail ("cannot decode Bool from " ++ show other)
    parseJSON _               = fail ("A top level JSON value cannot be Bool")


instance ToJSON Byte where
    toJSON i = Value.Number{nval=show i.unsigned}

instance FromJSON Byte where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) checkbyte . String.int $ nval
        where
            checkbyte n 
                | n > Byte.maxBound.unsigned = fail ("%d too big for byte".format n)
                | n < Byte.minBound.unsigned = fail ("%d too small for byte".format n)
                | otherwise = return (byte n)
    fromJSON other              = fail ("cannot decode Byte from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Byte")


instance ToJSON Short where
    toJSON i = Value.Number{nval=show i.unsigned}

instance FromJSON Short where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) checkshort . String.int $ nval
        where
            checkshort n 
                | n > Short.maxBound.unsigned = fail ("%d too big for short".format n)
                | n < Short.minBound.unsigned = fail ("%d too small for short".format n)
                | otherwise = return (short n)
    fromJSON other              = fail ("cannot decode Short from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Short")


instance ToJSON Int where
    toJSON i = Value.Number{nval=show i}

instance FromJSON Int where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) return . String.int $ nval
    fromJSON other              = fail ("cannot decode Int from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Int")


instance ToJSON Long where
    toJSON i = Value.Number{nval=show i}

instance FromJSON Long where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) return . String.long $ nval
    fromJSON other              = fail ("cannot decode Long from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Long")


instance ToJSON Integer where
    toJSON i = Value.Number{nval=show i}

instance FromJSON Integer where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) return . String.integer $ nval
    fromJSON other              = fail ("cannot decode Integer from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Integer")


instance ToJSON Float where
    toJSON i = Value.Number{nval=show i}

instance FromJSON Float where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) return . String.float $ nval
    fromJSON other              = fail ("cannot decode Float from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Float")


instance ToJSON Double where
    toJSON i = Value.Number{nval=show i}

instance FromJSON Double where
    fromJSON Value.Number{nval} = either (fail . Throwable.show) return . String.double $ nval
    fromJSON other              = fail ("cannot decode Double from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Double")


instance ToJSON Char where
    toJSON c = Value.String{sval=ctos c}

instance FromJSON Char where
    fromJSON Value.String{sval} | length sval == 1 
                                = return (sval.charAt 0)
    fromJSON other              = fail ("cannot decode Char from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be Char")


instance ToJSON String where
    toJSON s = Value.String s

instance FromJSON String where
    fromJSON Value.String{sval} = return sval
    fromJSON other              = fail ("cannot decode String from " ++ show other)
    parseJSON _                 = fail ("A top level JSON value cannot be String")


instance ToJSON ToJSON 𝖊 ⇒ [𝖊] where
    toJSON = Array . map toJSON 

instance FromJSON (FromJSON 𝖊) ⇒ [𝖊] where
    fromJSON (Array xs)
                                    -- goes 3 times through the list
                                    -- but avoids implicit construction
                                    -- of intermediate lists through mapM 
                                = if all (either (const false) (const true)) js
                                    then return     [ e | Right e ← js ]
                                    else fail (head [ e | Left e  ← js ])
                       where js = map fromJSON xs
    fromJSON other              = fail ("cannot decode [] from non array " ++ show other)


instance ToJSON ToJSON 𝖊 ⇒ JArray 𝖊  where
    toJSON = Array . map maybeToJSON . toMaybeList

instance FromJSON (FromJSON 𝖊, ArrayElem 𝖊) ⇒ JArray 𝖊 where
    fromJSON list = arrayFromMaybeList <$> fromJSON list


--- 'Maybe.toJSON' produces one of
--- > {"Nothing" : null }
--- > {"Just"    : v }
--- For a more concise representation see 'maybeToJSON'
instance ToJSON ToJSON 𝖊 ⇒ Maybe 𝖊 where
    toJSON = Struct 
                . maybe nothingJSON (insert empty "Just" . toJSON)

--- constant @{"Nothing" : null}@, used in encoding 'Maybe' values
private nothingJSON :: Tree String Value
private !nothingJSON = insert empty "Nothing" Value.Null

--- produce either @null@ or just the jsonized value for a 'Maybe'
maybeToJSON ∷ ToJSON 𝖆 ⇒ Maybe 𝖆 → Value
maybeToJSON = maybe Value.Null toJSON

instance FromJSON (FromJSON 𝖊) ⇒ Maybe 𝖊  where
    {--
        Encoding can be:
        > {"Just": some-value}
        > {"Nothing": _}
        > null
        > some-value 
    -}
    fromJSON (Struct m)
        | Just v <- m.lookup "Just"     = Just <$> fromJSON v
        | Just _ <- m.lookup "Nothing"  = return Nothing
    fromJSON Value.Null                 = return Nothing
    fromJSON v                          = Just <$> fromJSON v


instance ToJSON (ToJSON 𝖆, ToJSON 𝖇) ⇒ (𝖆|𝖇)  where
    toJSON = Struct 
                . either (insert empty "Left"  . toJSON) 
                         (insert empty "Right" . toJSON)


instance FromJSON (FromJSON 𝖆, FromJSON 𝖇) ⇒ (𝖆|𝖇)  where
    fromJSON (Struct m)
        | Just v <- m.lookup "Left"     = Left  <$> fromJSON v
        | Just v <- m.lookup "Right"    = Right <$> fromJSON v
    fromJSON other                      = fail ("cannot decode Either from " ++ show other)


instance ToJSON (ToJSON 𝖆, ToJSON 𝖇) ⇒ (𝖆, 𝖇)  where
    toJSON (a,b) = Array [toJSON a, toJSON b]

instance FromJSON (FromJSON 𝖆, FromJSON 𝖇) ⇒  (𝖆, 𝖇) where
    fromJSON (Array [va, vb]) = do
        a ← fromJSON va
        b ← fromJSON vb
        return (a,b)
    fromJSON other      = fail ("cannot decode (a,b) from " ++ show other)

instance ToJSON (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈) ⇒  (𝖆, 𝖇, 𝖈) where
    toJSON (a,b,c) = Array [toJSON a, toJSON b, toJSON c]

instance FromJSON (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈) ⇒  (𝖆, 𝖇, 𝖈) where
    fromJSON (Array [va, vb, vc]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        return (a,b,c)
    fromJSON other      = fail ("cannot decode (a,b,c) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉) ⇒  (𝖆, 𝖇, 𝖈, 𝖉) where
    toJSON (a,b,c,d) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉) ⇒  (𝖆, 𝖇, 𝖈, 𝖉) where
    fromJSON (Array [va, vb, vc, vd]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        return (a,b,c,d)
    fromJSON other      = fail ("cannot decode (a,b,c,d) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊) where
    toJSON (a,b,c,d,e) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊) where
    fromJSON (Array [va, vb, vc, vd, ve]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        return (a,b,c,d,e)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋) where
    toJSON (a,b,c,d,e,f) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋) where
    fromJSON (Array [va, vb, vc, vd, ve, vf]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        return (a,b,c,d,e,f)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌) where
    toJSON (a,b,c,d,e,f,g) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        return (a,b,c,d,e,f,g)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍) where
    toJSON (a,b,c,d,e,f,g,h) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        return (a,b,c,d,e,f,g,h)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎) where
    toJSON (a,b,c,d,e,f,g,h,i) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        return (a,b,c,d,e,f,g,h,i)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏) where
    toJSON (a,b,c,d,e,f,g,h,i,j) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        return (a,b,c,d,e,f,g,h,i,j)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐) ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        return (a,b,c,d,e,f,g,h,i,j,k)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        return (a,b,c,d,e,f,g,h,i,j,k,l)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        return (a,b,c,d,e,f,g,h,i,j,k,l,m)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘) 
                    ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙) 
                ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙) 
                ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙, ToJSON 𝖚) 
                ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t,
                            toJSON u]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙, FromJSON 𝖚) 
                ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt, vu]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        u ← fromJSON vu
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙, ToJSON 𝖚,
                    ToJSON 𝖛) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t,
                            toJSON u, toJSON v]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙, FromJSON 𝖚,
                    FromJSON 𝖛) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt, vu, vv]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        u ← fromJSON vu
        v ← fromJSON vv
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙, ToJSON 𝖚,
                    ToJSON 𝖛, ToJSON 𝖜) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t,
                            toJSON u, toJSON v, toJSON w]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙, FromJSON 𝖚,
                    FromJSON 𝖛, FromJSON 𝖜) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt, vu, vv, vw]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        u ← fromJSON vu
        v ← fromJSON vv
        w ← fromJSON vw
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙, ToJSON 𝖚,
                    ToJSON 𝖛, ToJSON 𝖜, ToJSON 𝖝) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜, 𝖝) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t,
                            toJSON u, toJSON v, toJSON w, toJSON x]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙, FromJSON 𝖚,
                    FromJSON 𝖛, FromJSON 𝖜, FromJSON 𝖝) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜, 𝖝) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt, vu, vv, vw, vx]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        u ← fromJSON vu
        v ← fromJSON vv
        w ← fromJSON vw
        x ← fromJSON vx
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙, ToJSON 𝖚,
                    ToJSON 𝖛, ToJSON 𝖜, ToJSON 𝖝,
                    ToJSON 𝖞) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜, 𝖝, 𝖞) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t,
                            toJSON u, toJSON v, toJSON w, toJSON x,
                            toJSON y]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙, FromJSON 𝖚,
                    FromJSON 𝖛, FromJSON 𝖜, FromJSON 𝖝,
                    FromJSON 𝖞) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜, 𝖝, 𝖞) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt, vu, vv, vw, vx, vy]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        u ← fromJSON vu
        v ← fromJSON vv
        w ← fromJSON vw
        x ← fromJSON vx
        y ← fromJSON vy
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y) from " ++ show other)


instance ToJSON  (ToJSON 𝖆, ToJSON 𝖇, ToJSON 𝖈, 
                    ToJSON 𝖉, ToJSON 𝖊, ToJSON 𝖋,
                    ToJSON 𝖌, ToJSON 𝖍, ToJSON 𝖎,
                    ToJSON 𝖏, ToJSON 𝖐, ToJSON 𝖑,
                    ToJSON 𝖒, ToJSON 𝖓, ToJSON 𝖔,
                    ToJSON 𝖕, ToJSON 𝖖, ToJSON 𝖗,
                    ToJSON 𝖘, ToJSON 𝖙, ToJSON 𝖚,
                    ToJSON 𝖛, ToJSON 𝖜, ToJSON 𝖝,
                    ToJSON 𝖞, ToJSON 𝖟) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜, 𝖝, 𝖞, 𝖟) where
    toJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) = Array [
                            toJSON a, toJSON b, toJSON c, toJSON d,
                            toJSON e, toJSON f, toJSON g, toJSON h,
                            toJSON i, toJSON j, toJSON k, toJSON l,
                            toJSON m, toJSON n, toJSON o, toJSON p,
                            toJSON q, toJSON r, toJSON s, toJSON t,
                            toJSON u, toJSON v, toJSON w, toJSON x,
                            toJSON y, toJSON z]

instance FromJSON  (FromJSON 𝖆, FromJSON 𝖇, FromJSON 𝖈, 
                    FromJSON 𝖉, FromJSON 𝖊, FromJSON 𝖋,
                    FromJSON 𝖌, FromJSON 𝖍, FromJSON 𝖎,
                    FromJSON 𝖏, FromJSON 𝖐, FromJSON 𝖑,
                    FromJSON 𝖒, FromJSON 𝖓, FromJSON 𝖔,
                    FromJSON 𝖕, FromJSON 𝖖, FromJSON 𝖗,
                    FromJSON 𝖘, FromJSON 𝖙, FromJSON 𝖚,
                    FromJSON 𝖛, FromJSON 𝖜, FromJSON 𝖝,
                    FromJSON 𝖞, FromJSON 𝖟) 
            ⇒  (𝖆, 𝖇, 𝖈, 𝖉, 𝖊, 𝖋, 𝖌, 𝖍, 𝖎, 𝖏, 𝖐, 𝖑, 𝖒, 𝖓, 𝖔, 𝖕, 𝖖, 𝖗, 𝖘, 𝖙, 𝖚, 𝖛, 𝖜, 𝖝, 𝖞, 𝖟) where
    fromJSON (Array [va, vb, vc, vd, ve, vf, vg, vh, vi, 
                                             vj, vk, vl, vm, vn, vo, vp, vq, vr, 
                                             vs, vt, vu, vv, vw, vx, vy, vz]) = do
        a ← fromJSON va
        b ← fromJSON vb
        c ← fromJSON vc
        d ← fromJSON vd
        e ← fromJSON ve
        f ← fromJSON vf
        g ← fromJSON vg
        h ← fromJSON vh
        i ← fromJSON vi
        j ← fromJSON vj
        k ← fromJSON vk
        l ← fromJSON vl
        m ← fromJSON vm
        n ← fromJSON vn
        o ← fromJSON vo
        p ← fromJSON vp
        q ← fromJSON vq
        r ← fromJSON vr
        s ← fromJSON vs
        t ← fromJSON vt
        u ← fromJSON vu
        v ← fromJSON vv
        w ← fromJSON vw
        x ← fromJSON vx
        y ← fromJSON vy
        z ← fromJSON vz
        return (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)
    fromJSON other      = fail ("cannot decode (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) from " ++ show other)
