{- 

    Copyright ¬© 2011 - 2015, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

-}


{--
    An efficient implementation of
    'https://en.wikipedia.org/wiki/Persistent_data_structure persistent' 
    ordered maps from keys to values
    based on 'http://en.wikipedia.org/wiki/AVL_tree AVL trees'.

    ## Properties of ordered maps
    
    An AVL tree is a self-balancing binary search tree. 
    In an AVL tree, the heights of the two child subtrees of any node 
    differ by at most one; if at any time they differ by more than one, 
    rebalancing is done to restore this property. 
    
    Lookup, insertion, and deletion all take O(log n) time in both the average 
    and worst cases, where n is the number of nodes in the tree prior to the 
    operation. Insertions and deletions may require the tree to be rebalanced 
    by one or more tree rotations.

    AVL trees are height-balanced, but not weight-balanced nor Œº-balanced,
    that is, sibling nodes can have hugely differing numbers of descendants.
    
    ## Properties of this implementation
    
    Keys will always be strict, whereas values can remain un-evaluated until
    two values will have to be combined. 
    
    Combination of two values takes place when a mapping for 
    an already existing key is inserted in a map. In order to prevent
    building up of thunks that could lead to stack overflows later, the
    function combining the values will be evaluated right away, and this may 
    trigger evaluation of one or both values in turn. 
    
    The default function used by operations like 'insert' or 'union' is 'const'; 
    and this will cause evaluation of the *new* value. Take a look at
    the following example:
    
    > insert 7 undefined (insert 7 25 empty)            -- will fail
    > insert 7 42 (insert 7 undefined empty)            -- will succeed
    > insertWith (+) 7 42 (insert 7 undefined empty)    -- will fail

    The last expression will fail because ('+') needs to evaluate both 
    arguments. OTOH, expressions like

    > fold (\t\v -> insertWith (+) 42 v t) empty [1..1_000_000]
 
    will not cause stack overflow when later the value associated with 42 is
    actually used, nor will it need heap memory for one million thunks.

    ## Operations

    ### Creating Maps

    Get an empty map with 'TreeMap.mempty' or 'TreeMap.empty', make a singleton one
    with 'singleton' or turn an association list into a 'TreeMap' with 'fromList'.
    The more general function 'fromListWith' allows custom handling of 
    associations with duplicate keys.

-}
package frege.data.TreeMap where

-- import frege.data.List (elemBy, partitioned, sortBy, groupBy)
import frege.data.Monoid as M(Monoid)

--- _O(1)_ Create a singleton map
singleton ‚à∑ Ord ùñê ‚áí ùñê ‚Üí ùñõ ‚Üí TreeMap ùñê ùñõ
singleton k v = TreeMap.Node{h√∂he=1, left=TreeMap.Nil, right=TreeMap.Nil, key=k, value=v}

--- _O(n)_ Compute the size of the map
size ‚à∑ TreeMap ùñê ùñõ ‚Üí Int
size TreeMap.Node{left, right} = 1 + size left + size right
size TreeMap.Nil = 0

{--
    _O(log n)_
    
    > insert k v map
    
    returns a 'TreeMap' where _k_ is associated with _v_ such that
    
    > lookup k (insert k v map) = Just v
    
    If _k_ was already associated with some value in _map_, then _v_ will get 
    evaluated to WHNF, otherwise it is left alone. 
-}
insert k v m = TreeMap.insertWork const m k v

{-- 
    _O(log n)_
    > insertWith f k v m
    If _m_ does not contain _k_, this works like 'insert'.
    Otherwise, the existing association of _k_ with some value _v'_ is replaced by
    an association of _k_ with the result of evaluating 
    > f v v'
    in the resulting map. 

    Strict evaluation is necessary to prevent building up of large thunks 
    of the form
    > f v3 (f v2 (f v1 v0))

    Note that
    > insert = insertWith const
    and that this will evaluate the *new* value in case of an update. If you
    want to prevent this, use

    > replace k v = insert k v . delete k
    
    The replaced value will be evaluated only if the given function is strict
    in the second argument. Since 'const' is lazy in the second argument, the
    following will be fine:
    
    > insert "foo" 7 (insert "foo" undefined (delete "foo" m))
    
    That is, the value that is inserted for a given key first is not evaluated on
    insertion, and only evaluated on update if the update function demands it, which
    is not the case for a plain 'insert'.
-} 
insertWith f k v m = TreeMap.insertWork f m k v

{-- 
    _O(log n)_
    > delete k tm
    is a 'HashMap' m such that
    > lookup k m = Nothing
    and for any other key _o_
    > lookup o m = lookup o tm

    Less formally, the association of _k_ with some value, if any, 
    is removed in the result, while all other associations are retained.

    If _tm_ didn't contain _k_ in the first place,
    > delete k tm = tm    
-}
delete ‚à∑ Ord ùñê ‚áí ùñê ‚Üí TreeMap ùñê ùñõ ‚Üí TreeMap ùñê ùñõ
delete k tm = tm.delete k

--- Interface for Maps based on AVL trees
class AVLMap map where
    --- look up an element by key
    lookup    :: Ord key => map key value -> key -> Maybe value
    -- insert an element
    -- insert    :: Ord key => map key value -> key -> value -> map key value
    --- insert a (key, value) list
    insertList :: Ord key => map key value -> [(key, value)] -> map key value
    --- update an element
    update    :: Ord key => map key value -> key -> value -> map key value
    --- construct a tree map from a list with (key, value) tuples
    fromList  :: (Monoid (map key value), Ord key) => [(key, value)]  -> map key value
    --- the tree data as unordered (key, value) list 
    each      :: map key value -> [(key, value)]
    --- the unordered list of keys in the tree map
    keys      :: map key value -> [key]
    --- the unordered list of values in the tree map
    values    :: map key value -> [value]
    fromList  = insertList mempty

data TreeMap k v = 
          protected Nil    --- the empty tree 
        | protected Node { !h√∂he :: Int, !left, !right :: (TreeMap k v), !key :: k, value ::  v}
        where
    
    depth (Node _ l r _ _) = max (depth l) (depth r)
    depth _ = 0

    balance (Node _ l r _ _) = height l - height r
    balance _ = 0
    
    height Node{h√∂he} = h√∂he
    height _ = 0

    rotright (Node _ (Node _ ll lr lk lv) r k v) = Node sa ll x lk lv
        where
            sx = 1 + max (height lr) (height r)
            x = Node sx lr r k v
            sa = 1 + max (height ll) (height x)
    rotright t = t
    
    rotleft (Node _ l (Node _ rl rr rk rv) k v) = Node sb x rr rk rv
        where
            sx = 1 + max (height l) (height rl)
            x = Node sx l rl k v
            sb = 1 + max (height x) (height rr)
    rotleft t = t
    
    drotlr (Node s l r k v) = rotright (Node s (rotleft l) r k v)
    drotlr nil = nil
    
    drotrl (Node s l r k v) = rotleft  (Node s l (rotright r) k v)
    drotrl nil = nil
    
    rebalance (x@Node s l r k v) =
        if hl + 1 < hr then
            if balance r < 1 then rotleft x else drotrl x
        else if hl > hr + 1 then        -- left subtree higher
            if balance l >= 0 then rotright x else drotlr x
        else x where
            hl = height l
            hr = height r
    rebalance nil = nil
    
    -- heightchange (Node a _ _ _ _) Nil = (+1)
    -- heightchange Nil (Node a _ _ _ _) = (subtract 1)
    -- heightchange (Node a _ _ _ _) (Node b _ _ _ _) = case a <=> b of
    --     Lt -> (+1)
    --     Eq -> id
    --     Gt -> (subtract 1)
    -- heightchange Nil Nil = id
    
    leftmost (this@Node _ Nil _ _ _) =  this
    leftmost (Node _ l _ _ _) = leftmost l
    leftmost Nil              = error "AVLTree.leftmost TreeMap.Nil"

    --- do the dirty work for insert operations
    insertWork f (TreeMap.Node s l r  k1 v1) !k v =
        case k <=> k1 of 
            Lt -> case insertWork f l k v of 
                    !nl -> case 1 + max (TreeMap.height nl) (TreeMap.height r) of 
                        !ns -> TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Eq -> case f v v1 of
                    !nv ‚Üí TreeMap.Node s l r k nv
            Gt -> case insertWork f r k v of 
                    !nr -> case 1 + max (TreeMap.height l) (TreeMap.height nr) of
                        !ns -> TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
    insertWork f nil k v = TreeMap.Node 1 TreeMap.Nil TreeMap.Nil k v

    --- _O(log n)_
    --- > tm.insert k v 
    --- Variant of 'insert' that is better suited for left folds and supports dot-notation.
    insert ‚à∑ Ord ùñÜ ‚áí TreeMap ùñÜ ùñá ‚Üí ùñÜ ‚Üí ùñá ‚Üí TreeMap ùñÜ ùñá
    insert = insertWork const

    --- _O(log n)_
    --- > tm.delete k
    --- Variant of 'delete' that is better suited for left folds and supports dot-notation 
    delete (x@TreeMap.Node _ TreeMap.Nil TreeMap.Nil k1  _) k = if k == k1 then TreeMap.Nil else x
    delete   (TreeMap.Node _ l   TreeMap.Nil k1 v1) k = if k == k1 then l else
        let
            nl = delete l k
            s' = 1 + TreeMap.height nl
        in TreeMap.rebalance (TreeMap.Node s' nl TreeMap.Nil k1 v1)
    delete (TreeMap.Node _ TreeMap.Nil r   k1 v1) k = if k == k1 then r else
        let
            nr = delete r k
            s' = 1 + TreeMap.height nr
        in TreeMap.rebalance (TreeMap.Node s' TreeMap.Nil nr k1 v1)
    delete (TreeMap.Node s l r k1 v1) k =
        case k <=> k1 of
            Lt -> let
                    nl = delete l k
                    ns = 1 + max (TreeMap.height nl) (TreeMap.height r)
                in TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Gt -> let
                    nr = delete r k
                    ns = 1 + max (TreeMap.height l) (TreeMap.height nr)
                in TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
            Eq -> case TreeMap.leftmost r of
                TreeMap.Node ls _ _ lk lv -> let    -- r may not be Nil here, see above
                        nr = delete r lk
                        ns = 1 + max (TreeMap.height l) (TreeMap.height nr)
                    in TreeMap.rebalance (TreeMap.Node ns l nr lk lv)
                TreeMap.Nil -> error "cannot happen"
    delete nil k = nil


    keyvalues t order = kv t []
        where
             kv (Node _ l r key v) !acc = case order of
                 Lt -> kv l ((key,v): kv r acc)
                 Gt -> kv r ((key,v): kv l acc)
                 Eq -> (key,v) : kv l (kv r acc)
             kv nil acc = acc

    fmap f Nil = Nil
    fmap f (Node i l r k v) = Node i (fmap f l) (fmap f r) k  (f v)

    insertList t kvs = fold ins t kvs where
        ins t (k,v) = t.insert k v
    fromList  = insertList empty
        
    --- version of lookup that is optimised for 'String' keys
    lookupS    :: TreeMap String value -> String -> Maybe value
    lookupS (Node _ l r k1 v) !k =
                    case String.compareTo k k1 of
                        cmp | cmp < 0 = lookupS l k
                            | cmp > 0 = lookupS r k
                            | otherwise = Just v
    lookupS nil _ = Nothing

    --- version of lookup that is optimised for 'Int' keys
    lookupI    :: TreeMap Int value -> Int -> Maybe value
    lookupI (Node _ l r k1 v) !k =
                    if k < k1 then lookupI l k
                    else if k > k1 then lookupI r k
                    else Just v
    lookupI nil _ = Nothing
    --- version of insert that is optimized for 'Int' keys
    insertI :: TreeMap Int value -> Int -> value -> TreeMap Int value
    insertI (Node s l r  k1 v1) !k v =
        case k <=> k1 of 
            Lt -> case insertI l k v of 
                    !nl -> case 1 + max (TreeMap.height nl) (TreeMap.height r) of 
                        !ns -> TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Eq -> Node s l r k v
            Gt -> case insertI r k v of 
                    !nr -> case 1 + max (TreeMap.height l) (TreeMap.height nr) of
                        !ns -> TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
    insertI nil k v = Node 1 Nil Nil k v

    insertkvI k v t = insertI t k v
    updatekvI k v t = insertI t k v


    insertS :: TreeMap String value -> String -> value -> TreeMap String value
    insertS (TreeMap.Node s l r  k1 v1) !k v =
        case k <=> k1 of 
            Lt -> case insertS l k v of 
                    !nl -> case 1 + max (TreeMap.height nl) (TreeMap.height r) of 
                        !ns -> TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Eq -> TreeMap.Node s l r k v
            Gt -> case insertS r k v of 
                    !nr -> case 1 + max (TreeMap.height l) (TreeMap.height nr) of
                        !ns -> TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
    insertS nil k v = TreeMap.Node 1 TreeMap.Nil TreeMap.Nil k v

    insertkvS k v t = insertS t k v
    updatekvS k v t = insertS t k v

--- 'TreeMap' can be used as array element
derive ArrayElement (TreeMap a b)

derive Show  TreeMap k v

instance ListEmpty (TreeMap a) where
    null TreeMap.Nil = true
    null _ = false
    empty = TreeMap.Nil

instance Monoid Ord a => TreeMap a b where
    mempty = TreeMap.Nil
    mappend = union

instance Functor TreeMap a 

instance AVLMap TreeMap where
    update t k v = t.insert k v
    
    -- lookup    :: forall value key . Ord key => TreeMap key value -> key -> Maybe value;
    lookup (TreeMap.Node _ l r !k1 v) !k =
                    case k <=> k1 of {
                        Lt -> lookup l k;
                        Gt -> lookup r k;
                        Eq -> Just v;
                    };
    lookup nil _ = Nothing;
         
    
    each t = kv t [] where
        kv (TreeMap.Node _ l r key v) acc = (key,v) : kv l (kv r acc)
        kv nil acc = acc
    
    keys t = kv t [] where
        kv (TreeMap.Node _ l r key v) acc = key : kv l (kv r acc)
        kv nil acc = acc

    values t = kv t [] where
        kv (TreeMap.Node _ l r key v) acc = v : kv l (kv r acc)
        kv nil acc = acc

type TreeSet a  = TreeMap a ()

including s o = insert o () s
contains  s o
    | Nothing <- TreeMap.lookup s o = false
    | otherwise = true;

fromKeys = fold ins empty 
    where
        ins :: Ord a => TreeSet a -> a -> TreeSet a 
        ins t k = t.insert k ()
union s1 = TreeMap.insertList s1 . TreeMap.each
intersection s1 s2 = (TreeMap.insertList empty . filter ((s2 `contains`) . fst) . TreeMap.each) s1 
diff s1 s2 = (TreeMap.insertList empty . filter (not . (s2 `contains`) . fst) . TreeMap.each) s1
            
