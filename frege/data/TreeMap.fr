{- 

    Copyright © 2011 - 2015, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

-}


{--
    An efficient implementation of
    'https://en.wikipedia.org/wiki/Persistent_data_structure persistent' 
    ordered maps from keys to values
    based on 'http://en.wikipedia.org/wiki/AVL_tree AVL trees'.

    ## Properties of ordered maps
    
    An AVL tree is a self-balancing binary search tree. 
    In an AVL tree, the heights of the two child subtrees of any node 
    differ by at most one; if at any time they differ by more than one, 
    rebalancing is done to restore this property. 
    
    Lookup, insertion, and deletion all take O(log n) time in both the average 
    and worst cases, where n is the number of nodes in the tree prior to the 
    operation. Insertions and deletions may require the tree to be rebalanced 
    by one or more tree rotations.

    AVL trees are height-balanced, but not weight-balanced nor μ-balanced,
    that is, sibling nodes can have hugely differing numbers of descendants.
    
    ## Properties of this implementation
    
    Keys will always be strict, whereas values can remain un-evaluated until
    two values will have to be combined. 
    
    Combination of two values takes place when a mapping for 
    an already existing key is inserted in a map. In order to prevent
    building up of thunks that could lead to stack overflows later, the
    function combining the values will be evaluated right away, and this may 
    trigger evaluation of one or both values in turn. 
    
    The default function used by operations like 'insert' or 'union' is 'const'; 
    and this will cause evaluation of the *new* value. Take a look at
    the following example:
    
    > insert 7 undefined (insert 7 25 empty)            -- will fail
    > insert 7 42 (insert 7 undefined empty)            -- will succeed
    > insertWith (+) 7 42 (insert 7 undefined empty)    -- will fail

    The last expression will fail because ('+') needs to evaluate both 
    arguments. OTOH, expressions like

    > fold (\t\v -> insertWith (+) 42 v t) empty [1..1_000_000]
 
    will not cause stack overflow when later the value associated with 42 is
    actually used, nor will it need heap memory for one million thunks.

    ## Operations

    ### Creating Maps

    Get an empty map with 'TreeMap.mempty' or 'TreeMap.empty', make a singleton one
    with 'singleton' or turn an association list into a 'TreeMap' with 'fromList'.
    The more general function 'fromListWith' allows custom handling of 
    associations with duplicate keys.

-}
package frege.data.TreeMap where

-- import frege.data.List (elemBy, partitioned, sortBy, groupBy)
import frege.data.Monoid as M(Monoid)

--- _O(1)_ Create a singleton map
singleton ∷ Ord 𝖐 ⇒ 𝖐 → 𝖛 → TreeMap 𝖐 𝖛
singleton k v = TreeMap.Node{höhe=1, left=TreeMap.Nil, right=TreeMap.Nil, key=k, value=v}

--- _O(n)_ Compute the size of the map
size ∷ TreeMap 𝖐 𝖛 → Int
size TreeMap.Node{left, right} = 1 + size left + size right
size TreeMap.Nil = 0

{--
    _O(log n)_
    
    > insert k v map
    
    returns a 'TreeMap' where _k_ is associated with _v_ such that
    
    > lookup k (insert k v map) = Just v
    
    If _k_ was already associated with some value in _map_, then _v_ will get 
    evaluated to WHNF, otherwise it is left alone. 
-}
insert k v m = TreeMap.insertWork const m k v

{-- 
    _O(log n)_
    > insertWith f k v m
    If _m_ does not contain _k_, this works like 'insert'.
    Otherwise, the existing association of _k_ with some value _v'_ is replaced by
    an association of _k_ with the result of evaluating 
    > f v v'
    in the resulting map. 

    Strict evaluation is necessary to prevent building up of large thunks 
    of the form
    > f v3 (f v2 (f v1 v0))

    Note that
    > insert = insertWith const
    and that this will evaluate the *new* value in case of an update. If you
    want to prevent this, use

    > replace k v = insert k v . delete k
    
    The replaced value will be evaluated only if the given function is strict
    in the second argument. Since 'const' is lazy in the second argument, the
    following will be fine:
    
    > insert "foo" 7 (insert "foo" undefined (delete "foo" m))
    
    That is, the value that is inserted for a given key first is not evaluated on
    insertion, and only evaluated on update if the update function demands it, which
    is not the case for a plain 'insert'.
-} 
insertWith f k v m = TreeMap.insertWork f m k v

{-- 
    _O(log n)_
    > delete k tm
    is a 'HashMap' m such that
    > lookup k m = Nothing
    and for any other key _o_
    > lookup o m = lookup o tm

    Less formally, the association of _k_ with some value, if any, 
    is removed in the result, while all other associations are retained.

    If _tm_ didn't contain _k_ in the first place,
    > delete k tm = tm    
-}
delete ∷ Ord 𝖐 ⇒ 𝖐 → TreeMap 𝖐 𝖛 → TreeMap 𝖐 𝖛
delete k tm = tm.delete k

{--
    _O(log n)_
    > lookup k m
    If _k_ is associated with some value _v_  in map _m_, it returns
    > Just v
    and otherwise
    > Nothing 
-}
lookup ∷ Ord 𝖐 ⇒ 𝖐 → TreeMap 𝖐 𝖛 → Maybe 𝖛
lookup k hm = hm.lookup k


{--
    _O(n)_

    > foldValues f a map

    applies the operation _f_ to the values in the _map_ in no particular order. 
-}
foldValues ∷ (𝖆 → 𝖛 → 𝖆) → 𝖆 → TreeMap 𝖐 𝖛 → 𝖆
foldValues f a  = TreeMap.foldL Eq (\a\_\v → f a v) a

{--
    _O(n)_

    > foldWithKey f a map

    applies the operation _f_ to the keys and values in the _map_ in ascending key order. 
-}
foldWithKey ∷ (𝖆 → 𝖈 → 𝖇 → 𝖆) → 𝖆 → TreeMap 𝖈 𝖇 → 𝖆
foldWithKey f a = TreeMap.foldL Lt f a

{--
    _O(n)_

    > foldrValues f a map

    applies the operation _f_ to the values in the _map_ in no particular order. 
-}
foldrValues ∷ (𝖛 → 𝖆 → 𝖆) → 𝖆 → TreeMap 𝖐 𝖛 → 𝖆
foldrValues f a  = TreeMap.foldR Eq (\_\v\a → f v a) a

{--
    _O(n)_

    > foldrWithKey f a map

    applies the operation _f_ to the keys and values in the _map_ in descending key order. 
-}
foldrWithKey ∷ (𝖈 → 𝖇 → 𝖆 → 𝖆) → 𝖆 → TreeMap 𝖈 𝖇 → 𝖆
foldrWithKey f a = TreeMap.foldR Gt f a

--- produces a list of the values in the map, in no particular order.
values ∷ TreeMap 𝖆 𝖇 → [𝖇]
values = foldrValues (:) []

--- produces the key/value pairs of a map sorted by key
each ∷ TreeMap 𝖆 𝖇 → [(𝖆,𝖇)]
each = foldrWithKey (\k\v\kvs → (k,v)!:kvs) []

--- produces the keys of the map in ascending order
keys ∷ TreeMap 𝖆 𝖇  → [𝖆]
keys = foldrWithKey (\k\v\kvs → k !: kvs) []

data TreeMap k v = 
          protected Nil    --- the empty tree 
        | protected Node { !höhe :: Int, !left, !right :: (TreeMap k v), !key :: k, value ::  v}
        where
    
    depth (Node _ l r _ _) = max (depth l) (depth r)
    depth _ = 0

    balance (Node _ l r _ _) = height l - height r
    balance _ = 0
    
    height Node{höhe} = höhe
    height _ = 0

    rotright (Node _ (Node _ ll lr lk lv) r k v) = Node sa ll x lk lv
        where
            sx = 1 + max (height lr) (height r)
            x = Node sx lr r k v
            sa = 1 + max (height ll) (height x)
    rotright t = t
    
    rotleft (Node _ l (Node _ rl rr rk rv) k v) = Node sb x rr rk rv
        where
            sx = 1 + max (height l) (height rl)
            x = Node sx l rl k v
            sb = 1 + max (height x) (height rr)
    rotleft t = t
    
    drotlr (Node s l r k v) = rotright (Node s (rotleft l) r k v)
    drotlr nil = nil
    
    drotrl (Node s l r k v) = rotleft  (Node s l (rotright r) k v)
    drotrl nil = nil
    
    rebalance (x@Node s l r k v) =
        if hl + 1 < hr then
            if balance r < 1 then rotleft x else drotrl x
        else if hl > hr + 1 then        -- left subtree higher
            if balance l >= 0 then rotright x else drotlr x
        else x where
            hl = height l
            hr = height r
    rebalance nil = nil
    
    -- heightchange (Node a _ _ _ _) Nil = (+1)
    -- heightchange Nil (Node a _ _ _ _) = (subtract 1)
    -- heightchange (Node a _ _ _ _) (Node b _ _ _ _) = case a <=> b of
    --     Lt -> (+1)
    --     Eq -> id
    --     Gt -> (subtract 1)
    -- heightchange Nil Nil = id
    
    leftmost (this@Node _ Nil _ _ _) =  this
    leftmost (Node _ l _ _ _) = leftmost l
    leftmost Nil              = error "AVLTree.leftmost TreeMap.Nil"

    --- do the dirty work for insert operations
    insertWork f (TreeMap.Node s l r  k1 v1) !k v =
        case k <=> k1 of 
            Lt -> case insertWork f l k v of 
                    !nl -> case 1 + max (TreeMap.height nl) (TreeMap.height r) of 
                        !ns -> TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Eq -> case f v v1 of
                    !nv → TreeMap.Node s l r k nv
            Gt -> case insertWork f r k v of 
                    !nr -> case 1 + max (TreeMap.height l) (TreeMap.height nr) of
                        !ns -> TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
    insertWork f nil k v = TreeMap.Node 1 TreeMap.Nil TreeMap.Nil k v

    --- _O(log n)_
    --- > tm.insert k v 
    --- Variant of 'insert' that is better suited for left folds and supports dot-notation.
    insert ∷ Ord 𝖆 ⇒ TreeMap 𝖆 𝖇 → 𝖆 → 𝖇 → TreeMap 𝖆 𝖇
    insert = insertWork const

    --- _O(log n)_
    --- > tm.delete k
    --- Variant of 'delete' that is better suited for left folds and supports dot-notation 
    delete (x@TreeMap.Node _ TreeMap.Nil TreeMap.Nil k1  _) k = if k == k1 then TreeMap.Nil else x
    delete   (TreeMap.Node _ l   TreeMap.Nil k1 v1) k = if k == k1 then l else
        let
            nl = delete l k
            s' = 1 + TreeMap.height nl
        in TreeMap.rebalance (TreeMap.Node s' nl TreeMap.Nil k1 v1)
    delete (TreeMap.Node _ TreeMap.Nil r   k1 v1) k = if k == k1 then r else
        let
            nr = delete r k
            s' = 1 + TreeMap.height nr
        in TreeMap.rebalance (TreeMap.Node s' TreeMap.Nil nr k1 v1)
    delete (TreeMap.Node s l r k1 v1) k =
        case k <=> k1 of
            Lt -> let
                    nl = delete l k
                    ns = 1 + max (TreeMap.height nl) (TreeMap.height r)
                in TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Gt -> let
                    nr = delete r k
                    ns = 1 + max (TreeMap.height l) (TreeMap.height nr)
                in TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
            Eq -> case TreeMap.leftmost r of
                TreeMap.Node ls _ _ lk lv -> let    -- r may not be Nil here, see above
                        nr = delete r lk
                        ns = 1 + max (TreeMap.height l) (TreeMap.height nr)
                    in TreeMap.rebalance (TreeMap.Node ns l nr lk lv)
                TreeMap.Nil -> error "cannot happen"
    delete nil k = nil

    lookup (TreeMap.Node _ l r !k1 v) !k =
                    case k <=> k1 of {
                        Lt -> lookup l k;
                        Gt -> lookup r k;
                        Eq -> Just v;
                    };
    lookup nil _ = Nothing;

    {--
        > foldL o f a map
        Fold a tree by applying an operation to an accumulator 
        and key and value of every node, 
        whereby the nodes are visited in a certain order
        specified by the first argument. Let the tree be
        >                       root 
        >                     /     \
        >                    /       \
        >                   left    right
        then the result is:
        - @Eq@ the operation is first applied to the root node, 
            and the result is passed to the left subtree, 
            and the result of that is passed to the fold of the right subtree. 
            Also known as "preorder" traversal.
        - @Lt@ the operation is applied to the result of the 
            fold done with the left sub-tree and the root node,
            and the result of that is passed to the fold of the right subtree.
            Also known as "inorder" traversal. This causes the operation to get
            applied to the key/value pairs in ascending key order.
        - @Gt@ like with @Lt@, but the subtrees are processed in reverse order, 
            which results in application of the operation to the key/value pairs in
            descending order. 
    -}
    foldL ∷ Ordering → (c → a → b → c) → c → TreeMap a b → c
    foldL o !f !a t
        | t.null = a
        | otherwise = case o of
            Eq → foldL Eq f (foldL Eq f (f a t.key t.value) t.left) t.right  
            Lt → foldL Lt f (f (foldL Lt f a t.left) t.key t.value ) t.right
            Gt → foldL Gt f (f (foldL Gt f a t.right) t.key t.value ) t.left
    
    --- foldR o f a map
    --- Like 'TreeMap.foldL', but the function is right associative.
    --- The following yields the key of _map_ in ascending order:
    --- > foldR Gt (\k\v\a → k:a) [] map
    foldR ∷ Ordering → (a → b → c → c) → c → TreeMap a b → c
    foldR o !f !a t
        | t.null = a
        | otherwise = case o of
            Eq → foldR Eq f (foldR Eq f (f t.key t.value a) t.left) t.right  
            Lt → foldR Lt f (f t.key t.value (foldR Lt f a t.left)) t.right
            Gt → foldR Gt f (f t.key t.value (foldR Gt f a t.right)) t.left
 

    fmap f Nil = Nil
    fmap f (Node i l r k v) = Node i (fmap f l) (fmap f r) k  (f v)

    insertList :: Ord  𝖆  => TreeMap 𝖆 𝖇 -> [(𝖆, 𝖇)] -> TreeMap 𝖆 𝖇
    insertList t kvs = fold ins t kvs where
        ins t (k,v) = t.insert k v
    fromList ∷ Ord 𝖆 ⇒ [(𝖆,𝖇)] → TreeMap 𝖆 𝖇
    fromList  = insertList empty
        
    --- version of lookup that is optimised for 'String' keys
    lookupS    :: TreeMap String value -> String -> Maybe value
    lookupS (Node _ l r k1 v) !k =
                    case String.compareTo k k1 of
                        cmp | cmp < 0 = lookupS l k
                            | cmp > 0 = lookupS r k
                            | otherwise = Just v
    lookupS nil _ = Nothing

    --- version of lookup that is optimised for 'Int' keys
    lookupI    :: TreeMap Int value -> Int -> Maybe value
    lookupI (Node _ l r k1 v) !k =
                    if k < k1 then lookupI l k
                    else if k > k1 then lookupI r k
                    else Just v
    lookupI nil _ = Nothing
    --- version of insert that is optimized for 'Int' keys
    insertI :: TreeMap Int value -> Int -> value -> TreeMap Int value
    insertI (Node s l r  k1 v1) !k v =
        case k <=> k1 of 
            Lt -> case insertI l k v of 
                    !nl -> case 1 + max (TreeMap.height nl) (TreeMap.height r) of 
                        !ns -> TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Eq -> Node s l r k v
            Gt -> case insertI r k v of 
                    !nr -> case 1 + max (TreeMap.height l) (TreeMap.height nr) of
                        !ns -> TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
    insertI nil k v = Node 1 Nil Nil k v

    insertkvI k v t = insertI t k v
    updatekvI k v t = insertI t k v


    insertS :: TreeMap String value -> String -> value -> TreeMap String value
    insertS (TreeMap.Node s l r  k1 v1) !k v =
        case k <=> k1 of 
            Lt -> case insertS l k v of 
                    !nl -> case 1 + max (TreeMap.height nl) (TreeMap.height r) of 
                        !ns -> TreeMap.rebalance (TreeMap.Node ns nl r k1 v1)
            Eq -> TreeMap.Node s l r k v
            Gt -> case insertS r k v of 
                    !nr -> case 1 + max (TreeMap.height l) (TreeMap.height nr) of
                        !ns -> TreeMap.rebalance (TreeMap.Node ns l nr k1 v1)
    insertS nil k v = TreeMap.Node 1 TreeMap.Nil TreeMap.Nil k v

    insertkvS k v t = insertS t k v
    updatekvS k v t = insertS t k v

--- 'TreeMap' can be used as array element
derive ArrayElement (TreeMap a b)

derive Show  TreeMap k v

instance ListEmpty (TreeMap a) where
    null TreeMap.Nil = true
    null _ = false
    empty = TreeMap.Nil

instance Monoid Ord a => TreeMap a b where
    mempty = TreeMap.Nil
    mappend = union

instance Functor TreeMap a 


type TreeSet a  = TreeMap a ()

including s o = insert o () s
contains  s o
    | Nothing <- TreeMap.lookup o s  = false
    | otherwise = true;

fromKeys = fold ins empty 
    where
        ins :: Ord a => TreeSet a -> a -> TreeSet a 
        ins t k = t.insert k ()
union s1 = TreeMap.insertList s1 . each
-- intersection s1 s2 = (TreeMap.insertList empty . filter ((s2 `contains`) . fst) . TreeMap.each) s1 
-- diff s1 s2 = (TreeMap.insertList empty . filter (not . (s2 `contains`) . fst) . TreeMap.each) s1
