{-
  This library (deepseq) is derived from code from the GHC project which
  is largely (c) The University of Glasgow, and distributable under a
  BSD-style license (see below).
  It is adapted to work with Frege.

  -----------------------------------------------------------------------------

  The Glasgow Haskell Compiler License

  Copyright 2001-2009, The University Court of the University of Glasgow. 
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

  - Redistributions of source code must retain the above copyright notice,
  this list of conditions and the following disclaimer.
   
  - Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.
   
  - Neither name of the University nor the names of its contributors may be
  used to endorse or promote products derived from this software without
  specific prior written permission. 

  THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY COURT OF THE UNIVERSITY OF
  GLASGOW AND THE CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
  UNIVERSITY COURT OF THE UNIVERSITY OF GLASGOW OR THE CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  DAMAGE.

  -----------------------------------------------------------------------------
-}
{--
    This module provides an overloaded function, 'deepseq', for fully
    evaluating data structures (that is, evaluating to \"Normal Form\").

    'deepseq' differs from 'seq' as it traverses data structures deeply,
    for example, 'seq' will evaluate only to the first constructor in
    the list:

    > > [1,2,undefined] `seq` 3
    > 3

    While 'deepseq' will force evaluation of all the list elements:

    > > [1,2,undefined] `deepseq` 3
    > frege.runtime.Undefined: undefined

    Another common use is to ensure any exceptions hidden within lazy
    fields of a data structure do not leak outside the scope of the
    exception handler, or to force evaluation of a data structure in one
    thread, before passing to another thread (preventing work moving to
    the wrong threads).
-}
module Control.DeepSeq where

import Data.Tree

--- A class of types that can be fully evaluated.
class NFData α where
    --- 'rnf' should reduce its argument to normal form (that is, fully
    --- evaluate all sub-components), and then return '()'.
    rnf :: α -> ()
    rnf a = a `seq` ()

{--
    Fully evaluates @a@ and returns @b@.

    'deepseq': fully evaluates the first argument, before returning the
    second.

    The name 'deepseq' is used to illustrate the relationship to 'seq':
    where 'seq' is shallow in the sense that it only evaluates the top
    level of its argument, 'deepseq' traverses the entire data structure
    evaluating it completely.

    'deepseq' can be useful for forcing pending exceptions,
    eradicating space leaks, or forcing lazy I/O to happen.  It is
    also useful in conjunction with parallel Strategies (see the
    @parallel@ package).
-}
deepseq :: NFData α => α -> β -> β
deepseq a b = rnf a `seq` b

--- the deep analogue of '$!'.  In the expression @f $!! x@, @x@ is
--- fully evaluated before the function @f@ is applied to it.
---
($!!) :: (NFData α) => (α -> β) -> α -> β
f $!! x = x `deepseq` f x

{--
    a variant of 'deepseq' that is useful in some circumstances:

    > force x = x `deepseq` x

    @force x@ fully evaluates @x@, and then returns it.  Note that
    @force x@ only performs evaluation when the value of @force x@
    itself is demanded, so essentially it turns shallow evaluation into
    deep evaluation.
-}
force :: (NFData α) => α -> α
force x = x `deepseq` x

instance NFData Int
instance NFData Integer
instance NFData Long
instance NFData Float
instance NFData Double

instance NFData Char
instance NFData Bool
instance NFData ()

instance NFData String

instance NFData (NFData α) => Maybe α where
    rnf Nothing = ()
    rnf (Just x) = rnf x

instance NFData (NFData α, NFData β) => Either α β where
    rnf (Left x)  = rnf x
    rnf (Right x) = rnf x

instance NFData (NFData α) => [α] where
    rnf [] = ()
    rnf (x:xs) = case rnf x of
                    !_ -> rnf xs

instance NFData (NFData α) => (Tree α) where
    rnf (Node a b) = rnf a `seq` rnf b

instance NFData (NFData α, NFData β) => (α -> β) where
    rnf !_ = ()

instance NFData (NFData α, NFData β) => (α, β) where
    rnf (a, b) = rnf a `seq` rnf b
instance NFData (NFData α, NFData β, NFData γ) => (α, β, γ) where
    rnf (a, b, c) = rnf a `seq` rnf b `seq` rnf c
instance NFData (NFData α, NFData β, NFData γ, NFData δ) => (α, β, γ, δ) where
    rnf (a, b, c, d) = rnf a `seq` rnf b `seq` rnf c `seq` rnf d

{-
instance NFData ( NFData α1
                , NFData α2
                , NFData α3
                , NFData α4
                , NFData α5
                , NFData α6
                , NFData α7
                , NFData α8
                , NFData α9
                , NFData α10
                , NFData α11
                , NFData α12
                , NFData α13
                , NFData α14
                , NFData α15
                , NFData α16
                , NFData α17
                , NFData α18
                , NFData α19
                , NFData α20
                , NFData α21
                , NFData α22
                , NFData α23
                , NFData α24
                , NFData α25
                , NFData α26
                ) => ( α1
                     , α2
                     , α3
                     , α4
                     , α5
                     , α6
                     , α7
                     , α8
                     , α9
                     , α10
                     , α11
                     , α12
                     , α13
                     , α14
                     , α15
                     , α16
                     , α17
                     , α18
                     , α19
                     , α20
                     , α21
                     , α22
                     , α23
                     , α24
                     , α25
                     , α26
                     ) where
    rnf (a
        , b
        , c
        , d
        , e
        , f
        , g
        , h
        , i
        , j
        , k
        , l
        , m
        , n
        , o
        , p
        , q
        , r
        , s
        , t
        , u
        , v
        , w
        , x
        , y
        , z
        )
     = rnf a
       `seq` rnf b
       `seq` rnf c
       `seq` rnf d
       `seq` rnf e
       `seq` rnf f
       `seq` rnf g
       `seq` rnf h
       `seq` rnf i
       `seq` rnf j
       `seq` rnf k
       `seq` rnf l
       `seq` rnf m
       `seq` rnf n
       `seq` rnf o
       `seq` rnf p
       `seq` rnf q
       `seq` rnf r
       `seq` rnf s
       `seq` rnf t
       `seq` rnf u
       `seq` rnf v
       `seq` rnf w
       `seq` rnf x
       `seq` rnf y
       `seq` rnf z
-}
