
--- The strict 'State' 'Monad'

module frege.control.monad.State
        inline  (State.State.>>=, State.State.>>, 
                State.State.return, State.State.get,
                StateT.>>=, StateT.>>, 
                StateT.return, StateT.get) 
    where

import frege.control.monad.trans.MonadTrans
import frege.control.monad.trans.MonadIO
-- class MonadState m where
--     get :: m s s
--     put :: s -> m s ()
--     modify :: (s -> s) -> m s () 


{--
    @State s a@ is an abstrac data type that resembles a stateful computation
    with State _s_ and result _a_,
    i.e. functions of type @s -> (a, s)@
    where the State is immutable.
 -}
abstract data State s a = State (s -> (a, s)) where
    --- run a stateful computation
    public run (State x) s = x s
    --- return the state from the internals of the monad
    public get   = State doublestate
    
    --- replace the 'State' inside the monad 
    public put x = State (const ((); x))
    --- modify the 'State'
    public modify f = State (\state -> ((); f state))
    --- lift a value to the 'State' monad
    public return a        =  State (strictTuple2 a)
    --- monadic bind for the 'State' monad
    public State a >>= k  =  State (\s -> case a s of 
                                        (v, s') -> case k v of 
                                            State.State b -> b s'
                                    )
    public a >> b = a  State.>>=  (const b)    

    protected doublestate s = (s;s)
    
instance Monad (State s)
-- instance MonadState State

-- Haskell compatibility

-- runState :: State s a -> s -> (a,s)
runState    = State.run
evalState s = fst . State.run s
execState s = snd . State.run s
-- state       = State.State

data StateT s m a = StateT { run ::  s -> m (a,s) } where
    get   = StateT doublestate 
    put s = StateT (\_ -> return ((); s))
    modify f = StateT (\s -> return ((); f s))
    doublestate s = return (s;s) 
 
instance Monad  (Monad m) => (StateT s m) where
    return a         = StateT (\s -> return (a,s))
    (StateT x) >>= f = StateT (\s -> do
        (v,s') <- x s          -- get new value and state
        StateT.run (f v) s'     -- pass them to f
      )
    a >> b = a  >>=  (const b)

instance MonadPlus (MonadPlus m) => (StateT s m) where
    mzero = StateT (\s -> mzero)
    (StateT x1) `mplus` (StateT x2) = StateT (\s -> (x1 s) `mplus` (x2 s))

instance MonadAlt (MonadAlt m) => (StateT s m) where
    pzero = StateT (\s -> pzero)
    (StateT x1) <|> (StateT x2) = StateT (\s -> (x1 s) <|> (x2 s))
    (StateT x1) <+> (StateT x2) = StateT (\s -> (x1 s) <+> (x2 s))
    
instance MonadTrans (StateT s) where
    lift c = StateT (\s -> c >>= (\x -> return (x;s)))

instance MonadIO (MonadIO m) =>  (StateT s m) where
    liftIO = lift . liftIO
    
promote st = StateT (\s -> return (State.run st s))