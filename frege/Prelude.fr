// enable UTF-8: «««««••••••••••••»»»»»»
/**
 * This package provides basic definitions for the Frege language.
 *
 * (C) Ingo Wechsung 2006, 2007, 2008, 2009, 2010
 *
 * The /Prelude/ is imported explicitely or implicetely during compilation
 * of any other package.
 * It defines basic data structures, classes and functions.
 *
 * The types and constructors for lists, unit type and tuple types are not
 * defined here: They are provided programmaticaly by the compiler when it
 * compiles a package with the name @frege.Prelude@. Nevertheless, they are
 * considered part of the /Prelude/, thus qualified names like 'Prelude.(,)'
 * are okay.
 *
 * The package is /implementation specific/ insofar as the compiler may
 * assume that certain items are defined here in a certain way.
 * Changes may thus lead
 * to compiler crashes or java code that will be rejected by the java compiler.
 */
/**
                Overview of the type class hierarchy

 >   Eq                         equality, provides relational operators '==' and '!='
 >       Ord                    ordering, provides relational operators '<' '<=' '>' '>=' and '<=>'
 >           Enum               enumarations (succ, pred, etc.)
 >           Num                numbers
 >               Real           real numbers
 >               Integral       integral numbers
 >   Show                       string representation of values
 >   Length                     data types that have a length
 >   Empty                      data types that have an empty value
 >   AbstractList               data types that behave like lists

*/
/*
Uncommon characters defined here:

> Char   used for               howto type   in editor
> •      function composition   ALT+0149     CTRL+.
> «      left shift?            ALT+0171     CTRL+<
> »      right shift?           ALT+0187     CTRL+Shift+<
> ¦      to be determined       ALT+0166     Alt+Shift+<
> ¿      to be determined       ALT+0191     CTRL+ß (?)
>
*/

package frege.Prelude where

/*
 * $Author$
 * $Revision$
 * $Id$
 * $Date$
 */


/*
 * Here are the standard operators in precedence order
 * (higher numbers mean less tight binding)
 * This is so that @(f x)@ can be tought of as having precedence 0
 */

infixr 1 `<~` `~>` `•`
infixl 1 `!!`
infixr 2 `**` `??` `^`
infix  2 `=~` `!~` `?~` `/~`  `~` `~~` `~~~`
infixl 3 `*` `/` `%` `mod` `rem` `div`
infixl 4 `+` `-`
infixr 4 `++`
infixl 5 `<<` `bshl` `bshr`
infixl 6 `band`
infixl 7 `bor` `bxor`
infix  8 `<=` `>=` `<` `>` `elem` `notElem`
infix  9 `<=>`
infix  10 `==` `!=` `===` `!==` // `<>`
infixr 11 `&&`  `and`
infixr 12 `||`  `or` `xor`
infix  13 `..`
infixr 13 `:`
infixr 14 `>>` `>>=`              // monad bind
infixr 15 `:=` `=<<` `@` `seq`    // so that in x@a:bs x is bound to the list
infixr 16 `$` `$!`


//------------------------------------------------------------------------------
//          CLASS SECTION
//------------------------------------------------------------------------------


/** The class 'Eq' provides operators '==' and '!='.
  All types whose values can be compared for equality should be instances of
  this class. For algebraic data types instances can be automatically derived
  if all components are themselves instances of 'Eq'.
  */
class Eq eq where
    /// Check for equality. This function is required in all instances.
    /// Ayn Rand's favorite law
    /// > a == a
    /// shall be obeyed by all implementations.
    (==) :: eq -> eq -> Bool               // must be defined in instances
    /// Check for inequality. The default implementation obeys the laws
    /// > !(a != a)
    /// > (a != b) == !(a == b)
    /// > (a == b) != (a != b)
    /// These laws shall also be obeyed in all implementations.
    (!=) :: eq -> eq -> Bool
    a!=b =  if a==b then false else true   // may be replaced by more efficient version



/**
 * A class for data types that have a notion of length.
 */
class Length this where
    /// computes the length of a value in a type dependend way
    length :: this -> Int

/**
 * A class for data types that have a notion of emptieness.
 */
class Empty this where
    /// check for empty thing
    null  :: this -> Bool
    /// create an empty thing
    empty :: this


/**
 * A class for data types that behave like lists.
 */
class AbstractList (Length this, Empty this) => this where
    // Get the element at the head of a non empty list, otherwise 'undefined'
    // head :: this elem -> elem
    // Construct. Note that
    // >head (cons a as) == a && tail (cons a as) == as
    // cons :: elem -> this elem -> this elem
    /// Get the tail elements. This is 'undefined' if the list is empty.
    tail :: this -> this
    /// concatenate two lists, strings or whatever
    ///  > empty ++ x == x && x ++ empty == x
    (++) :: this -> this -> this


/**
 * A class for things we can make a list from
 */
class ListSource t where
    /// converts the value to a list
    toList :: forall t e  . t e -> [e]

instance ListSource Maybe where
    toList (Just a) = [a]
    toList Nothing  = []

instance ListSource  Either l where
    toList (Left _) = []
    toList (Right a) = [a]


instance Eq Bool where
    pure native == :: Bool -> Bool -> Bool
    pure native != :: Bool -> Bool -> Bool


//////////////////////////////////////////////////////////////////////
//          DATA SECTION
//

//////////////////////////////////////////////////////////////////////
//          INSTANCE SECTION
//

instance Length String where
    /// Get the length of a 'String'
    pure native length :: String -> Int


instance Empty String where
    //* Check if a 'String' is empty
    null "" = true
    null s  = false
    //* The empty 'String'
    empty = ""



instance Empty [a] where
    null [] = true
    null _ = false
    empty = []


instance Length [a] where
    length as = len as 0 where
        len (_:as) !acc = len as (acc+1)
        len []     !acc = acc


instance AbstractList [a] where
    tail (_:xs) = xs
    tail [] = error "List.tail []"
    (a:as) ++ bs = a:(as++bs)
    []     ++ bs = bs

instance AbstractList String where
    // head "" = error "String.head \"\""
    // head s  = s.charAt 0;
    tail "" = error "String.tail \"\""
    tail s  = strtail s 1
    // cons c s = (ctos c) ++ s

//////////////////////////////////////////////////////////////////////
//          FUNCTIONS SECTION
//

/**
 * Determines the constructor of a value.
 * This is used like
 * >constructor arg
 * where @arg@ is any frege value.
 *
 * Returns 0 for product types and native types or
 * the /constructor number/ for constructed types. The /constructor number/
 * is a small integer stored in every constructed value. It indicates by
 * what data constructor a value was constructed.
 *
 * The compiler assigns constructor numbers starting from 0 to the constructors
 * defined in a @data@ definition in the order of their appearance.
 *
 * Examples
 * >constructor [] == 0
 * >constructor (a:as) == 1
 * >constructor "string"  == 0    // native value
 *
 * This function is strict in its argument, i.e.
 * >constructor undefined == undefined
 *
 * *Implementation specific:* This function is used in derived instances
 * of 'Eq' and 'Ord'.
 */
pure native constructor "frege.RT.constructor" :: a -> Int;

// ######## Java Boxed Types ####################
data JBoolean   = native java.lang.Boolean
data JByte      = native java.lang.Byte
data JChar      = native java.lang.Character
data JShort     = native java.lang.Short
data JInteger   = native java.lang.Integer
data JLong      = native java.lang.Long
data JFloat     = native java.lang.Float
data JDouble    = native java.lang.Double

//######### Basic types      ####################
/**
    'Bool' values are based on Java's primitive @boolean@ values.
    Note that @true@ and @false@ are literals, not constructors.
 */
data Bool = native boolean

/**
This is a constant with the value @true@.
It is most often used as the last alternative in pattern guards:

> foo n | n >= 0    = ...
>       | otherwise = ...
*/
otherwise = true

/**
This is used by code generation when a conditional expression
appears in a lazy context, i.e.
> (42, if foo then bar else baz)
@lazyif a b c@ evaluates to @b@ if @a@ is @true@, otherwise to @c@.
*/
lazyif a b c = if a then b else c

/**
    'Int' values are based on Java's primitive @int@ values.

    The existence of this type is assumed in numerous places in the compiler.

    Like with all @native@ Java types, be they primitive or reference types,
    Frege holds the raw @int@ in boxed form. However, in certain cases the
    compiler will optimize the boxing away:
    - Strict variables or function arguments work with the unboxed value directly.
    - Functions with a @native@ return type generally return the unboxed value.
    Polymorphic data structures or functions always work with boxed values.
    Thus, for example, the function
    > sum a b c = a + b + c
    can compute the sum of 3 'Int's, 'Long's, 'Double's or any other values
    of a type that is an instance of type class 'Num', but it may be somewhat
    slower than functions spezialized for a given type.

    According to the Java Language Specification, @int@ values are
    32 bit wide signed two's complement integers (§4.2). Java operations on @int@ do
    not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 32 bits of
    every result are retained.
 */
data Int = native int where
    /// convert an 'Int' to a 'Float', i.e. @2.float == 2.0f@.
    /// For large integers, the result may have been be rounded.
    pure native float java.lang.Float.valueOf ::    Int -> Float
    /// convert an 'Int' to a 'Double', i.e. @2.double == 2.0@.
    pure native double java.lang.Double.valueOf ::  Int -> Double
    /// Convert an 'Int' to a 'Long', i.e. @2.long == 2L@.
    pure native long java.lang.Long.valueOf ::      Int -> Long
    /// @i.char@ returns the 'Char' value whose ordinal number is @i@
    /// Result is only valid for integers in the range 0..65535
    pure native char "(char)"  ::            Int -> Char
    /// Computes binary /or/ of two integers. Uses the java @|@-operator.
    pure native bor  `|` :: Int -> Int -> Int
    /// Computes binary /exclusive or/ of two integers. Uses the java @^@-operator.
    pure native bxor `^` :: Int -> Int -> Int
    /// Computes binary /and/ of two integers. Uses the java @&@-operator.
    pure native band `&` :: Int -> Int -> Int
    // Compare 2 intergers, use java operator
    // pure native (==) :: Int -> Int -> Bool   // is defined in Eq
    /// convert to a hexadecimal string
    pure native toHexString java.lang.Integer.toHexString :: Int -> String

/**
 * 'Integer' is
 * a type for integer numbers of unlimited size,
 * It has instances for 'Eq', 'Ord', 'Show' and 'Integral'.

 * This is derived from @java.math.BigInteger@.
 */


data Integer = native java.math.BigInteger where
    // constants
    pure  native zero    java.math.BigInteger.ZERO    :: Integer
    pure  native one     java.math.BigInteger.ONE     :: Integer
    pure  native ten     java.math.BigInteger.TEN     :: Integer
    /// construction from a 'Long', see also 'String.aton' and 'String.integer'
    pure  native valueOf java.math.BigInteger.valueOf :: Long -> Integer
    // arithmetic operations
    pure  native +       add                          :: Integer -> Integer -> Integer
    pure  native *       multiply                     :: Integer -> Integer -> Integer
    pure  native -       subtract                     :: Integer -> Integer -> Integer
    pure  native div     divide                       :: Integer -> Integer -> Integer
    pure  native rem     remainder                    :: Integer -> Integer -> Integer
    /// /Warning/! Throws @ArithmeticException@ when divisor is negative.
    pure  native nMod    mod                          :: Integer -> Integer -> Integer
    /**
     * The native @java.math.BigInteger.mod@ method throws
     * an @ArithmeticException@ when the divisor is  lower than 0
     * This is incompatible with 'Integral.mod' thus we force
     * the divisor to be positive.
     */
    a `mod` b = nMod a (abs b)
    pure  native abs                                  :: Integer -> Integer
    pure  native negate                               :: Integer -> Integer
    // relational
    pure  native compareTo                            :: Integer -> Integer -> Int
    pure  native max                                  :: Integer -> Integer -> Integer
    pure  native min                                  :: Integer -> Integer -> Integer
    // shift
    pure  native bshr    shiftRight                   :: Integer -> Int -> Integer
    pure  native bshl    shiftLeft                    :: Integer -> Int -> Integer
    // bit arithmetic
    pure  native bor     or                           :: Integer -> Integer -> Integer
    pure  native band    and                          :: Integer -> Integer -> Integer
    pure  native bxor    xor                          :: Integer -> Integer -> Integer
    // miscellanous
    pure native bitLength                            :: Integer -> Int
    pure native toString                             :: Integer -> String
    pure native sign    signum                       :: Integer -> Int
    pure native long    longValue                    :: Integer -> Long
    pure native int     intValue                     :: Integer -> Int

/**
 * Types that can be converted to 'Integer'
 */
class IntegerConvertable this where
    /// returns an 'Integer' with the same value as the argument
    big :: this -> Integer

instance IntegerConvertable Long where
    big l = Integer.valueOf l

instance IntegerConvertable Int where
    big i = Integer.valueOf i.long

/**
 * 'Long' values are based on Java's primitive @long@ values.
 *
 * According to the Java Language Specification, @long@ values are
   64 bit wide signed two's complement integers (§4.2). Java operations on @long@ do
   not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 64 bits of
   every result are retained.
 */
data Long = native long  where
    /// Convert an 'Long' to a 'Float', i.e. @42L.float == 42.0f@.
    /// For large numbers, the result may have been be rounded.
    pure native float java.lang.Float.valueOf ::   Long -> Float
    /// Convert an 'Long' to a 'Double', i.e. @42L.double == 42.0@.
    /// For large numbers, the result may have been be rounded.
    pure native double java.lang.Double.valueOf :: Long -> Double
    /// Uses a java cast to convert a 'Long' to an 'Int'. This is a /narrowing primitive conversion/ in java parlance.
    pure native int "(int)"  ::          Long -> Int
    /// Computes binary /or/ of two long integers. Uses the java @|@-operator.
    pure native bor  `|` :: Long -> Long -> Long
    /// Computes binary /exclusive or/ of two long integers. Uses the java @^@-operator.
    pure native bxor `^` :: Long -> Long -> Long
    /// Computes binary /and/ of two integers. Uses the java @&@-operator.
    pure native band `&` :: Long -> Long -> Long

//* 'Char' values are based on Java's primitive @char@ values.
data Char = native char where
    /**
     * @c.ord@ is the ordinal (integer) value of the character @c@.
     * It holds: @c.ord.char@ == @c@, see 'Int.char'.
     * (But note that @i.char.ord@ is not necessarily @i@)
     */
    pure native ord "(int)"                                     :: Char -> Int
    pure native isLowerCase    java.lang.Character.isLowerCase  :: Char -> Bool
    pure native isUpperCase    java.lang.Character.isUpperCase  :: Char -> Bool
    pure native isWhitespace   java.lang.Character.isWhitespace :: Char -> Bool


/// 'String' values are based on Java's @java.lang.String@ objects.
data String = native java.lang.String where
    /** Like 'String.int', but the exception is not checked, thus only good when one *knows for sure* that the parse will succeed. */
    pure native atoi java.lang.Integer.parseInt   :: String  -> Int
    /** Like 'String.long', but the exception is not checked, thus only good when one *knows for sure* that the parse will succeed. */
    pure native atol java.lang.Long.parseLong     :: String  -> Long
    /** Like 'String.float', but the exception is not checked, thus only good when one *knows for sure* that the parse will succeed. */
    pure native atof java.lang.Float.parseFloat   :: String  -> Float
    /** Like 'String.double', but the exception is not checked, thus only good when one *knows for sure* that the parse will succeed. */
    pure native atod java.lang.Double.parseDouble :: String  -> Double
    /** Like 'String.integer', but the exception is not checked, thus only good when one *knows for sure* that the parse will succeed. */
    pure  native aton new                          :: String  -> Integer
    /** Safe way to parse an integer from a string.
        @java.lang.NumberFormatException@ will be catched and returned as 'Left' value.
        When the parse succeeds, the integer is returned in the 'Right' value.

        Use like this:
        > case s.int of
        >   Left exc -> ... // s is not well formed
        >   Right i  -> ... // the parsed value is in i
    */
    pure  native int    java.lang.Integer.parseInt   :: String  -> Exception Int
    /// Safe way to parse a long integer from a string. See 'String.int'
    pure  native long   java.lang.Long.parseLong     :: String  -> Exception Long
    /// Safe way to parse a 'Float' value from a string. See 'String.int'
    pure  native float  java.lang.Float.parseFloat   :: String  -> Exception Float
    /// Safe way to parse a 'Double' value from a string. See 'String.int'
    pure  native double java.lang.Double.parseDouble :: String  -> Exception Double
    /// Safe way to parse a big 'Integer' value from a string. See 'String.int'
    pure  native integer new                         :: String  -> Exception Integer
    /// retrieve character at index
    pure  native charAt :: String -> Int -> Char
    /// Get character at index.
    /// This will allow to use a string like an array, e.g. @"xyz".[1]@
    pure  native frozenGetAt  charAt :: String -> Int -> Char
    pure  native elemAt charAt :: String -> Int -> Char
    /// interpret this string as regex (unsafe, does not catch exceptions)
    /// see 'regcomp' for an alternative
    pure  native compile java.util.regex.Pattern.compile :: String -> Regex
    /// quote regular expression metacharacters in string
    pure  native quote   java.util.regex.Pattern.quote   :: String -> String
    /// quote replacement string metacharacters in string
    pure  native quoteReplacement   java.util.regex.Matcher.quoteReplacement
                            :: String -> String
    /// convert to lower case
    pure  native toLowerCase :: String -> String
    /// convert to upper case
    pure  native toUpperCase :: String -> String
    /// 'compareTo' is used in the 'Ord' instance of 'String'
    pure  native compareTo :: String -> String -> Int
    /// Concatenate two strings, uses Java's @+@ operator
    pure  native ++ + :: String -> String -> String    // String concatenation
    /// get the has code
    pure  native hashCode :: String -> Int

/**
     @substr s start end@ returns the sub string of @s@ that starts
     with the character at position @start@
     and extends to the character at position @end-1@.

    This uses the native method @substring@ of class @java.lang.String@. It
    will throw an @IndexOutOfBoundsException@ if @start@ is negative or larger than
    @end@ or if @end@ is greater than the length of @s@.
 */
pure native substr     substring :: String -> Int -> Int -> String;
/**
    @strtail s n@ returns a new string that is a substring of string /s/.
    The substring begins with the character at the specified index
    and extends to the end of /s/.

    This uses the native method @substring@ of class @java.lang.String@. It
    will throw an @IndexOutOfBoundsException@ if /n/ is negative or larger than
    the length of /s/.
*/
pure native strtail        substring :: String -> Int -> String
strhead s i = substr s 0 i
/// compile a 'String' to a 'Regex'
pure native regcomp        java.util.regex.Pattern.compile :: String -> Exception Regex
atoi (s::String) = s.atoi


/// 'Float' values are based on Java's primitive @float@ values.
/**
    According to the Java Language Specification §4.2.3, @float@ values are
    32-bit-precision binary floating point values. The values and the operations
    on it behave as speicified in the IEEE Standard for Binary Floating-Point Arithmetic.
*/
data Float = native float where
    /**
      Returns the closest 'Int' value to the argument.
      The result is rounded to an integer by adding 1/2,
      taking the 'floor' of the result,
      and casting the result to type int.

      The following property holds:

      > (f < Int.maxBound.float && f > Int.minBound.float) ==>
      >   (f.int.float == (f + 0.5f).floor)

      Special cases:
      - If the argument is NaN, the result is 0.
      - If the argument is negative infinity or any value less than or equal
      to the value of 'Int.minBound', the result is equal to the value of
      'Int.minBound'.
      - If the argument is positive infinity or any value greater than or equal
      to the value of 'Int.maxBound', the result is equal to the value of
      'Int.maxBound'.
    */
    pure  native int    java.lang.Math.round :: Float -> Int
    /**
      Returns the largest (closest to positive infinity) value that is
      less than or equal to the argument and is equal to a mathematical integer.

      Special cases:

        - If the argument value is already equal to a mathematical integer,
        then the result is the same as the argument.
        - If the argument is NaN or an infinity or positive zero or
        negative zero, then the result is the same as the argument.
    */
    floor f = (Float.double f).floor.float
    /// Applies the java widening primitive conversion from @float@ to @double@.
    pure  native double "(double)"           :: Float -> Double

/// 'Double' values are Java's primitive @double@ values.
/**
    According to the Java Language Specification §4.2.3, @double@ values are
    64-bit-precision binary floating point values. The values and the operations
    on it behave as speicified in the IEEE Standard for Binary Floating-Point Arithmetic.
    */
data Double = native double where
    /**
      Returns the closest 'Long' value to the argument.
      The result is rounded to an integer by adding 1/2,
      taking the 'floor' of the result,
      and casting the result to type @long@.

      The following property holds:

      > (d < Long.maxBound.double && d > Long.minBound.double) ==>
      >   (d.long.double == (d + 0.5d).floor)

      Special cases:
      - If the argument is NaN, the result is 0.
      - If the argument is negative infinity or any value less than or equal
      to the value of 'Long.minBound', the result is equal to the value of
      'Long.minBound'.
      - If the argument is positive infinity or any value greater than or equal
      to the value of 'Long.maxBound', the result is equal to the value of
      'Long.maxBound'.
     */
    pure  native long   java.lang.Math.round :: Double -> Long
    /**
      Returns the largest (closest to positive infinity) value that is
      less than or equal to the argument and is equal to a mathematical integer.

      Special cases:

        - If the argument value is already equal to a mathematical integer,
        then the result is the same as the argument.
        - If the argument is NaN or an infinity or positive zero or
        negative zero, then the result is the same as the argument.

     */
    pure  native floor  java.lang.Math.floor :: Double -> Double
    /// Applies the java narrowing primitive conversion from @double@ to @float@
    pure  native float  "(float)"            :: Double -> Float


/**
 *   'Regex' values are based on Java's @java.util.regex.Pattern@ objects.
 *   All regular expression literals are values of this type.
 */
data Regex = native java.util.regex.Pattern where
    pure native pattern :: Regex -> String
    /// create a 'Matcher' from a regular expression and a 'String'
    pure native matcher :: Regex -> String -> Matcher
    pure native split   :: Regex -> String -> StringArr
    /**
        Split a string around matches of a regular expression and return
        the result as list of strings.
    */
    splitted r s = (split r s).toList

/**
    'Matcher' values are based on Java's @java.util.regex.Matcher@ objects.
    Code generation relies on the existence of this type and its operations.

    The native 'Matcher' functions that correspond to java methods
    of the @java.util.regex.Matcher@ class that modify the state of the
    object they are invoked on
    ('Matcher.find', 'Matcher.matches', 'Matcher.replaceFirst', 'Matcher.replaceAll',
    'Matcher.usePattern', 'Matcher.useAnchoringBounds') are implemented
    so that they make a copy of the 'Matcher' and invoke the impure java method
    on the copy.

    Frege 'Matcher's can thus be regarded as read-only values and
    the functions defined here as pure. If you need to pass a 'Matcher' to
    other native functions, be sure that the function is pure. If it is not
    because it would modify the matcher, and you do not need the match result, always
    pass a clone of the Matcher (see 'Matcher.clone')

*/
data Matcher = pure native java.util.regex.Matcher where
    pure  native clone frege.RT.clone :: Matcher -> Matcher
    /** Tries a match and if it succeeds, returns @Just m@, where @m@ is
     *  a new 'Matcher' that contains the result. If there is no match, @Nothing@
     *  is returned.
     *
     *  The following java fragment appends all matched substrings of a string:
     *  > String s = "cats and dogs are not concatenated.";
     *  > Pattern p = Pattern.compile("cat|dog");
     *  > String result = "";
     *  > Matcher m = p.matcher(s);
     *  > while (m.find()) result += m.group(0);  // "catdogcat"
     *  The follwoing frege fragment computes the same result:
        > result = loop m "" where
        >      s = "cats and dogs are not concatenated."
        >      p = #cat|dog#
        >      m = p.matcher s
        >      loop :: Matcher -> String -> String
        >      loop m1 r | Just m2 <- m1.find = loop m2 (r++m2.match)
        >                | otherwise = r
     */
    pure  native find   frege.RT.find :: Matcher -> Maybe Matcher
    /// Tries to match the entire string and returns @Just m@ on success and otherwise @Nothing@.
    pure  native matches frege.RT.matches  :: Matcher -> Maybe Matcher
    /**
        Retrieves the input subsequence captured by the given group
        during the previous match operation.

        Capturing groups are indexed from left to right, starting at one.
        Group zero denotes the entire pattern, so the expression @(m.group 0)@
        retrieves that portion of the input string that was matched by the pattern.

        If the match was successful but the group specified failed to match any
        part of the input sequence, then 'Nothing' is returned. Note that some
        groups, for example @(a?)@, match the empty string.
        This functon will return @Just ""@ when such a group successfully
        matches the empty string in the input.

        The folloing property holds for a 'Matcher' /m/ with input
        sequence /s/ and group index /g/:
        > isJust (m.group g) ==> (m.group g) == Just (s.substr (m.start g) (m.end g))
    */
    pure  native group                :: Matcher -> Int -> (Maybe String)
    /**
        @Matcher.match m@ returns the input subsequence matched by the previous match.
        The result is 'undefined' if the last match was not successful.

        For a 'Matcher' @m@ with input sequence @s@, the following holds:
        > isJust (m.group 0) ==> unJust (m.group 0) == m.match

        Note that some patterns, for example @a?@, match the empty string.
        This method will return the empty string when the pattern successfully
        matches the empty string in the input.
    */
    pure  native match group          :: Matcher -> String

    /**
        Returns the start index of the subsequence captured by the
        given group during the previous match operation where group 0 denotes
        the entire pattern.

        If the specified capturing group failed to match,
        the return value will be -1.

        The follwoing property holds:
        > (m.group n == Nothing) ==> (m.start n < 0)
    */
    pure  native start                :: Matcher -> Int -> Int

    /**
        Returns the offset after the last character of the subsequence
        captured by the
        given group during the previous match operation where group 0 denotes
        the entire pattern.

        If the specified capturing group failed to match,
        the return value will be -1.

        The follwoing property holds:
        > (m.group n == Nothing) ==> (m.end n < 0)
    */
    pure  native end                  :: Matcher -> Int -> Int

    /**
        Makes a new 'Matcher' and causes it to use a different 'Regex' for future matches.

        The original matchers position in the input and its
        last append position is copied, but information about the last match, if any,
        is not.

        This is most useful with patterns that start with the @\\G@ anchor.

        Note that, due to a java bug, if the last find operation matched the empty string,
        the next find will fail. For a workaround see 'usePatternAndFind'
    */
    pure  native usePattern frege.RT.usePattern :: Matcher -> Regex -> Matcher

    /**
        Makes a new 'Matcher' with a different 'Regex' and tries to find a match.
        If the last find on the original Matcher returned an empty result, it
        calls @mnew.find(morig.end(0))@ to work around a bug in the java API.
        Therefore, this function must only be used on a matcher whose last match
        attempt was successful.
    */
    pure  native usePatternAndFind frege.RT.usePatternAndFind :: Matcher -> Regex -> Maybe Matcher

    /// Requires or forbids the matcher to acknowledge anchors.
    pure  native useAnchoringBounds frege.RT.useAnchoringBounds :: Matcher -> Bool ->  Matcher

    /**
       Returns the string representation of this matcher.
       The string representation of a 'Matcher' contains information
       that may be useful for debugging. The exact format is unspecified.
    */
    pure  native toString         :: Matcher -> String

    /**
       Replaces the first subsequence of the input sequence that matches
       the pattern with the given replacement string.

       This method scans the input sequence from the start
       looking for a match of the pattern.
       Characters that are not part of the match are appended directly
       to the result string; the match is replaced in the result by the
       replacement string. The replacement string may contain references
       to captured subsequences.

       Note that backslashes (\\) and dollar signs ($) in the replacement
       string may cause the results to be different than if it were
       being treated as a literal replacement string.
       Dollar signs may be treated as references to captured subsequences
       as described above, and backslashes are used to escape
       literal characters in the replacement string.

       Given the regular expression @#dog#@, the input @"zzzdogzzzdogzzz"@,
       and the replacement string @"cat"@, an invocation of this function
       on a matcher for that expression would yield the string
       @"zzzcatzzzdogzzz"@.
    */
    pure  native replaceFirst frege.RT.replaceFirst :: Matcher -> String -> String

    /// Like 'replaceFirst', but replaces all matches.
    pure  native replaceAll   frege.RT.replaceAll   :: Matcher -> String -> String


/**
 * This is the principal return type for java methods that are expected to
 * throw exceptions.
 */
type Exception a = Either JException a

/**
 * We need to do some reflection from frege code.
 * For example, when we catch an 'JException' thrown from Java code.
 * we might want to know what it is.
 */
data Class = pure native java.lang.Class where
    pure  native getName :: Class -> String
    pure  native forName java.lang.Class.forName :: String -> Exception Class


/// Frege wrapper for java exceptions.
data JException = pure native java.lang.Exception where
    pure native getLocalizedMessage :: JException -> String
    pure native getMessage ::          JException -> String
    pure native getClass   ::          JException -> Class
    /// give the name of this exception
    catched t = (JException.getClass t).getName



/**
 * Constructs a strict tuple.
 * The difference to '(,)' is that both argument values
 * will be evaluated before the tuple is constructed. Thus:
 * >fst (42; undefined) == undefined
 * >fst (42, undefined) == 42
 * *Implementation specific:* The compiler will rewrite @(a;b)@ as
 * @(Prelude.strictTuple2 a b)@.
 */
pure native strictTuple2  Prelude.TTuple2.mk :: a -> b -> (a,b);
/// Constructs a strict 3-tuple. See remarks for 'strictTuple2'.
pure native strictTuple3  Prelude.TTuple3.mk :: a -> b -> c -> (a,b,c);
/// Constructs a strict 4-tuple. See remarks for 'strictTuple2'.
pure native strictTuple4  Prelude.TTuple4.mk :: a -> b -> c -> d -> (a,b,c,d);
/// Constructs a strict 5-tuple. See remarks for 'strictTuple2'.
pure native strictTuple5  Prelude.TTuple5.mk :: a -> b -> c -> d -> e -> (a,b,c,d,e);
/// Constructs a strict 6-tuple. See remarks for 'strictTuple2'.
pure native strictTuple6  Prelude.TTuple6.mk :: a -> b -> c -> d -> e -> f -> (a,b,c,d,e,f);
/// Constructs a strict 7-tuple. See remarks for 'strictTuple2'.
pure native strictTuple7  Prelude.TTuple7.mk :: a -> b -> c -> d -> e -> f -> g -> (a,b,c,d,e,f,g);
/// Constructs a strict 8-tuple. See remarks for 'strictTuple2'.
pure native strictTuple8  Prelude.TTuple8.mk :: a -> b -> c -> d -> e -> f -> g -> h -> (a,b,c,d,e,f,g,h);
/// Constructs a strict 9-tuple. See remarks for 'strictTuple2'.
pure native strictTuple9  Prelude.TTuple9.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (a,b,c,d,e,f,g,h,i);
/// Constructs a strict 10-tuple. See remarks for 'strictTuple2'.
pure native strictTuple10 Prelude.TTuple10.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a,b,c,d,e,f,g,h,i,j);
/// Constructs a strict 11-tuple. See remarks for 'strictTuple2'.
pure native strictTuple11 Prelude.TTuple11.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a,b,c,d,e,f,g,h,i,j,k);
/// Constructs a strict 12-tuple. See remarks for 'strictTuple2'.
pure native strictTuple12 Prelude.TTuple12.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a,b,c,d,e,f,g,h,i,j,k,l);
/// Constructs a strict 13-tuple. See remarks for 'strictTuple2'.
pure native strictTuple13 Prelude.TTuple13.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a,b,c,d,e,f,g,h,i,j,k,l,m);
/// Constructs a strict 14-tuple. See remarks for 'strictTuple2'.
pure native strictTuple14 Prelude.TTuple14.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n);
/// Constructs a strict 15-tuple. See remarks for 'strictTuple2'.
pure native strictTuple15 Prelude.TTuple15.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);
/// Constructs a strict 16-tuple. See remarks for 'strictTuple2'.
pure native strictTuple16 Prelude.TTuple16.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p);
/// Constructs a strict 17-tuple. See remarks for 'strictTuple2'.
pure native strictTuple17 Prelude.TTuple17.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q);
/// Constructs a strict 18-tuple. See remarks for 'strictTuple2'.
pure native strictTuple18 Prelude.TTuple18.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r);
/// Constructs a strict 19-tuple. See remarks for 'strictTuple2'.
pure native strictTuple19 Prelude.TTuple19.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s);
/// Constructs a strict 20-tuple. See remarks for 'strictTuple2'.
pure native strictTuple20 Prelude.TTuple20.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t);
/// Constructs a strict 21-tuple. See remarks for 'strictTuple2'.
pure native strictTuple21 Prelude.TTuple21.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u);
/// Constructs a strict 22-tuple. See remarks for 'strictTuple2'.
pure native strictTuple22 Prelude.TTuple22.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v);
/// Constructs a strict 23-tuple. See remarks for 'strictTuple2'.
pure native strictTuple23 Prelude.TTuple23.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w);
/// Constructs a strict 24-tuple. See remarks for 'strictTuple2'.
pure native strictTuple24 Prelude.TTuple24.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x);
/// Constructs a strict 25-tuple. See remarks for 'strictTuple2'.
pure native strictTuple25 Prelude.TTuple25.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y);
/// Constructs a strict 26-tuple. See remarks for 'strictTuple2'.
pure native strictTuple26 Prelude.TTuple26.mk :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z);




/**
 * @(try f x)@  is like  @(f $ x)@
 * but catches all exceptions that are thrown in @f@. To be used like
 *
 * > case try f x of
 * >    Left exception -> ...
 * >    Right result   -> ...
 *
 * Note that 'try' is strict in both its arguments. The exceptions thrown
 * when the arguments are evaluated will *not* be catched.
 */

pure native try "Prelude._dollar.w" :: (a -> b) -> a -> Exception b


/// @a `seq` b@ evaluates /a/ before it returns /b/
/// This is a right associative operator with precedence 15.
seq !a b = b;

//######### undefined things ####################
/**
 *  This is used in cases of higher order polymorphism to provide a provisonal type.
 *  For example:
 *  > f :: (forall a => [a] -> [a]) -> ([Bool],[Char])
 *  will extend java type
 *  > Fun1<Fun<Void, Void>, Tuple2<List<Bool>,List<Char>>>
 *  Whenever such a function is used, it must be coerced to the correct type.
 */
data Void = pure native Void

data Undefined = pure native frege.RT.Undefined where
    pure  native new :: String -> Undefined
    /// create an 'Undefined' value from a string and a cause
    pure  native newSX new :: String -> JException -> Undefined
    /** create an 'Undefined' value from a 'JException'. The message
     *  will be taken from the exception.
     */
    newX :: JException -> Undefined
    newX jex = newSX ("caused by " ++ jex.getClass.getName ++ ": " ++ jex.getMessage) jex
    /// Throw this 'Undefined', this will abort the computation evaluating it.
    /// Actually, the return type is not correct, since it never returns.
    pure native die  :: Undefined -> Bool

    /**
     * convert an 'Undefined' value to a 'JException'
     *
     * This is actually a no-op, since @frege.RT.Undefined@ is a subclass
     * of @java.lang.Exception@. However, the type checker knows nothing about subclasses.
     *
     * This function is used in the @Monad (Exception a)@.
     */
    pure native toException "(java.lang.Exception)" :: Undefined -> JException


/// This is the standard undefined value.
undefined :: u
undefined = error "undefined"
/// Construct an undefined value with an informative message.
error :: String -> u
error s   = if (Undefined.new s).die then undefined else undefined
/// Constructs an undefined value from a java exception and throws it.
throw u   = if (Undefined.newX u).die then undefined else undefined


/// Get the head element of a non empty list. The head of an empty list is 'undefined'.
head (x:xs) = x
head [] = error "List.head []"


//######### boolean expr ########################
/// The Java @!@ operator on booleans
pure  native ! :: Bool -> Bool      //  = if b then false else true;
/** The Java @&&@ operator on booleans. Note that since this is a
    native function, the second argument appears strict to the frege compiler
    when in fact it is lazy at the Java level.
    This can lead to inconsistent results in some cases. For example, the following
    program correctly prints @false@ in the first line of the output, but then aborts:
    > main _ = do
    >    stdout << (false && undefined) << "\n"
    >    stdout << conj false undefined << "\n"
    >  where
    >    conj a b = a && b

    Note that the very same behaviour is seen in the following java program

    > public class And {
    >    static boolean undef() {
    >        if (true) throw new Error("undefined");
    >        return false;
    >    }
    >    static boolean conj(boolean a, boolean b) { return a&&b; }
    >    public static void main(String[] args) {
    >        System.out.println(false && undef());
    >        System.out.println(conj(false, undef()));
    >    }
    > }

    One could thus say that '&&' behaves exactly like the Java operator including
    the fact that it cannot be replaced by a function without changing the semantics
    of a program.

    For an alternative see 'and'
*/
pure  native && :: Bool -> Bool -> Bool

/// The Java @||@ operator, see notes to '&&' and 'or' for an alternative
pure native || :: Bool -> Bool -> Bool

/** Like '&&', but second argument is lazy.
    The @`and`@ operator has the same precedence and arity as '&&'.
    The definition is
    > a `and` b = if a then b     else false
    */
a `and` b = if a then b     else false

/** Like '||', but second argument is lazy.
    The @`or`@ operator has the same precedence and arity as '||'.
    The definition is
    > a `or`  b = if a then true  else b
    */
a `or`  b = if a then true  else b

/**
 * @not b@ is true if /b/ is false, otherwise true. Uses java's '!' operator
 */
pure  native not "!" :: Bool -> Bool

/**
 * @a `xor` b@ is true if either /a/ or /b/ is true, but not both
 * > a `xor` b = if a then not b else b
 */
a `xor` b = if a then not b else b

//######### expr identity ######################
/** This checks for object identity or equality of primitive values
    using Java's @==@ operator.
    It evaluates its arguments, so undefined values cannot be compared. */
pure  native === == :: a -> a -> Bool;
/** This checks for object identity or inequality of primitive values
    using Java's @!=@ operator.
    It evaluates its arguments, so undefined values cannot be compared. */
pure  native !== != :: a -> a -> Bool;


//########### class Ord - compare ordered things ##################
/// The type of the result of '<=>'
data Ordering = Lt | Eq | Gt

/**
  The 'Ord' class provides relational operators as well as the functions 'max' and 'min'.
  The default implementation defines them all in terms of the /compare/ operator '<=>'.

  Making some type an instance of 'Ord' makes it automatically an instance of 'Eq' if it
  is not one already. The operators '==' and '!=' will be defined in terms of '<=>' too.

  Instances of 'Ord' can be derived automatically for algebraic data types when
  all elements of the type are themselves instances of 'Ord'.
 */
class Ord Eq ord => ord where
    /** This operator must be defined in all instances. It compares its operands and
        returns 'Lt' if the first is lower than the second, 'Gt' if the first is
        greater than the second and 'Ordering.Eq' otherwise.

        The following shall be invariantly true:
        > case a <=> b of { Eq -> a == b; _ -> a != b }

        */
    (<=>) :: ord -> ord -> Ordering      // must be defined

    /** Relational @<@ operator. Obeys the following laws:
        > if a < b && b < c then a < c
        > a < b == b > a
        */
    (<)   :: ord -> ord -> Bool
    /** Relational @<=@ operator. Obeys the following laws:
        > if a <= b && b <= c then a <= c
        > a <= b == b >= a
        > a <= b == !(a > b)
        */
    (<=)  :: ord -> ord -> Bool
    /** Relational @>@ operator. Obeys the following laws:
        > if a > b && b > c then a > c
        > a > b == b < a
        */
    (>)   :: ord -> ord -> Bool
    /** Relational @>=@ operator. Obeys the following laws:
        > if a >= b && b >= c then a >= c
        > a >= b == b <= a
        > a >= b == !(a < b)
        */
    (>=)  :: ord -> ord -> Bool
    /// > max a b = if a > b then a else b
    max   :: ord -> ord -> ord
    /// > min a b = if a < b then a else b
    min   :: ord -> ord -> ord
    (a) < (b)   = case a <=> b of { Lt -> true;   _ -> false; }
    (a) <= (b)  = case a <=> b of { Gt -> false;  _ -> true;  }
    (a) >= (b)  = case a <=> b of { Lt -> false;  _ -> true;  }
    (a) > (b)   = case a <=> b of { Gt -> true;   _ -> false; }
    max a b = if a > b then a else b
    min a b = if a < b then a else b
    /** This implementation for the ('==') operator is being used in instances
        of 'Ord' when the instantiated type is not already an instance of 'Eq'.
    */
    (a) == (b)  = case a <=> b of { Eq -> true;   _ -> false; }
    /** This implementation for the ('!=') operator is being used in instances
        of 'Ord' when the instantiated type is not already an instance of 'Eq'.
    */
    (a) != (b)  = case a <=> b of { Eq -> false;  _ -> true;  }

//############# class Enum ############################################
/**
 * Class 'Enum' defines operations on sequentially ordered types.
 *
 * A type that is an instance of 'Enum' is also an instance
 * of 'Ord' (and, in turn, of 'Eq').
 *
 * Instances of 'Enum' may be derived for any enumeration type
 *(types whose constructors have no fields).
 */
class Enum Ord e => e where
    /** @ord e@ returns the ordinal number associated with the value @e@. For
     * enumeration types, 'ord' is the same as 'constructor', for 'Int', it is the
     * identity function.
     * Some types, like 'Long', cannot map all their values to 'Int', in such cases
     * the result of applying 'ord' may be meaningless.
     */
    ord :: e -> Int
    /**
     * This is the default implementation of the compare operator,
     * that makes each 'Enum' type an 'Ord' type automatically.
     * > a <=> b  =  ord a  Int.<=>  ord b
     */
    a <=> b = ord a Ord.<=> ord b
    /**
     * @T.from i@ maps the 'Int' value @i@ to a value of @T@, such that
     >   ord (T.from i) == i
     * unless there is no value @e@ of @T@ so that @ord e == i@. In the
     * latter case, the result is 'undefined'.
     */
    from :: Int -> e
    /// @succ e@ is the successor of @e@ or 'undefined' if there is no such successor.
    succ :: e -> e
    /// @pred e@ is the predecessor of @e@ or 'undefined' if there is no predecessor.
    pred :: e -> e
    // pred x = from (ord x - 1)
    // succ x = from (ord x + 1)
    /** @a .. b@ is the list @[a, succ a, succ (succ a), ..., b ]@
     * if @a < b@, or [a] if @a == b@ or the empty list if @a > b@.
     */
    (..) :: e -> e -> [e]
    (a) .. (b)
        | a < b     = a:(succ a..b)
        | a == b    = [a]
        | otherwise = []

instance Eq () where {
    () != () = false;
    () == () = true;
};

derive Ord ()
derive Eq Ordering
derive Ord Ordering

//########### class Num - basic arithmetics ########################
/** The 'Num' class provides the operators ('+'), ('-') and ('*') as well as
    some functions that are common for all numeric types.
    */
class Num Ord n => n where
    /// Computes the sum of two numbers
    (+) :: n -> n -> n
    /// Computes the difference of two numbers
    (-) :: n -> n -> n
    /// Computes the product of two numbers
    (*) :: n -> n -> n
    /// Computes the absolute value
    abs :: n -> n
    /// Negates a number n such that if n is a number
    /// > n + negate n == 0
    negate :: n -> n
    /// @sign n@ is -1 if n<0, 1 if n>0 and 0 otherwise
    sign :: n -> Int
    /// the number 1 in the instantiated type
    one  :: n
    /// the number 0 in the instantiated type
    zero :: n
    abs n = if n < (n-n) then (n-n) - n else n
    negate n =  (n-n)-n
    sign n = constructor (n <=> (n-n)) - 1
    /// converts an 'Int' value to the instantiated type
    fromInt :: Int -> n
    /** Floating point number types may have special values for /infinity/
        and /negative infinity/. @isFinite n@ yields @true@ if @n@ is an infinite
        value and @false@ in all other cases.

        The default implementation always returns @false@ so that implementors of
        instances for types without special values for infinity need not care.

        See also 'isNumber'.
    */
    isInfinite :: n -> Bool
    isInfinite _ = false
    /** Floating point number types may have a special values for
        /not a number/ (NaN). For example, @0d \/ 0d@ is NaN.
        @isNaN n@ yields @true@ if @n@ is the special value that indicates that
        @n@ is not a number and @false@ in all other cases.

        The default implementation always returns @false@ so that implementors of
        instances for types without such a special values need not care.

        See also 'isNumber'.
    */
    isNaN :: n -> Bool
    isNaN _ = false
    /** Returns @true@ if @n@ is neither infinite (see 'isInfinite') nor NaN (see 'isNaN').

        Note that certain properties for funtions on numbers are true only under the assumption
        that the argument values are numbers.

        The default implementation is
        > isNumber n = !(isInfinite n) && !(isNaN n)
        so that the function should always compute
        the right answer as long as 'isInfinite' and 'isNaN' do.
    */
    isNumber :: n -> Bool
    isNumber n = !(isInfinite n) && !(isNaN n)


/**
 * The 'Real' class provides the division operator ('/').
 */
class Real Num r => r where
    /// the division operator
    (/) :: r -> r -> r


//########### class Show - conversion to strings ##################
/**
 * Class 'Show' provides operations to convert values to 'String's.

 * This class can be derived for all algebraic data types whose constituents
 * are themselves instances of 'Show'.
 */
class Show show where
    /// computes the string representation of a value
    show    :: show -> String
    /**
     * 'showsub' is used for 'show'ing elements of a value of an allgebraic data type
     * in derived instances of 'Show'.
     *
     * The generated code in derived instances for types that are not
     * enumerations is
     * > showsub x = "(" ++ show x ++ ")"
     * so that values are enclosed in parentheses.
     * Certain types like records, lists, tuples and many primitive types do not need
     * extra parentheses, and thus 'showsub' is the same as 'show', which is also the
     * default implementation.
     *
     * In short,
     * - in derived instances, 'showsub' will do the right thing.
     * - in all other instances, 'showsub' will do the same as 'show' if not
     *   implemented differently.
     *
     * Example:
     * > derive Show ( Maybe Show:b)
     * implements the following:
     * > show Nothing = "Nothing"
     * > show (Just x) = "Just " ++ x.showsub
     * > showsub x = "(" ++ show x ++ ")"
     * so that
     * > show (Just (Just 42)) == "Just (Just 42)"
     *
     */
    showsub :: show -> String
    /**
     * 'display' computes an alternate string represantation of a value.
     * The default implementation is to do the same as 'show'.
     * See 'Char.display' and 'String.display' for examples of different implementation.
     */
    display :: show -> String
    showsub x = show x
    display d = show d

/**
 * 'Integer' is an instance of 'Show'
 */
instance Show Integer where
    show = Integer.toString
    showsub = Integer.toString

/**
 * 'Integer' is an instance of 'Ord'
 */
instance Ord Integer where
    a <=> b = (a.compareTo b).<=> 0
    a >   b = (a.compareTo b).>   0
    a <   b = (a.compareTo b).<   0
    a >=  b = (a.compareTo b).>=  0
    a <=  b = (a.compareTo b).<=  0
    a ==  b = (a.compareTo b).==  0
    a !=  b = (a.compareTo b).!=  0

/**
 * 'Integer' is an instance of 'Enum'
 */
instance Enum Integer where
    /// @succ b@  is the same as @b + 1.big@
    succ b = b + Integer.one
    /// @succ b@  is the same as @b + 1.big@
    pred b = b - Integer.one
    /// @ord b@ is only defined if the value of b is in the range 'Int.minBound' .. 'Int.maxBound'
    ord b  = b.int
    /// @Integer.from i@ is the same as @Int.big i@
    from i = i.big
;
/**
 * 'Integer' is an instance of 'Integral'
 */
instance Integral Integer where
    fromInt i = big i

/// Class 'Integral' provides bit arithmetic, division and remainder operations for integral numbers.
class Integral Num integ => integ where
    /// integer division
    div :: integ -> integ -> integ
    /// The remainder á la Java operator @%@ - @a `rem` b@ has same sign as @a@
    /// Property: @(a `div` b) * b + (a `rem` b) = a@
    rem :: integ -> integ -> integ
    mod :: integ -> integ -> integ
    /// This modulo operator works like @java.math.BigInteger.mod@
    /// > (-5) `mod` 3 == 1
    a `mod` b  = case a `rem` b of
                    arb -> if arb < a-a then abs b + arb else arb
                 // if a `rem` b < a.zero then abs b + a `rem` b else a `rem` b
                 ;
    band :: integ -> integ -> integ
    bxor :: integ -> integ -> integ
    bor  :: integ -> integ -> integ
    bshl :: integ -> Int -> integ
    bshr :: integ -> Int -> integ


instance Show JException where
    /** creates a string representation of a Java exception, consisting of
       the class name and the message, like
       > "java.lang.ArithmeticException: division by zero"
    */
    show jx = jx.catched ++ ": " ++ jx.getMessage


//############ Int instances & functions ############################

instance Eq Int where
    /// Uses the java @==@ operator for comparision of 'Int' values.
    pure native ==     :: Int -> Int -> Bool
    /// Uses the java @!=@ operator for comparision of 'Int' values.
    pure native !=     :: Int -> Int -> Bool


instance Ord Int where
    /// Uses the java @<=@ operator for comparision of 'Int' values.
    pure native <=     :: Int -> Int -> Bool
    /// Uses the java @>=@ operator for comparision of 'Int' values.
    pure native >=     :: Int -> Int -> Bool
    /// Uses the java @<@ operator for comparision of 'Int' values.
    pure native <      :: Int -> Int -> Bool
    /// Uses the java @>@ operator for comparision of 'Int' values.
    pure native >      :: Int -> Int -> Bool
    (<=>) :: Int -> Int -> Ordering
    (a) <=> (b) = if a<b then Lt else if a>b then Gt else Eq


instance Num Int where
    /// Uses the java @+@ operator to add 2 'Int' values.
    pure native +  :: Int -> Int -> Int
    /// Uses the java @\*@ operator to multiply 2 'Int' values.
    pure native *  :: Int -> Int -> Int
    /// Uses the java @-@ operator to subtract one 'Int' value from another.
    pure native -  :: Int -> Int -> Int
    /// the integer constant 0
    zero = 0
    /// the integer constant 1
    one = 1
    /** Returns the negated argument if it is negative, otherwise the argument itself.

        This does not work for 'Int.minBound' since there is no corresponding positive
        value that can be represented as an 'Int'. Rather
        > abs Int.minBound == Int.minBound
    */
    abs i = if i < 0 then  negate i else i
    /** @negate i@ computes @0-i@ using the java negation operator @-@.

        This does not work for 'Int.minBound' since there is no corresponding positive
        value that can be represented as an 'Int'. Rather
        > negate Int.minBound == Int.minBound
    */
    pure native negate - :: Int -> Int
    /// For 'Int' values, this is the identity function.
    fromInt i = i


instance Eq Long where
    /// Uses the java @==@ operator for comparision of 'Long' values.
    pure native ==     :: Long -> Long -> Bool
    /// Uses the java @!=@ operator for comparision of 'Long' values.
    pure native !=     :: Long -> Long -> Bool


instance Ord Long where
    /// Uses the java @<=@ operator for comparision of 'Long' values.
    pure native <=     :: Long -> Long -> Bool
    /// Uses the java @>=@ operator for comparision of 'Long' values.
    pure native >=     :: Long -> Long -> Bool
    /// Uses the java @<@ operator for comparision of 'Long' values.
    pure native <      :: Long -> Long -> Bool
    /// Uses the java @>@ operator for comparision of 'Long' values.
    pure native >      :: Long -> Long -> Bool
    (<=>) :: Long -> Long -> Ordering
    (a) <=> (b) = if a<b then Lt else if a>b then Gt else Eq


instance Num Long where
    /// Uses the java @+@ operator to add two 'Long' values.
    pure native +  :: Long -> Long -> Long
    /// Uses the java @\*@ operator to multiply two 'Long' values.
    pure native *  :: Long -> Long -> Long
    /// Uses the java @-@ operator to subtract a 'Long' value from another.
    pure native -  :: Long -> Long -> Long
    /// The constant @0L@.
    zero = 0L
    /// The constant @1L@.
    one  = 0L
    /** Returns the negated argument if it is negative, otherwise the argument itself.

        This does not work for 'Long.minBound' since there is no corresponding positive
        value that can be represented as a 'Long'. Rather
        > abs Long.minBound == Long.minBound
    */
    abs i = if i < 0L then 0L-i else i
    /** @negate a@ computes @0L-a@ using the java negation operator @-@.

        This does not work for 'Long.minBound' since there is no corresponding positive
        value that can be represented as a 'Long'. Rather
        > negate Long.minBound == Long.minBound
    */
    pure native negate - :: Long -> Long
    /// applys the widening primitive conversion (JLS §5.1.2) from @int@ to @long@
    fromInt i = i.long



instance Show Int where
    /// the 'String' representation of the 'Int' argument, uses @java.lang.String.valueOf@
    pure native show   java.lang.String.valueOf    :: Int -> String


instance Show Long where
    /// the 'String' representation of the 'Long' argument, uses @java.lang.Long.toString@
    pure native show       java.lang.Long.toString     :: Long -> String


/**
 * A class for data types that have a lower and an upper bound.
 *
 * Instances of 'Bounded' can be derived automatically for enumeration types.
 */
class Bounded b where
    /// the lower bound
    minBound :: b
    /// the upper bound
    maxBound :: b


instance Bounded Int where
    /// the smallest 'Int' value  -2147483648 (or -(2**31))
    minBound  = 0x80000000
    /// the largest 'Int' value  2147483647 (or (2**31)-1)
    maxBound  = 0x7fffffff



instance Enum Int where

    /// > ord i = i
    ord  (i::Int) = i
    /// > from i = i
    from (i::Int) = i
    /// @pred i@ is the same as @i-1@ except for @pred Int.minBound@, which is 'undefined'
    pred i
        | i > Int.minBound = i-1
        | otherwise = error "pred Int.minBound"

    /// @succ i@ is the same as @i+1@ except for @succ Int.maxBound@, which is 'undefined'
    succ i
        | i < Int.maxBound = i+1
        | otherwise = error "succ Int.maxBound"


instance Bounded Long where
    /// the smallest 'Long' value  -9223372036854775808 (or -(2**63))
    minBound  = 0x8000000000000000L
    /// the largest 'Long' value  9223372036854775807 (or (2**63)-1)
    maxBound  = 0x7fffffffffffffffL

instance Enum Long where

    /// @ord l@ is only valid if @Int.minBound.long <= l && l <= Int.maxBound@
    ord  (i::Long) = i.int;

    /// @Long.from i@ returns a 'Long' with the same numeric value as @i@.
    from (i::Int)  = i.long;

    /// @pred a@ is the same as @a-1L@ except for @pred Long.minBound@, which is 'undefined'
    pred i
        | i > Long.minBound = i-1L
        | otherwise = error "pred Long.minBound"

    /// @succ a@ is the same as @a+1L@ except for @succ Long.maxBound@, which is 'undefined'
    succ i
        | i < Long.maxBound = i+1L
        | otherwise = error "succ Long.maxBound"



instance Integral Int where
    pure native `rem` %    :: Int -> Int -> Int
    pure native `div` /    :: Int -> Int -> Int
    pure native bshl `<<`  :: Int -> Int -> Int
    pure native bshr `>>`  :: Int -> Int -> Int

instance Integral Long where
    pure native `rem` %      :: Long -> Long -> Long
    pure native `div` /      :: Long -> Long -> Long
    pure native bshl `<<`    :: Long -> Int -> Long
    pure native bshr `>>`    :: Long -> Int -> Long


//############# Bool instances ########################################


instance Ord Bool where
    false <  true   = true
    _     <  _      = false
    true  >  false  = true
    _     >  _      = false
    false <= _      = true
    true  <= b      = b
    false >= b      = !b
    true  >= _      = true
    true  <=> false = Gt
    false <=> true  = Lt
    _     <=> _     = Eq


instance Bounded Bool where
    minBound   = false
    maxBound   = true

instance Enum Bool where
    ord false = 0
    ord true  = 1
    from 0    = false
    from _    = true           // nonzero is true
    pred true = false
    pred _    = error "pred false"
    succ false = true
    succ true  = error "succ true"



instance Show Bool where
    show b = if b then "true" else "false"


//############## String instances ###############

instance Eq String where
    pure native == equals :: String -> String -> Bool
    (!=) :: String -> String -> Bool
    a != b = !(a==b)

instance Ord String where
    (<=>) :: String -> String -> Ordering
    (>)   :: String -> String -> Bool
    (<)   :: String -> String -> Bool
    (>=)  :: String -> String -> Bool
    (<=)  :: String -> String -> Bool
    a <=> b = (a.compareTo b) Int.<=> 0
    a >   b = (a.compareTo b) Int.>   0
    a <   b = (a.compareTo b) Int.<   0
    a >=  b = (a.compareTo b) Int.>=  0
    a <=  b = (a.compareTo b) Int.<=  0


instance Show String where
    pure native show frege.RT.quoteStr :: String -> String
    display s = s



//################# Char instances    #############
instance Eq  Char where
    pure native == :: Char -> Char -> Bool
    pure native != :: Char -> Char -> Bool


instance Ord Char where
    (<=>)      :: Char -> Char -> Ordering
    a <=> b = a.ord Int.<=> b.ord
    pure native <=  :: Char -> Char -> Bool
    pure native >=  :: Char -> Char -> Bool
    pure native <   :: Char -> Char -> Bool
    pure native >   :: Char -> Char -> Bool


instance Bounded Char where
    pure native minBound   java.lang.Character.MIN_VALUE :: Char
    pure native maxBound   java.lang.Character.MAX_VALUE :: Char

instance Enum Char where
    pure native from       "(char)" :: Int -> Char
    pred c = Char.from (Char.ord c - 1)
    succ c = Char.from (Char.ord c + 1)

chr i = Char.from i

pure native ctos    java.lang.Character.toString  :: Char -> String
stocs = unpacked
unpacked (s::String) = loop (length s - 1) [] where
        loop :: Int -> [Char] -> [Char]
        loop i res
            | i >= 0 = loop (i-1) (s.charAt i : res)
            | otherwise = res





instance Show Char where
    pure native show frege.RT.quoteChr :: Char -> String
    display c = ctos c


//################# Float Instances   #############

instance Show Float where
    pure native show java.lang.Float.toString :: Float -> String

instance Eq Float where
    pure native ==  :: Float -> Float -> Bool
    pure native !=  :: Float -> Float -> Bool

instance Ord Float where
    pure native <=  :: Float -> Float -> Bool
    pure native >=  :: Float -> Float -> Bool
    pure native <   :: Float -> Float -> Bool
    pure native >   :: Float -> Float -> Bool
    (<=>)  :: Float -> Float -> Ordering
    a <=> b = if a<b then Lt else if a>b then Gt else Eq

instance Real Float where
    pure native + :: Float -> Float -> Float
    pure native - :: Float -> Float -> Float
    pure native * :: Float -> Float -> Float
    pure native / :: Float -> Float -> Float
    zero = 0.0f
    one  = 1.0f
    pure native negate - :: Float -> Float
    fromInt i = i.float
    pure native isInfinite java.lang.Float.isInfinite :: Float -> Bool
    pure native isNaN      java.lang.Float.isNaN      :: Float -> Bool


// ################# Double Instances   #############

instance Show Double where
    pure native show java.lang.Double.toString :: Double -> String


instance Eq  Double where
    pure native ==  :: Double -> Double -> Bool
    pure native !=  :: Double -> Double -> Bool


instance Ord Double where
    pure native <=  :: Double -> Double -> Bool
    pure native >=  :: Double -> Double -> Bool
    pure native <   :: Double -> Double -> Bool
    pure native >   :: Double -> Double -> Bool
    (<=>)  :: Double -> Double -> Ordering
    a <=> b = if a<b then Lt else if a>b then Gt else Eq



instance Real Double where
    pure native + :: Double -> Double -> Double
    pure native - :: Double -> Double -> Double
    pure native * :: Double -> Double -> Double
    pure native / :: Double -> Double -> Double
    zero = 0.0
    one = 1.0
    pure native negate - :: Double -> Double
    fromInt i = i.double
    pure native isInfinite java.lang.Double.isInfinite :: Double -> Bool
    pure native isNaN      java.lang.Double.isNaN      :: Double -> Bool


// ################# Misc. types and derivations #############

derive Show ()

derive Show Ordering

instance Eq Eq a => [a] where
    /// two lists are equal if their heads and tails are equal or if the lists are empty
    (a:as) == (b:bs) = if a.== b then as == bs else false
    []     == []     = true
    _      == _      = false


derive Ord Ord a => [a]

data Maybe a = Nothing | Just a

derive Eq   Maybe a
derive Ord  Maybe a
derive Show Maybe a



isJust (Just _) = true
isJust Nothing  = false
isNothing Nothing = true
isNothing (Just _) = false
maybe d f (Just x) = f x
maybe d f Nothing = d

/// @fromMaybe d (Just a)@ returns @a@ and @fromMaybe d (Just a)@ returns @d@
fromMaybe d Nothing  = d
fromMaybe d (Just a) = a

/// @unJust Nothing@ is 'undefined' whereas @unJust (Just a)@ is @a@
unJust (Just a) = a
unJust Nothing  = error "unJust Nothing"
fromJust = unJust   // make Haskell folks happy


data Either a b = Left a | Right b
derive Eq   Either a b
derive Ord  Either a b
derive Show Either a b

either left right (Left x)  = left x
either left right (Right x) = right x




// Arrays
type Array elem = Frozen (STArray elem)
instance Cloneable (STArray elem) where
    native our frege.RT.our :: STArray elem s -> ST s (Array elem)

data STArray elem s = native "frege.rt.Array" where
    native      new                           :: Int -> Mutable (STArray elem) s
    pure native length                        :: Array elem -> Int
    native      setAt                         :: STArray elem s -> Int -> elem -> ST s ()
    // pure native updAt    frege.RT.Arr.vaupd   :: Array a -> Int -> a -> Array a
    /// set array element to value v (Just v) or null (Nothing)
    native      setAtMB  setAt                :: STArray elem s -> Int -> Maybe elem -> ST s ()
    // update array element to value v (Just v) or null (Nothing)
    // pure native updAtMB  frege.RT.Arr.vaupd   :: Array a -> Int -> Maybe a -> Array a
    /// Fetch array element and return @Just v@, if it is not a null value, otherwise @Nothing@
    native      getAt                         :: STArray elem s -> Int -> ST s (Maybe elem)
    /// Fetch array element form a frozen array
    pure native frozenGetAt getAt             :: Array elem -> Int -> Maybe elem
    /// Fetch array element from a frozen array *without* checking for @null@ value.
    pure native elemAt      getAt             :: Array elem -> Int -> elem

    /// Create array from (finite) list.
    /// The resulting Array does not contain null values
    fromListST :: [elem] -> ST u (STArray elem u)
    fromListST elems = (Array.new elems.length >>= loop 0 elems) where
        loop j (x:xs) arr = do Array.setAt arr j x; loop (j+1) xs arr
        loop j []     arr = return arr
    /// create an immutable arra from a list
    fromList elems = ST.run (fromListST elems >>= our)

    /// Collect non-null elements from an immutable array.
    toList a = elems a 0 // [ e | Just e  <- [ a.[i] | i <- 0..a.length-1 ]];
        where
            elems a i
                | i < Array.length a = case Array.frozenGetAt a i of
                    Just s  -> s:elems a (i+1)
                    Nothing -> elems a (i+1)
                | otherwise = []

    /**
     * Extract all non null elements from an immutable array, togehther with
     * their indexes.
     * For arrays whose last element is not null, the following holds:
     > fromInxList (toInxList arr) == arr
     */
    toInxList :: Array a -> [(Int, a)]
    toInxList arr = [ (i,x) | (i, Just x) <- [ (i, arr.frozenGetAt i) | i <- 0..arr.length-1]]
    /**
      * Create a mutable array from a list of tuples ('Int', a).
      * The size of the array will be so that it can accomodate the
      * greatest index. Elements whose index does not appear in the list
      * reamin unset, i.e. they are initialised with the null value.
      *
      * Negative indexes cause java exceptions to be thrown.
      */
    fromInxListST :: [(Int, a)] -> ST s (STArray a s)
    fromInxListST xs = Array.new n >>= loop xs where
        n = 1 + fold max 0 (map fst xs)
        loop :: [(Int, a)] -> STArray a s -> ST s (STArray a s)
        loop ((i,x):xs) arr = do
            arr.[i <- x]
            loop xs arr
        loop [] arr = return arr
    /// create immutable array using frozen result of 'Array.fromInxListST'
    fromInxList xs = ST.run (fromInxListST xs >>= our)



type StringArr = Frozen StringArray
instance Cloneable StringArray where
    native our frege.RT.our :: StringArray s -> ST s (Frozen StringArray)

/// native array of native strings
data StringArray s = native "java.lang.String[]" where
    /// make a new mutable string array
    native new    "java.lang.String[]"
                                                :: Int -> Mutable StringArray s
    native getAt  "frege.rt.Boxed.<java.lang.String>arrayGet"
                                                :: StringArray s -> Int -> ST s (Maybe String)
    native setAt  "frege.rt.Boxed.<java.lang.String>arraySet"
                                                :: StringArray s -> Int -> String -> ST s ()
    pure native frozenGetAt "frege.rt.Boxed.<java.lang.String>arrayGet"
                                                :: StringArr -> Int -> Maybe String
    /// use this only if it is absolutely sure that there are no nulls in the array
    pure native elemAt "frege.rt.Boxed.<java.lang.String>arrayGet"
                                                :: StringArr -> Int -> String
    /// the length of the array
    pure native length "frege.rt.Boxed.<java.lang.String>arrayLen"
                                                :: StringArr -> Int
    toList (a::StringArr) = elems a 0
        where
            elems (a::StringArr) i
                | i < a.length = case frozenGetAt a i of
                    Just s  -> s:elems a (i+1)
                    Nothing -> elems a (i+1)
                | otherwise = []

    fromListST :: [String] -> ST u StringArr
    fromListST strings = (StringArr.new strings.length >>= loop 0 strings) >>= our where
        loop j (x:xs) arr = do StringArr.setAt arr j x; loop (j+1) xs arr
        loop j []     arr = return arr
    fromList strings = ST.run (fromListST strings)


type IntArr = Frozen IntArray
instance Cloneable IntArray where
    native our frege.RT.our :: IntArray s -> ST s (Frozen IntArray)

/// native array of primitive int
data IntArray s = native "int[]" where
    /// make a new mutable array of given size
    native      new    frege.rt.Boxed.Int.arrayNew :: Int -> Mutable IntArray s
    /// get element at index from an immutable array
    pure native elemAt frege.rt.Boxed.Int.arrayGet :: IntArr     -> Int -> Int
    /// get element at index from an immutable array
    pure native frozenGetAt frege.rt.Boxed.Int.arrayGet :: IntArr     -> Int -> Int
    /// get element at index from a mutable array
    native      getAt  frege.rt.Boxed.Int.arrayGet :: IntArray s -> Int -> ST s Int
    /// set element at index
    native      setAt  frege.rt.Boxed.Int.arraySet :: IntArray s -> Int -> Int -> ST s ()
    /// get the length of the array
    pure native length frege.rt.Boxed.Int.arrayLen :: IntArr -> Int

    /// create an immutable int array from a list
    fromList is   = ST.run (fromListST is >>= our)
    /// create a mutable int array from a list
    fromListST is = IntArr.new is.length >>= loop 0 is
        where
            loop :: Int -> [Int] -> IntArray s -> ST s (IntArray s)
            loop j (x:xs) iarr = do
                iarr.[j <- x]
                loop (j+1) xs iarr
            loop _ [] iarr = return iarr

    /// convert immutable array to list
    toList (arr::IntArr) = [ elemAt arr i | i <- 0 .. (arr.length-1) ]

    /** Create an immutable int array from list of tuples.
     *
     *  The first component of each tuple gives the index, the second one
     *  is the value. Array elements not mentioned in the list will be 0.
     *
     *  > toList (IntArr.fromList [(7,42)]) == [0,0,0,0,0,0,0,42]
     */
    fromInxList xs   = ST.run (fromInxListST xs >>= our)
    fromInxListST xs = IntArr.new n >>= loop xs
        where
            n = 1 + fold max 0 (map fst xs)
            loop ((i,x):xs) arr = do
                    IntArr.setAt arr i x
                    loop xs arr
            loop [] arr = return arr

/**
 * > string =~ regex
 * tries to match /string/ against /regex/ and returns
 * @Just matcher@ if it succeeds, @Nothing@ otherwise.
 */
(s) =~ (p::Regex) = (p.matcher s).find

/**
 * >string ~ regex
 * @true@ if /string/ matches /regex/, @false@ otherwise
 */
(s) ~ (p::Regex) = isJust ((p.matcher s).find)

/**
 * > s !~ p == !(s ~ p)
 */
(s) !~ (p) = !(s ~ p)

/**
 * > ("string" ~~ #r??#) == Just "rin"
 * Tries a match and returns @Just x@ where
 * /x/ is the matched substring or @Nothing@ if there was no match.
 *
 */
s ~~ r =
    case s =~ r of
        Just m -> m.group 0
        Nothing -> Nothing


/**
 * > string ~~~ regex
 * Matches /string/ with /regex/ and returns a function
 * that can be used to extract the matched part of the string and the
 * captured substrings.
 * >   let f = "frege" ~~~ #(..).(..)#
 * >   in [ f i | i <- 0..3 ]
 * yields
 * >[Just "frege", Just "fr", Just "ge", Nothing]
 */
s ~~~ r =
    case s =~ r of
        Just m  -> m.group
        Nothing -> const Nothing

/**
 * @m ?~ p@ binds pattern /p/ to the matcher /m/
 * and tries a match. There must have been a successful
 * match on /m/ before.

 * Returns 'Nothing' if match fails, else ('Just' @m@).

 * This function is most usefull in conjunction with patterns that
 * use the G-anchor when one wants to extract
 * multiple differnt adjacent items from a string.
 * This is how the frege scanner is implemented.
 */
(m::Matcher) ?~ (p) =  m.usePatternAndFind p

/**
 * > m /~ p
 * is like
 * > m ?~ p
 * but instead of the
 * matcher it returns the matched string, if any.
 */
(m) /~ (p) = case m ?~ p of
        Just m  -> Matcher.group m 0
        Nothing -> Nothing



/// return the first element of a 2-tuple
fst (a, _) = a
/// return the second element of a 2-tuple
snd (_, a) = a

derive Eq   (a,b)
derive Ord  (a,b)
derive Show (a,b)

derive Eq    (a,b,c)
derive Ord   (a,b,c)
derive Show  (a,b,c)

/* more tuple stuff in Tuples.fr */

// function stuff
/**
    Function composition.

    @(f <~ g)@ is a function whose argument is
    passed to /g/, and the result to /f/, yielding the overall result.

    One can imagine that the data flow from right to left through a function pipe.

    > (a) <~ (b)  = \x -> a (b x)
 */
(a) <~ (b)  = \x -> a (b x)

/**
    Function composition.

    @(f ~> g)@ is a function whose argument is first
    passed to /f/, and the result to /g/, yielding the overall result.

    One can imagine that the data flows from left to right through a function pipe.

    > (a) ~> (b)  = \x -> b (a x)
 */
(a) ~> (b)  = \x -> b (a x)

/**
    @a $ b@ is the same as @a b@, but because of '$''s low precedence
    one can write @f $ x+y@ instead of @f (x+y)@. Also, becuase '$' is right
    associative, @f $ g $ h y@ is @f (g (h y))@
*/
(a) $ (b) = a b;
/// Same as `$` but argument is strict
a $! !b = a b;
/// The identity function
id x = x;
/// @const a@ is a function that returns /a/ regardless of its argument.
const a _ = a;
/// Exchange first and second argument of a function, i.e.
/// > flip f a b = f b a
flip f a b = f b a
/// Passes the elements of a 2-tuple as arguments to a function.
curry f (a,b) = f a b;
/// @uncurry f@ passes the next two arguments as 2-tuple to /f/
uncurry f a b = f (a,b);

/// Another operator for function composition, which is identical to '<~'
/// Character can be created by holding ALT and typing 0149 on the numeric keypad.
/// > (f • g) a = f (g a)
(•) = \f\g\a -> f (g a);

/// In patterns, the \@-operator is used to bind a name to a complex pattern
/// > f (x@a:as) = e
/// is the same as
/// > f arg = case arg of { x -> case x of { a:as -> e }}
(@) = (•)


// ####################################################################
// ###################### list functions ##########################••••####
// ####################################################################
/**
    @map f xs@ applies /f/ to each element of /xs/ and builds a new list from the results.

    Usage of 'map' is safe on infinite lists, it delivers the result list one by
    one as it is demanded.
*/
map f (x:xs) = (f x):map f xs
map f [] = []

/**
    @filter p xs@ returns the list of elements /x/ from /xs/ where (/p/ /x/) holds.

    'filter' will not stop to evaluate its argument list until the first
    element with the property asked for is found. For example

    > filter (==true) (repeat false)

    will loop forever, whereas

    > filter iseven (iterate succ 1n) where iseven n = n `band` 1n == 0n

    will faithfully deliver the list of positive integers that are divisible by 2,
    one by one.

*/

filter p (x:xs) = if p x then x:filter p xs else filter p xs
filter p []     = []

/**
 * 'concat' concatenates the sublists of the argument which is a list of list.
 * It is ok if the argument is an infinite list or any of the sublists is infinite.
 * In either case, the result will also be infinite.
 *
 */
concat xss = foldr (++) [] xss

/// Returns the last element of a list by taking the 'head' of the 'reverse'd list.
/// See also 'init'
last = head <~ reverse

/// Returns all but the last element from a list.
/// The following property holds for all non-empty finite lists /xs/:
/// > init xs ++ [last xs] == xs
init [x]    = []
init (x:xs) = x : init xs
init []     = error "Prelude.init: empty list"

/**
    @xs !! n@ is the element with index /n/ of the list /xs/,
    where the head element of a list has index 0.
*/
(x:_)  !! 0         = x
(_:xs) !! n | n > 0 = xs !! (n-1)
(_:_)  !! n         = error ("Prelude.!!: negative index (" ++ show n ++ ")")
[]     !! n         = error ("[] Prelude.!! " ++ show n)

//* This is how our 'fold' is called in Haskell land.
foldl = fold

/**
 * 'fold', applied to a binary operator, a starting value (typically the
 * left identity of the operator), and a list, reduces the list using
 * the binary operator, from left to right:
 * > fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn
 * 'fold' runs in constant stack space, but consumes the entire list before
 * returning a result, so it must not be applied to infinite lists.
 *
 * This function is known as 'foldl' in Haskell where there is a bias in favour
 * of using 'foldr'.
 * In the environment of the JVM stack space is precious, hence one should prefer 'foldl'
 * when one has the choice.
 */
fold f !acc []     = acc
fold f !acc (x:xs) = fold f  (f acc x) xs


/**
 * 'foldl1' is a variant of 'fold' that has no starting value argument
 * and thus must be applied to nonempty lists only.
 */
foldl1 f (x:xs) = fold f x xs
foldl1 f _      = error "Prelude.foldl1 f []"

/**
 * 'scanl' is similar to 'fold' but returns a list of successive
 * reduced values from the left:
 * > scanl f z [x1, x2, ...] = [z, z `f` x1, (z `f` x1) `f` x2, ... ]
 * The follwoing property holds for all finite lists /xs/:
 * > last (scanl f z xs) == fold f z xs
 * In contrast to 'fold', 'scanl' can operate on infinite lists.
 */
scanl f !q (x:xs) = q : scanl f (f q x) xs
scanl f !z []     = [z]

/**
 * 'scanl1' is similar to 'scanl', but takes the 'head' of the list as
 * starting element and is thus only applicable to non-empty lists.
 * > scanl1 f [x1, x2, ...] = [x1, x1 `f` x2, (x1 `f` x2) `f` ...]
 */
scanl1 f (x:xs) = scanl f x xs
scanl1 f _      = error "Prelude.scanl1 f []"

/**
 * Fold over a list from right to left.
 * > foldr f a (x1:x2:x3:[])
 * is the same as
 * > x1 `f` (x2 `f` (x3 `f` a))
 * Note that, if /f/ is strict in the second argument,
 * @foldr f@ will need stack space proportional
 * to the length of the list.
 * But if /f/ is lazy in it's second argument, 'foldr' works on infinite lists.
 *
 * If /f/ is commutative, the list finite and lazyness not an issue,
 * 'fold' may be the better choice since it runs with constant stack space.
 * Otherwise, if /f/ is not commutative, 'foldrs' will trade time and heap space for
 * stack space by 'fold'ing the 'flip'ped /f/ over the 'reverse'd list.
 */
foldr :: (e->a->a) -> a -> [e] -> a
foldr _ acc [] = acc
foldr f acc (x:xs) =  x `f` (foldr f acc xs)

/**
 * This function may be used in place of
 * > foldr f z xs
 * if /f/ is strict in its right operand and /xs/ is a finite list,
 * when 'foldr' exceeds the stack size, which is usually quite limited in
 * the JVM.
 *
 * 'foldrs' will need extra CPU cycles and maybe (temporary) heap space for
 * 'reverse'-ing its list argument, before 'fold'ing the 'flip'ped /f/ over it.
 *
 * If /f/ is commutative, you may simply use 'fold' instead.
 *
 * The following property holds for all finite lists /xs/:
 * > foldr f z xs == foldrs f z xs
 */
foldrs f z xs = fold (flip f) z (reverse xs)

/**
 * reverses a list
 */
reverse xs = rev xs [] where
    rev (x:xs) ys = rev xs (x:ys)
    rev []     ys = ys

/**
 * @any p xs@ tells if any element of /xs/ has property /p/.
 * This is equivalent to @fold (||) false (map p xs)@ except that
 * 'any' stops at the first element that has property /p/.
 *
 * Note that, according to the identity above,  @any p []@ is always @false@.
 */
any p (x:xs) = if p x then true else any p xs
any p [] = false

/**
 * @all p xs@ tells if all elements of /xs/ have property /p/.
 * This is equivalent to @fold (&&) true (map p xs)@ except that
 * 'all' stops at the first element that hasn't property /p/.
 *
 * Note that, according to the identity above, @all p []@ is always @true@.
 */
all p (x:xs) = if p x then all p xs else false;
all p [] = true;

/**
 * @take n xs@ returns the starting sequence of /xs/ with at most /n/ elements.
 * If /n/ is greater than the 'length' of /xs/, the result is /xs/.
 *
 * For negative /n/, the result is undefined.
 *
 * The following property holds for all lists /xs/ and non negative /n/:
 * > take n xs ++ drop n xs == xs
 */
take 0 _ = []
take _ [] = []
take n (x:xs) = x:take (n-1) xs

/**
 * @drop n xs@ returns what remains from /xs/ after the /n/ leading elements have been dropped.
 * If /n/ is greater than the 'length' of /xs/, the result is the empty list.
 *
 * For negative /n/, the result is undefined.
 *
 * The following property holds for all lists /xs/ and non negative /n/:
 * > take n xs ++ drop n xs == xs
 */
drop 0 lst = lst
drop n [] = []
drop n (x:xs) = drop (n-1) xs

/**
 * @takeWhile p xs@ takes leading elements from /xs/ while they satisfy the predicate /p/.
 *
 * Example:
 * > takeWhile (<7) [1,2,3,9,4] == [1,2,3]
 */
takeWhile p [] = []
takeWhile p (x:xs) = if p x then x:takeWhile p xs else []

/**
 * @takeUntil p xs@ is the same as @takeWhile (not \@ p) xs@
 */
takeUntil p [] = []
takeUntil p (x:xs) = if p x then [] else x:takeUntil p xs

/**
 * @dropWhile p xs@ drops leading elements from /xs/ that satisfy the predicate /p/.
 *
 * The following holds for all lists /xs/
 * > takeWhile p xs ++ dropWhile p xs == xs
 */
dropWhile p [] = [];
dropWhile p (list@(x:xs)) = if p x then dropWhile p xs else list;

/**
 * @dropUntil p xs@ is the same as @dropWhile (not • p) xs@
 *
 * Consequently, for all lists /xs/
 * > takeUntil p xs ++ dropUntil p xs == xs
 */
dropUntil p [] = [];
dropUntil p (list@(x:xs)) = if p x then list else dropUntil p xs;

/**
 * @span p xs@ returns a tuple whose first element is the longest prefix of @xs@
 * of elements that satisfy @p@ and whose second element is the remainder of the list.
 *
 * > span p xs == (takeWhile p xs, dropWhile p xs)
 */
span p xs = (takeWhile p xs, dropWhile p xs)

/**
 * @group xs@ returns a list of sub-lists made of adjacent equal elements in @xs@.
 * All sublist are not empty and theri concatenation yields again @xs@.
 */
group (x:xs) = (x:ys) : group zs where (!ys,!zs) = span (x==) xs
group [] = []

/**
 * @groupBy f xs@ groups by function @f@ instead of (==) that is used by @group@
 */
groupBy f (x:xs) = (x:ys) : groupBy f zs where (!ys,!zs) = span (x `f`) xs
groupBy f [] = []

/**
 *  @e `elem` xs@ is true if and only if at least one of the elements of /xs/ equals /e/.
 */
elem e [] = false
elem e (h:t) = if e == h then true else elem e t

/// opposite of 'elem'
notElem e es = if elem e es then false else true

/// @elemBy f@ is a more general version of 'elem' that uses /f/ instead of '=='.
/// See also: 'using'
elemBy f e []    = false
elemBy f e (h:t) = if e `f` h then true else elemBy f e t

/**
 * 'unique' removes duplicate elements from an unsorted list,
 * which may or may not be faster than using @(uniq • sort)@
 *
 * However, the follwoing holds
 * > unique xs == uniq (sort xs)
 */
unique (e:es) = if e `elem` es then unique es else e:unique es
unique [] = []

/**
 * @uniqueBy f@ is a more general form of 'unique',
 * but uses ('elemBy' @f@) instead of 'elem' to decide
 * whether equal elements are contained in the list.

 * The following holds:
 * > uniqueBy (using f) xs == uniqBy (using f) (sortBy (comparing f) xs)
 */
uniqueBy f (e:es) = if elemBy f e es then uniqueBy f es else e:uniqueBy f es
uniqueBy f []     = []

/**
 * 'uniq' removes adjacent equal elements from a list
 * > uniq [1, 2, 2, 3, 2] = [1, 2, 3, 2]
 * This is most useful on sorted lists to remove duplicates.
 * For unsorted lists use 'unique'
 */
uniq [] = []
uniq [x] = [x]
uniq (y:x:xs) = if y == x then uniq (x:xs) else y:uniq (x:xs)

/**
 * @uniqBy f@ is a variant of 'uniq' that uses /f/ instead of '=='.
 * In the result, there are no two adjacent elements /x/ and /y/ where
 * the relation @y `f` x@ holds.
 *
 * This is most useful on sorted lists with projection functions that
 * compare parts of the value for equality. See also 'using'.
 *
 * > uniqBy (\a\b -> fst a == fst b) [(1, 1), (2, 2), (2, 3), (3,4), (2,5)]
 * >   == [(1, 1), (2, 3), (3, 4), (2, 5)]
 *
 * The example shows that, if one of two adjacent elements is removed,
 * it will be the one occuring first.
 */
uniqBy f [] = []
uniqBy f (x@[_]) = x
uniqBy f (y:x:xs) = if y `f` x then uniqBy f (x:xs) else y:uniqBy f (x:xs)

/**
 * @using f@ applies a projection function /f/ on both sides of '=='.
 * The example for 'uniqBy' could be written easier
 * > uniqBy (using fst) [(1, 1), (2, 2), (2, 3), (3,4), (2,5)]
 */
using f a b      =  f a == f b

/**
 * @comparing f@ applies a proejction function on both sides of '<='.
 * Example usage:
 * > sortBy (comparing snd) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
 */
comparing f a b  =  f a <= f b

//* this is just an alias for 'comparing'
ascending = comparing

/**
 * @descending f@ applies a proejction function on both sides of '>='.
 * Example usage:
 * > sortBy (descending fst) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
 */
descending f a b =  f a >= f b

/**
 * @partition p xs@ splits /xs/ in 2 lists and returns them as a tuple @(xs1, xs2)@,
 * such that  /xs1/
 * contains all elements of /xs/ that satisfy predicate /p/ and /xs2/ contains
 * those that do not.
 *
 * The order of the elements of /xs/ is not preserved in the results.
 *
 * The follwoing is true for all finite lists xs
 * > let ps = partition p xs
 * > in    all p (fst ps)
 * >    && (not @ any p) (snd ps)
 * >    && length (fst ps) + length (snd ps) == length xs
 * >    && all (`elem` xs) (fst ps)
 * >    && all (`elem` xs) (snd ps)
 * >    && all (\x -> x `elem` fst ps || x `elem` snd ps) xs
 */
partition p lst = loop lst [] [] where
    loop (x:xs) as bs
        | p x         = loop xs (x:as) bs
        | otherwise   = loop xs as (x:bs)
    loop []     as bs = (as,bs)

/**
 * @intersperse a xs@ inserts /a/ between every two elements of /xs/
 * > intersperse 0 (1..3) == [1,0,2,0,3]
 */
intersperse a []       = []
intersperse a [x]      = [x]
intersperse a (x:ys)   = x:a:intersperse a ys

/**
 * @repeat a@ builds an infinite list where all elements are /a/.
 */
repeat a = a:repeat a

/**
 * @iterate f a@ builds the infinite list @[a, f a, f (f a), ...]@
 */
iterate f a = a:iterate f (f a)

/**
 * @cycle xs@ builds an list that is an infinite repetition of /xs/, which must not be empty.
 */
cycle [] = error "Prelude.cycle []"
cycle xs = xs ++ cycle xs

/**
 * convert a list of characters to a string
 * > cstos ['a', 'b', 'c' ] == "abc"
 * Not very efficient, may be replaced by a java function that does it with a
 * string buffer later.
 */
cstos [] = "";
cstos cs = fold (++) "" (map ctos cs);

/**
 * @zip as bs@ builds a list of tuples of corresponding elements of /as/ and /bs/.
 * Trailing elements of the longer list are ignored.
 * > zip (1,2,3) ("a", "b") = [(1, "a"), (2, "b")]
 */
zip [] _  = [];
zip (x:xs) (y:ys) = (x,y):zip xs ys;
zip (_:_)  [] = [];

/**
 * 'unzip' turns a list of tuples into a tuple of lists.
 * It is the opposite of 'zip' and the follwoing holds
 * > (curry zip @ unzip) xs == xs
 * But not that
 * > (unzip @ curry zip) (as, bs) == (as,bs)
 * will only hold if @length as == length bs@
 */
unzip [] = ([], []);
unzip ((a,b):rest) = (a:as, b:bs)
	where {
		(as, bs) = unzip rest;
	};

/**
 * @zipWith f xs ys@ zips two lists with function /f/ instead of the standard '(,)' that
 * is used by 'zip'
 */

zipWith _ [] _ = []
zipWith _ _ [] = []
zipWith f (x:xs) (y:ys) = f x y:zipWith f xs ys

/**
 * @sortBy f xs@ is a stable sort (merge sort), it uses /f/ to decide the order of elements.
 * If @a `f` b@ is true, then /a/ comes before /b/, otherwise /b/ comes before /a/.
 *
 * see also 'comparing',  'descending'
 */
sortBy _ []  = [];
sortBy _ [x] = [x];
sortBy by xs = merge (sortBy by l1) (sortBy by l2)
    where
        (l1,l2) = splitted xs
        merge [] x = x
        merge x [] = x
        merge (a:as) (b:bs)
             | a `by` b   = a : merge as (b:bs)
             | otherwise  = b : merge (a:as) bs
        splitted [] = ([],[])
        splitted xs = (take n2 xs, drop n2 xs) where n2 = length xs `div` 2


/// Standard sort uses operator '<=' and demands that the type of the list elements is an instance of 'Ord'
sort = sortBy (<=);

// ####################################################################
// ###################### monad stuff #################################
// ####################################################################

class Functor f where
    fmap :: (a -> b) -> f a -> f b


class Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    return :: a -> m a
    (>>)  :: m a -> m b -> m b
    ma >> mb = ma >>= const mb
    fail   :: String -> m a
    fail s = error s


/**
 *  Turn a list of monadic values @[m a]@ into a monadic value with a list @m [a]@
 *
 *  sequence [Just 1, Just 3, Just 2] = Just [1,2,3]
 *  This version of 'sequence' runs in constant stack space,
 *  but needs heap space proportional to the size of the input list.
 */

sequence :: Monad m => [m a] -> m [a]
sequence xs = loop xs []                                        // foldr mcons (ret []) xs
        where                                                   //   mcons p q = p >>= (\x -> q >>= (\y -> ret (x:y)))
            loop [] acc     = return (reverse acc)
            loop (m:ms) acc = do a <- m; loop ms (a:acc)


/// @mapM f@ is equivalent to @sequence • map f@
mapM :: Monad m => (a -> m b) -> [a] -> m [b]
mapM f xs = (sequence • map f) xs

/// @foldM f a xs@ folds a monadic function @f@ over the list @xs@.
foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
foldM f a bs = fm f bs a
    where
        fm f (b:bs) a = a `f` b >>= fm f bs
        fm f []     a = return a

/// @foldM_@ is the same as 'foldM', but discards the result
foldM_ f a bs = foldM f a bs >> return ()

/** foldr ('>>') over a list of monadic values for side effects */
sequence_ xs = loop xs
    where
        loop (m:ms) = do _ <- m; loop ms
        loop []     = return ()             // foldr (>>) (return ()) xs


liftM :: Monad m => (a -> b) -> m a -> m b
liftM  f ma          = ma >>= (\a -> return (f a))
liftM2 f ma mb       = ma >>= (\a -> mb >>= (\b -> return (f a b)))
liftM3 f ma mb mc    = ma >>= (\a -> mb >>= (\b -> mc >>= (\c -> return (f a b c))))
liftM4 f ma mb mc md = ma >>= (\a -> mb >>= (\b -> mc >>= (\c -> md >>= (\d -> return (f a b c d )))))


instance Monad Maybe where
    return a = Just a
    Nothing >>= _ = Nothing
    Just a  >>= k = k a
    fail  = const Nothing

instance Functor Maybe where
    fmap f Nothing  = Nothing
    fmap f (Just x) = Just (f x)

instance Monad (Either a) where
    return a = Right a
    Left x >>= _ = Left x
    Right x >>= k = k x

instance Functor (Either a) where
    fmap f (Left e)   = Left e
    fmap f (Right v)  = Right (f v)


/**
 * @(ST s a)@ is an abstract data type and is
 * a computation that encapsulates side effects in state thread @s@
 * and returns a value of type @a@.

 * The type @s@ can be understood as a compiler generated unique index for state threads.
 * Every state thread is independend of each other and keeps track of mutable variables
 * created in it. For detailed information, read the paper "Lazy Functional State Threads".

 * Every mutable native data type will have a phantom type paramter @s@
 * that tells to what state thread the value belongs. For example, the @new@ method of
 * the java class @java.util.Date@ could be accessed like this:

 > data Date s = native java.util.Date where
 >     native new :: () -> ST s (Date s)

 * Inside ST actions, Date values can be created and manipulated with
 * impure native methods at will. However, such a value can never escape
 * its ST thread.

 * Because @ST s@ is an instance of 'Monad', ST actions can be combined, which
 * ensures sequenced execution. For example, we could add another method
 * to the Date type that converts the date to a string:
 * >     native toString :: Date s -> ST s String
 * and a computation which yields the current time in string form:
 * > now = do
 * >    date <- newDate ()
 * >    return date.toString
 * This looks almost like java already! @now@ has type @ST s String@ and we can run
 * the computation with @now.run@ (see 'run' below), which gives us a nice, pure, immutable,
 * functional correct 'String' value.

 * The 'IO' type is just an alias for 'ST' 'RealWorld', and can be thought of as
 * indexing the global state thread.
 * Values of type 'IO' are also called  /IO actions/.

 * Any ST value can also be used in the IO thread.

 * This guarantees that
 * - any computation with side effect is sequenced through the ST-Monad
 * - any function whose return type is not @IO something@ does not have side effects,
 *   as long as no impure native function or value is deliberately declared to be pure.
 */
abstract data ST s a = ST (s -> (a,s))  where
    private app :: ST s a -> s -> (a, s)
    private app (ST x) b = x b
    /**
     * Run a stateful action with type @ST r a@
     *
     * This is possible only if the result type @a@ of the state action does *not* mention
     * @r@ and if @r@ is a type variable.
     */
    public run :: forall a . (forall r. ST r a) -> a
    public run stx = fst (stx.app "stateful")
    public performUnsafe (ST x)  = fst (x RealWorld.RealWorld)



/**
 * This abstract data type identifies the global state (disk, network, you name it).
 * Values of type 'ST' 'RealWord' @a@ are likely to perform input/output, manipulate
 * global data and so on.
 */
abstract data RealWorld = RealWorld

/**
 * Some native values can be detached from the stateful realm so as to make it possible
 * to apply them to pure (native) functions, see 'Freezable'.
 *
 * Such values will have 'Immutable' as last type argument.
 */
abstract data Immutable = Immutable
/// @IO a@ is an abbrevation for 'ST' 'RealWorld' @a@
type IO a = ST RealWorld a
/// @Mutable MyType s@ is an abbrevation for 'ST' @s (MyType s)@
type Mutable n s = ST s (n s)
/// @Frozen MyType@ is an abbrevation for @MyType Immutable@
type Frozen  n = n Immutable

/**
 * Type class for native values that may be used in a functional way.
 * The 'freeze' operation is a 'ST' action, but yields a result that
 * can be returned from a ST thread.
 *
 * To be implemented with care.
 */
class Freezable f where
    /**
     * "Freeze" a mutable native value. The result is supposed to be immutable
     * or at least not reachable from other parts of the code, especially from java code.
     *
     * The most prominent way to freeze a value is by 'clone'-ing it, if that is supported.
     */
    freeze :: forall f s. f s -> ST s (Frozen f)
    /**
     * The inverse of 'freeze' creates a value (an object) which can be passed
     * to impure functions without compromising the frozen object passed as argument.

     * One possibility to thaw an object properly is by cloning it.

     * If 'thaw' is not implemented correctly, bad things may happen.

     */
    thaw   :: forall f s. Frozen f -> Mutable f s
    /**
     * [Usage] @withFrozen v f@ where @v@ is a mutable native value.
     * [Purpose] Temporarily freeze @v@ and pass it to a pure function @f@.
     * [Return] the result of @f v@ in the 'ST' monad.
     * [Requirements] @f@ must not fork parallel computations that could access @v@
     * after @f@ has returned.
     *
     * This function is needed to synchronize pure computations on a native value with
     * manipulations of that same value inside 'ST' actions. Consider the following code:
     * > do
     * >    arr <- IntArray.new 100
     * >    arr.[42 <- 1]
     * >    let result = arr.elemAt 42   // actually a type error
     * >    arr.[42 <- 2]
     * >    return result
     * The placement of the @let@ does not guarantee that @result@ will be evaluated between
     * the assignments to cell 42 of the array. To the contrary, the read access to the array
     * will most probably not occur before the result of the state action is evaluated.
     * Therefore, such constructs are forbidden through the type of 'IntArray.elemAt' which
     * requires a frozen array.
     *
     * The @let@ must be replaced by
     * >    result <- withFrozen arr (flip IntArray.elemAt 42)
     * to sequence evaluation before the next write access to the array.
     *
     * Because 'Freezable.withFrozen' employs 'Freezable.our' it can be as easily misused.
     * In fact @withFrozen v id@ is identical to @our v@.
     */
    withFrozen :: forall f s a. f s -> (Frozen f -> a) -> ST s a
    withFrozen v f  = our v >>= (return • f)

    /**
     * [Usage] @our v@ as last action in a *do* block that created mutable native value @v@
     * [Purpose] Make a value that is identical to @v@ but has 'Immutable' as phantom type.
     * This allows escape of mutable native values from 'ST' actions. Yet, because these
     * values are tagged 'Immutable', unsafe operations are impossible outside the 'ST'
     * monad as long as all impure native functions are correctly defined. One can pass
     * the value to another 'ST' action, which may 'Freezable.thaw' it and apply
     * impure native functions again.
     * [Returns] a copy of @v@ tagged as 'Immutable' in the 'ST' monad
     *
     * This is intended for cases where want to keep the native value and we know
     * that there are no references to
     * the native value other than the ones maintained in the current 'ST' action.
     * In those not so rare cases, it would be overkill to obtain a copy
     * of a value by cloning it or serializing/deserializing it. Hence, an
     * implementation of 'Freezable.our' is allowed to cheat a bit and return just @this@.
     *
     * The safety of 'Freezable' operations is something the compiler cannot infer.
     * It lies entirely in the responsibility
     * of the programmer to ensure safety. Remember that violation of the informal
     * contract of 'Freezable' (see below)
     * will be rewarded with exceptions thrown at runtime or
     * with inexplicable, perhaps nondeterministic behaviour of the program.
     *
     * An example where 'Freezable.our' is employed
     * is creation and initialization of arrays, as in 'IntArray.fromList'.
     * When the array is completely initialized, it is safe to let it escape
     * as a read only value because no further write accesses are possible (unless one
     * manages to pass the array to an impure function.)
     *
     * This is the informal contract of 'Freezable' and its operations.
     * It is designed so that the
     * type system will detect unsafe usage of mutable native values. The programmer
     * should understand that such type errors are a strong signal to go back and rethink
     * the code. Inventing "clever" workarounds in the form of creatively typed
     * native functions or so is like loading a shotgun that points to ones foot.
     * - All mutable native data types have a frege type with a phantom type as its
     *   last type argument. (i.e. @data Date s = native java.util.Date@)
     * - All impure functions have the same type variable (say @s@) for the
     *   phantom type of mutable types that appear in their type
     *   and have a result of 'ST' @s@ /a/.
     * - All object creation functions have a return type of @ST s (M s)@ or @Mutable M s@
     *   where @M@ is the type constructor of the native values frege type.
     * - If the function relies on global state, alters global state or performs input or output,
     *   the return type must be 'ST' 'RealWorld' /a/. Consequently,
     *   all mutable types that appear in
     *   the type signature must have 'RealWorld' as phantom type.
     * - In pure functions, the mutable data types *must* appear as @M Immutable@.
     *   The return type is an ordinary type (no 'ST' type).
     * - If the type is an instance of 'Freezable', then the implmentations of
     *    'Freezable.freeze' and  'Freezable.thaw' create fresh objects.
     *    This is true for instances of 'Cloneable' and 'Serializable' that use the
     *    default type class methods (i.e., do not supply own implementations).
     *  - 'Freezable.our' is used only when there are no alien references to the value *or*
     *    if a fresh object is created.
     *
     *  The default implementation does the same as 'Freezable.freeze'. A generic native
     *  method to implement a low cost 'Freezable.our'
     *  is provided in the runtime as @frege.RT.our@. It just returns its argument.
     */
    our :: forall f s. f s -> ST s (Frozen f)
    our f = freeze f



/**
 * For a data type declared like
 * > data D s = native Javatype
 * where @Javatype@ implements the @java.lang.Cloneable@ interface,
 * one can get implementations for 'Freezable.freeze'
 * and 'Freezable.thaw' by just stating
 * > instance Cloneable D
 * The 'freeze' and 'thaw' operations are implemented in terms of 'clone'.
 */
class Cloneable (Freezable f) => f  where
    /**
     *  @clone v@ must be a native method that works like @java.lang.Object#clone@.
     */
    pure native clone :: f a -> f b
    freeze x = ST.return (clone x)
    thaw   x = ST.return (clone x)

/**
 * For a data type declared like
 * > data D s = native Javatype
 * where @Javatype@ implements the @java.io.Serializable@ interface,
 * one can get implementations for 'freeze'
 * and 'thaw' by just stating
 * > instance Serializable D
 * The 'freeze' and 'thaw' operations are implemented in terms of @copySerializable@,
 * which serializes its argument to a byte array and creates a new copy by
 * deserializing it from the byte array.
 */
class Serializable (Freezable f) => f  where
    /**
     *  @copySerializable v@ is supposed to be a native function that is
     *  implemented by @frege.RT.copySerializable@ at the instantiated type.
     */
    pure native copySerializable frege.RT.copySerializable :: f a -> f b
    freeze x = ST.return (copySerializable x)
    thaw   x = ST.return (copySerializable x)

// ########## Variables ###########################
data STRef a s = native frege.rt.Ref where
    native new         :: a -> Mutable (STRef a) s
    native get         :: STRef a s -> ST s a
    native put         :: STRef a s -> a -> ST s ()

type IORef a = STRef a RealWorld


/**
    @when condition monadic@ returns /action/ of type @Monad:m ()@
    if /condition/ is true, otherwise 'return' '()'.
*/
when c ioa   = if c then ioa else return ()

/** opposite of 'when' */
unless c ios = when (not c) ios

/** @void@ is short for 'IO.return' '()' */
void = IO.return ()

/**
 * @State s a@ is an abstrac data type that resembles a stateful computation
 * with state /s/ and result /a/,
 * i.e. functions of type @s -> (a, s)@
 * where the state is immutable
 */
abstract data State s a = State (s -> (a, s)) where
    /// run a stateful computation
    public run (State x) s = x s
    /// get the current state from inside the state monad
    public get   = State getHelper where getHelper x = (x; x)
    /// update the state in the state monad
    public put !x = State (putHelper x) where putHelper x = const ((); x)
    /// change the state
    public change f = State (chgHelper f) where chgHelper f s = ((); f s)



/**
 * the monad for construction of stateful computations
 */
instance Monad (State s) where
    return a = State.State (strictTuple2 a)
    State.State !m >>= k = State.State (bindState m k) where
        bindState :: (s -> (a,s)) -> (a -> State s b) -> s -> (b, s)
        bindState a k s = case a s of
                        (v, !s') -> case k v of State.State b -> b s'
    fail s = error s

instance Monad (ST s) where
    return a = ST.ST (strictTuple2 a)
    ST.ST !a >>= k = ST.ST (bindST a k) where
        // this is defined so that it can be identified in stack traces or post mortem dumps
        bindST :: (x -> (y, x)) -> (y -> ST x z) -> x -> (z, x)
        bindST a k u = case a u of
                       (!v, u') -> case k v of ST.ST b -> b u'
    fail s = error s

// this is defined so that it can be identified in stack traces or post mortem dumps
// bindST :: (x -> (y, x)) -> (y -> ST x z) -> x -> (z, x)
// bindST a k u = case a u of
//    (!v, u') -> case k v of ST.ST b -> b u'

native traceStr java.lang.System.err.print     :: String -> IO ();
native printStr java.lang.System.out.print     :: String -> IO ();
native printStrLn java.lang.System.out.println :: String -> IO ();
print d = printStr (display d);
println d = printStrLn (display d);

trace   str = IO.performUnsafe (traceStr str >> IO.return false)
traceLn str = trace (str ++ "\n")
  